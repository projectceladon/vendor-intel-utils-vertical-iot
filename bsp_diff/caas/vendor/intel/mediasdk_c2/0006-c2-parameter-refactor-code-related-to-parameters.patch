From f2bc107ffe67ce037e01544b5307c05721898241 Mon Sep 17 00:00:00 2001
From: "Kothapeta, BikshapathiX" <bikshapathix.kothapeta@intel.com>
Date: Fri, 25 Nov 2022 11:33:50 +0530
Subject: [PATCH] [c2][parameter] refactor code related to parameters

using Google's C2ReflectorHelper replaces self-built reflector.

Tracked-On: OAM-104993
Signed-off-by: zhangyichix <yichix.zhang@intel.com>
Signed-off-by: Kothapeta, BikshapathiX <bikshapathix.kothapeta@intel.com>

diff --git a/c2_components/include/mfx_c2_component.h b/c2_components/include/mfx_c2_component.h
index 55606cf..ead1531 100755
--- a/c2_components/include/mfx_c2_component.h
+++ b/c2_components/include/mfx_c2_component.h
@@ -24,11 +24,13 @@
 
 #include "mfx_defs.h"
 #include "mfx_c2_param_storage.h"
+#include "util/C2InterfaceHelper.h"
 #include <mutex>
 
 class MfxC2Component : public C2ComponentInterface,
                        public C2Component,
-                       public std::enable_shared_from_this<MfxC2Component>
+                       public std::enable_shared_from_this<MfxC2Component>,
+                       public C2InterfaceHelper
 {
 public:
     struct CreateConfig
@@ -72,7 +74,7 @@ protected:
     };
 
 protected:
-    MfxC2Component(const C2String& name, const CreateConfig& config, std::shared_ptr<MfxC2ParamReflector> reflector);
+    MfxC2Component(const C2String& name, const CreateConfig& config, std::shared_ptr<C2ReflectorHelper> reflector);
     MFX_CLASS_NO_COPY(MfxC2Component)
 
     // provides static Create method to registrate in components registry
@@ -96,13 +98,13 @@ private: // Non-virtual interface methods optionally overridden in descendants
 
     virtual c2_status_t Release() { return C2_OK; }
 
-    virtual c2_status_t Query(std::unique_lock<std::mutex>/*state_lock*/,
+    virtual c2_status_t UpdateMfxParamToC2(std::unique_lock<std::mutex>/*state_lock*/,
         const std::vector<C2Param*>&/*stackParams*/,
         const std::vector<C2Param::Index> &/*heapParamIndices*/,
         c2_blocking_t /*mayBlock*/,
         std::vector<std::unique_ptr<C2Param>>* const /*heapParams*/) const { return C2_OMITTED; }
 
-    virtual c2_status_t Config(std::unique_lock<std::mutex>/*state_lock*/,
+    virtual c2_status_t UpdateC2ParamToMfx(std::unique_lock<std::mutex>/*state_lock*/,
         const std::vector<C2Param*> &/*params*/,
         c2_blocking_t /*mayBlock*/,
         std::vector<std::unique_ptr<C2SettingResult>>* const /*failures*/) { return C2_OMITTED; }
@@ -192,8 +194,6 @@ protected: // variables
 
     CreateConfig m_createConfig;
 
-    MfxC2ParamStorage m_paramStorage;
-
     mfxIMPL m_mfxImplementation;
 
 private:
@@ -204,7 +204,7 @@ private:
 
 typedef MfxC2Component* (CreateMfxC2ComponentFunc)(const char* name,
     const MfxC2Component::CreateConfig& config,
-    std::shared_ptr<MfxC2ParamReflector> reflector, c2_status_t* status);
+    std::shared_ptr<C2ReflectorHelper> reflector, c2_status_t* status);
 
 template<typename ComponentClass, typename... ArgTypes>
 struct MfxC2Component::Factory
@@ -213,7 +213,7 @@ struct MfxC2Component::Factory
     // variadic args are passed to constructor
     template<ArgTypes... arg_values>
     static MfxC2Component* Create(const char* name, const CreateConfig& config,
-        std::shared_ptr<MfxC2ParamReflector> reflector, c2_status_t* status)
+        std::shared_ptr<C2ReflectorHelper> reflector, c2_status_t* status)
     {
         c2_status_t result = C2_OK;
         // class to make constructor public and get access to new operator
@@ -221,7 +221,7 @@ struct MfxC2Component::Factory
         {
         public:
             ConstructedClass(const char* name, const CreateConfig& config,
-                std::shared_ptr<MfxC2ParamReflector> reflector, ArgTypes... constructor_args) :
+                std::shared_ptr<C2ReflectorHelper> reflector, ArgTypes... constructor_args) :
                     ComponentClass(name, config, std::move(reflector), constructor_args...) { }
         };
 
diff --git a/c2_components/include/mfx_c2_components_registry.h b/c2_components/include/mfx_c2_components_registry.h
index 25aeeb8..9bb294e 100755
--- a/c2_components/include/mfx_c2_components_registry.h
+++ b/c2_components/include/mfx_c2_components_registry.h
@@ -45,7 +45,7 @@ public:
     static MfxC2ComponentsRegistry& getInstance();
 
     c2_status_t CreateMfxC2Component(const char* name, const MfxC2Component::CreateConfig& config,
-        std::shared_ptr<MfxC2ParamReflector> reflector, MfxC2Component** component);
+        std::shared_ptr<C2ReflectorHelper> reflector, MfxC2Component** component);
 
     void RegisterMfxC2Component(const std::string& name, CreateMfxC2ComponentFunc* createFunc);
 
diff --git a/c2_components/include/mfx_c2_decoder_component.h b/c2_components/include/mfx_c2_decoder_component.h
index 4bb568a..d3e2f15 100755
--- a/c2_components/include/mfx_c2_decoder_component.h
+++ b/c2_components/include/mfx_c2_decoder_component.h
@@ -29,6 +29,7 @@
 #include "mfx_frame_pool_allocator.h"
 #include "mfx_gralloc_allocator.h"
 #include "mfx_c2_color_aspects_wrapper.h"
+#include "mfx_c2_setters.h"
 
 class MfxC2DecoderComponent : public MfxC2Component
 {
@@ -44,7 +45,7 @@ public:
 
 protected:
     MfxC2DecoderComponent(const C2String name, const CreateConfig& config,
-        std::shared_ptr<MfxC2ParamReflector> reflector, DecoderType decoder_type);
+        std::shared_ptr<C2ReflectorHelper> reflector, DecoderType decoder_type);
 
     MFX_CLASS_NO_COPY(MfxC2DecoderComponent)
 
@@ -63,14 +64,14 @@ protected:
 
     c2_status_t Release() override;
 
-    c2_status_t Query(
+    c2_status_t UpdateMfxParamToC2(
         std::unique_lock<std::mutex> state_lock,
         const std::vector<C2Param*> &stackParams,
         const std::vector<C2Param::Index> &heapParamIndices,
         c2_blocking_t mayBlock,
         std::vector<std::unique_ptr<C2Param>>* const heapParams) const override;
 
-    c2_status_t Config(
+    c2_status_t UpdateC2ParamToMfx(
         std::unique_lock<std::mutex> state_lock,
         const std::vector<C2Param*> &params,
         c2_blocking_t mayBlock,
@@ -96,10 +97,9 @@ protected:
     c2_status_t Flush(std::list<std::unique_ptr<C2Work>>* const flushedWork) override;
 
 private:
-    c2_status_t QueryParam(const mfxVideoParam* src,
-        C2Param::Index index, C2Param** dst) const;
+    c2_status_t UpdateC2Param(const mfxVideoParam* src, C2Param::Index index) const;
 
-    void DoConfig(const std::vector<C2Param*> &params,
+    void DoUpdateMfxParam(const std::vector<C2Param*> &params,
         std::vector<std::unique_ptr<C2SettingResult>>* const failures,
         bool queue_update);
 
@@ -153,7 +153,7 @@ private:
 
     void UpdateHdrStaticInfo();
 
-    std::shared_ptr<C2StreamColorAspectsInfo::output> getColorAspects_l();
+    std::shared_ptr<C2StreamColorAspectsInfo::output> getColorAspects_l() const;
 
 private:
     DecoderType m_decoderType;
@@ -215,7 +215,7 @@ private:
     std::shared_ptr<MfxFramePoolAllocator> m_allocator; // used when Video memory output
     // for pre-allocation when Video memory is chosen and always when System memory output
     std::shared_ptr<C2BlockPool> m_c2Allocator;
-    C2BlockPool::local_id_t m_outputPoolId = C2BlockPool::BASIC_GRAPHIC;
+    C2BlockPool::local_id_t m_outputPoolId = C2BlockPool::PLATFORM_START;
     std::unique_ptr<MfxGrallocAllocator> m_grallocAllocator;
     std::atomic<bool> m_bFlushing{false};
 
@@ -228,7 +228,7 @@ private:
     std::shared_ptr<C2StreamHdrStaticInfo::output> m_hdrStaticInfo;
     bool m_bSetHdrStatic;
 
-    MfxC2ColorAspectsWrapper m_colorAspects;
+    MfxC2ColorAspectsWrapper m_colorAspectsWrapper;
 
     std::shared_ptr<C2StreamPixelFormatInfo::output> m_pixelFormat;
 
@@ -241,4 +241,44 @@ private:
 
     unsigned int m_uOutputDelay = 8u;
     unsigned int m_uInputDelay = 0u;
+
+    /* -----------------------C2Parameters--------------------------- */
+    std::shared_ptr<C2ComponentNameSetting> m_name;
+    std::shared_ptr<C2ComponentKindSetting> m_kind;
+    std::shared_ptr<C2ComponentDomainSetting> m_domain;
+    std::shared_ptr<C2StreamPictureSizeInfo::output> m_size;
+    std::shared_ptr<C2PortSurfaceAllocatorTuning::output> m_surfaceAllocator;
+    std::shared_ptr<C2PortAllocatorsTuning::input> m_inputAllocators;
+    std::shared_ptr<C2PortAllocatorsTuning::output> m_outputAllocators;
+    std::shared_ptr<C2StreamMaxPictureSizeTuning::output> m_maxSize;
+    std::shared_ptr<C2StreamMaxBufferSizeInfo::input> m_maxInputSize;
+    std::shared_ptr<C2PortMediaTypeSetting::output> m_outputMediaType;
+    std::shared_ptr<C2PortRequestedDelayTuning::output> m_requestedOutputDelay;
+    std::shared_ptr<C2PortBlockPoolsTuning::output> m_outputPoolIds;
+    std::shared_ptr<C2PortMediaTypeSetting::input> m_inputMediaType;
+    std::shared_ptr<C2StreamBufferTypeSetting::input> m_inputFormat;
+    std::shared_ptr<C2StreamBufferTypeSetting::output> m_outputFormat;
+    std::shared_ptr<C2StreamProfileLevelInfo::input> m_profileLevel;
+    std::shared_ptr<C2PortActualDelayTuning::output> m_actualOutputDelay;
+    std::shared_ptr<C2PortRequestedDelayTuning::input> m_requestedInputDelay;
+    std::shared_ptr<C2PortActualDelayTuning::input> m_actualInputDelay;
+    std::shared_ptr<C2PortDelayTuning::input> m_inputDelay;
+    std::shared_ptr<C2StreamColorAspectsTuning::output> m_defaultColorAspects;
+    std::shared_ptr<C2StreamColorAspectsInfo::input> m_codedColorAspects;
+    std::shared_ptr<C2StreamColorAspectsInfo::output> m_colorAspects;
+    /* ----------------------------------------Setters------------------------------------------- */
+    static C2R OutputSurfaceAllocatorSetter(bool mayBlock, C2P<C2PortSurfaceAllocatorTuning::output> &me);
+    static C2R SizeSetter(bool mayBlock, const C2P<C2StreamPictureSizeInfo::output> &oldMe,
+                        C2P<C2StreamPictureSizeInfo::output> &me);
+    static C2R MaxPictureSizeSetter(bool mayBlock, C2P<C2StreamMaxPictureSizeTuning::output> &me,
+                                const C2P<C2StreamPictureSizeInfo::output> &size);
+    static C2R MaxInputSizeSetter(bool mayBlock, C2P<C2StreamMaxBufferSizeInfo::input> &me,
+                                const C2P<C2StreamMaxPictureSizeTuning::output> &maxSize);
+    static C2R ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::input> &me,
+                                  const C2P<C2StreamPictureSizeInfo::output> &size);
+    static C2R DefaultColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsTuning::output> &me);
+    static C2R CodedColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::input> &me);
+    static C2R ColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::output> &me,
+                                const C2P<C2StreamColorAspectsTuning::output> &def,
+                                const C2P<C2StreamColorAspectsInfo::input> &coded);
 };
diff --git a/c2_components/include/mfx_c2_encoder_component.h b/c2_components/include/mfx_c2_encoder_component.h
index 0ddc585..a03fde9 100755
--- a/c2_components/include/mfx_c2_encoder_component.h
+++ b/c2_components/include/mfx_c2_encoder_component.h
@@ -28,6 +28,7 @@
 #include "mfx_c2_bitstream_out.h"
 #include "mfx_c2_utils.h"
 #include "mfx_c2_vpp_wrapp.h"
+#include "mfx_c2_setters.h"
 
 // Assumes all calls are done from one (working) thread, no sync is needed.
 // m_ctrlOnce accumulates subsequent changes for one next frame.
@@ -59,7 +60,7 @@ public:
 
 protected:
     MfxC2EncoderComponent(const C2String name, const CreateConfig& config,
-        std::shared_ptr<MfxC2ParamReflector> reflector, EncoderType encoder_type);
+        std::shared_ptr<C2ReflectorHelper> reflector, EncoderType encoder_type);
 
     MFX_CLASS_NO_COPY(MfxC2EncoderComponent)
 
@@ -78,14 +79,14 @@ protected:
 
     c2_status_t Release() override;
 
-    c2_status_t Query(
+    c2_status_t UpdateMfxParamToC2(
         std::unique_lock<std::mutex> state_lock,
         const std::vector<C2Param*> &stackParams,
         const std::vector<C2Param::Index> &heapParamIndices,
         c2_blocking_t mayBlock,
         std::vector<std::unique_ptr<C2Param>>* const heapParams) const override;
 
-    c2_status_t Config(
+    c2_status_t UpdateC2ParamToMfx(
         std::unique_lock<std::mutex> state_lock,
         const std::vector<C2Param*> &params,
         c2_blocking_t mayBlock,
@@ -94,8 +95,7 @@ protected:
     c2_status_t Queue(std::list<std::unique_ptr<C2Work>>* const items) override;
 
 private:
-    c2_status_t QueryParam(const mfxVideoParam* src,
-        C2Param::Index index, C2Param** dst) const;
+    c2_status_t UpdateC2Param(C2Param::Index index) const;
 
     std::unique_ptr<mfxVideoParam> GetParamsView() const;
 
@@ -122,7 +122,7 @@ private:
     c2_status_t AllocateBitstream(const std::unique_ptr<C2Work>& work,
         MfxC2BitstreamOut* mfx_bitstream);
 
-    void DoConfig(const std::vector<C2Param*> &params,
+    void DoUpdateMfxParam(const std::vector<C2Param*> &params,
         std::vector<std::unique_ptr<C2SettingResult>>* const failures,
         bool queue_update);
 
@@ -215,9 +215,42 @@ private:
     MfxC2Conversion m_inputVppType;
 
     mfxExtVideoSignalInfo m_signalInfo;
-    std::shared_ptr<C2StreamColorAspectsInfo::input> m_colorAspects;
-    std::shared_ptr<C2StreamColorAspectsInfo::output> m_codedColorAspects;
 
     // Input frame info with width or height not 16byte aligned
     mfxFrameInfo m_mfxInputInfo;
+
+    /* -----------------------C2Parameters--------------------------- */
+    std::mutex m_c2ParameterMutex;
+    std::shared_ptr<C2ComponentNameSetting> m_name;
+    std::shared_ptr<C2ComponentKindSetting> m_kind;
+    std::shared_ptr<C2ComponentDomainSetting> m_domain;
+    std::shared_ptr<C2StreamBufferTypeSetting::input> m_inputFormat;
+    std::shared_ptr<C2StreamBufferTypeSetting::output> m_outputFormat;
+    std::shared_ptr<C2PortMediaTypeSetting::input> m_inputMediaType;
+    std::shared_ptr<C2PortMediaTypeSetting::output> m_outputMediaType;
+    std::shared_ptr<C2StreamProfileLevelInfo::output> m_profileLevel;
+    std::shared_ptr<C2StreamPictureSizeInfo::input> m_size;
+    std::shared_ptr<C2StreamFrameRateInfo::output> m_frameRate;
+    std::shared_ptr<C2StreamBitrateInfo::output> m_bitrate;
+    std::shared_ptr<C2StreamBitrateModeTuning::output> m_bitrateMode;
+    std::shared_ptr<C2StreamGopTuning::output> m_gop;
+    std::shared_ptr<C2StreamRequestSyncFrameTuning::output> m_requestSync;
+    std::shared_ptr<C2StreamSyncFrameIntervalTuning::output> m_syncFramePeriod;
+    std::shared_ptr<C2StreamIntraRefreshTuning::output> m_intraRefresh;
+    std::shared_ptr<C2StreamColorAspectsInfo::input> m_colorAspects;
+    std::shared_ptr<C2StreamColorAspectsInfo::output> m_codedColorAspects;
+    /* ---------------------------------Setters------------------------------------------- */
+    static C2R SizeSetter(bool mayBlock, const C2P<C2StreamPictureSizeInfo::input> &oldMe,
+                        C2P<C2StreamPictureSizeInfo::input> &me);
+    
+    static C2R AVC_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me);
+    static C2R HEVC_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me);
+    static C2R VP9_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me);
+
+    static C2R BitrateSetter(bool mayBlock, C2P<C2StreamBitrateInfo::output> &me);
+    static C2R GopSetter(bool mayBlock, C2P<C2StreamGopTuning::output> &me);
+    static C2R IntraRefreshSetter(bool mayBlock, C2P<C2StreamIntraRefreshTuning::output> &me);
+    static C2R ColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::input> &me);
+    static C2R CodedColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::output> &me,
+                                    const C2P<C2StreamColorAspectsInfo::input> &coded);
 };
diff --git a/c2_components/src/mfx_c2_component.cpp b/c2_components/src/mfx_c2_component.cpp
index df6730a..34184a7 100755
--- a/c2_components/src/mfx_c2_component.cpp
+++ b/c2_components/src/mfx_c2_component.cpp
@@ -28,10 +28,10 @@ using namespace android;
 #undef MFX_DEBUG_MODULE_NAME
 #define MFX_DEBUG_MODULE_NAME "mfx_c2_component"
 
-MfxC2Component::MfxC2Component(const C2String& name, const CreateConfig& config, std::shared_ptr<MfxC2ParamReflector> reflector) :
+MfxC2Component::MfxC2Component(const C2String& name, const CreateConfig& config, std::shared_ptr<C2ReflectorHelper> reflector) :
+    C2InterfaceHelper(reflector),
     m_name(name),
     m_createConfig(config),
-    m_paramStorage(std::move(reflector)),
     m_mfxImplementation(MFX_IMPLEMENTATION)
 {
     MFX_DEBUG_TRACE_FUNC;
@@ -126,16 +126,27 @@ c2_status_t MfxC2Component::query_vb(
         lock.try_lock();
     }
 
+    // Func query will return c2 params to framework, so we must update MFX params to c2 before calling it.
     if (lock.owns_lock()) {
         if (State::RELEASED != m_state) {
-            res = Query(std::move(lock), stackParams, heapParamIndices, mayBlock, heapParams);
+            res = UpdateMfxParamToC2(std::move(lock), stackParams, heapParamIndices, mayBlock, heapParams);
         } else {
             res = C2_BAD_STATE;
         }
     } else {
         res = C2_BLOCKING;
     }
-    return res;
+    
+    if (C2_OK != res)
+    {
+        MFX_DEBUG_TRACE__android_c2_status_t(res);
+        return res;
+    }
+    
+    res = query(stackParams, heapParamIndices, mayBlock, heapParams);
+    MFX_DEBUG_TRACE__android_c2_status_t(res);
+    
+    return C2_OK;
 }
 
 c2_status_t MfxC2Component::config_vb(
@@ -144,19 +155,23 @@ c2_status_t MfxC2Component::config_vb(
     std::vector<std::unique_ptr<C2SettingResult>>* const failures)
 {
     MFX_DEBUG_TRACE_FUNC;
-
     c2_status_t res = C2_OK;
+    res = config(params, mayBlock, failures);
 
     std::unique_lock<std::mutex> lock = AcquireStableStateLock(mayBlock == C2_MAY_BLOCK);
+
+    // Func config brings us the updated values which we have to sync to MFX params.
     if (lock.owns_lock()) {
         if (State::RELEASED != m_state) {
-            res = Config(std::move(lock), params, mayBlock, failures);
+            res = UpdateC2ParamToMfx(std::move(lock), params, mayBlock, failures);
         } else {
             res = C2_BAD_STATE;
         }
     } else {
         res = C2_BLOCKING;
     }
+
+    MFX_DEBUG_TRACE__android_c2_status_t(res);
     return res;
 }
 
@@ -182,8 +197,10 @@ c2_status_t MfxC2Component::querySupportedParams_nb(
     std::vector<std::shared_ptr<C2ParamDescriptor>>* const params) const
 {
     MFX_DEBUG_TRACE_FUNC;
-
-    return m_paramStorage.getSupportedParams(params);
+    c2_status_t res = C2_OK;
+    res = querySupportedParams(params);
+    MFX_DEBUG_TRACE__android_c2_status_t(res);
+    return res;
 }
 
 c2_status_t MfxC2Component::querySupportedValues_vb(
@@ -192,18 +209,7 @@ c2_status_t MfxC2Component::querySupportedValues_vb(
     MFX_DEBUG_TRACE_FUNC;
 
     c2_status_t res = C2_OK;
-
-    std::unique_lock<std::mutex> lock = AcquireStableStateLock(mayBlock == C2_MAY_BLOCK);
-    if (lock.owns_lock()) {
-        if (State::RELEASED != m_state) {
-            res = m_paramStorage.querySupportedValues_vb(queries, mayBlock);
-        } else {
-            res = C2_BAD_STATE;
-        }
-    } else {
-        res = C2_BLOCKING;
-    }
-
+    res = querySupportedValues(queries, mayBlock);
     MFX_DEBUG_TRACE__android_c2_status_t(res);
     return res;
 }
diff --git a/c2_components/src/mfx_c2_components_registry.cpp b/c2_components/src/mfx_c2_components_registry.cpp
index ca3a8e1..d4a8436 100755
--- a/c2_components/src/mfx_c2_components_registry.cpp
+++ b/c2_components/src/mfx_c2_components_registry.cpp
@@ -42,7 +42,7 @@ using namespace android;
 extern "C" EXPORT MfxC2Component* MfxCreateC2Component(
     const char* name,
     const MfxC2Component::CreateConfig& config,
-    std::shared_ptr<MfxC2ParamReflector> reflector,
+    std::shared_ptr<C2ReflectorHelper> reflector,
     c2_status_t* status)
 {
     MFX_DEBUG_TRACE_FUNC;
@@ -78,7 +78,7 @@ MfxC2ComponentsRegistry& MfxC2ComponentsRegistry::getInstance()
 
 c2_status_t MfxC2ComponentsRegistry::CreateMfxC2Component(const char* name,
     const MfxC2Component::CreateConfig& config,
-    std::shared_ptr<MfxC2ParamReflector> reflector, MfxC2Component** component)
+    std::shared_ptr<C2ReflectorHelper> reflector, MfxC2Component** component)
 {
     MFX_DEBUG_TRACE_FUNC;
 
diff --git a/c2_components/src/mfx_c2_decoder_component.cpp b/c2_components/src/mfx_c2_decoder_component.cpp
index 4fe12ce..0c54e51 100755
--- a/c2_components/src/mfx_c2_decoder_component.cpp
+++ b/c2_components/src/mfx_c2_decoder_component.cpp
@@ -39,9 +39,11 @@ using namespace android;
 #undef MFX_DEBUG_MODULE_NAME
 #define MFX_DEBUG_MODULE_NAME "mfx_c2_decoder_component"
 
-const c2_nsecs_t TIMEOUT_NS = MFX_SECOND_NS;
-const uint64_t kMinInputBufferSize = 2 * WIDTH_2K * HEIGHT_2K;
-const uint64_t kDefaultConsumerUsage =
+constexpr uint32_t MIN_W = 176;
+constexpr uint32_t MIN_H = 144;
+constexpr c2_nsecs_t TIMEOUT_NS = MFX_SECOND_NS;
+constexpr uint64_t kMinInputBufferSize = 2 * WIDTH_2K * HEIGHT_2K;
+constexpr uint64_t kDefaultConsumerUsage =
     (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER);
 
 
@@ -56,8 +58,111 @@ enum VP8_LEVEL {
     LEVEL_VP8_Version0 = C2_PROFILE_LEVEL_VENDOR_START,
 };
 
+
+C2R MfxC2DecoderComponent::OutputSurfaceAllocatorSetter(bool mayBlock, C2P<C2PortSurfaceAllocatorTuning::output> &me) {
+    (void)mayBlock;
+    (void)me;
+    C2R res = C2R::Ok();
+
+    return res;
+}
+
+C2R MfxC2DecoderComponent::SizeSetter(bool mayBlock, const C2P<C2StreamPictureSizeInfo::output> &oldMe,
+                                    C2P<C2StreamPictureSizeInfo::output> &me) {
+    (void)mayBlock;
+    C2R res = C2R::Ok();
+    if (!me.F(me.v.width).supportsAtAll(me.v.width)) {
+        res = res.plus(C2SettingResultBuilder::BadValue(me.F(me.v.width)));
+        me.set().width = oldMe.v.width;
+    }
+    if (!me.F(me.v.height).supportsAtAll(me.v.height)) {
+        res = res.plus(C2SettingResultBuilder::BadValue(me.F(me.v.height)));
+        me.set().height = oldMe.v.height;
+    }
+    return res;
+}
+
+C2R MfxC2DecoderComponent::MaxPictureSizeSetter(bool mayBlock, C2P<C2StreamMaxPictureSizeTuning::output> &me,
+                                            const C2P<C2StreamPictureSizeInfo::output> &size) {
+    (void)mayBlock;
+    // TODO: get max width/height from the size's field helpers vs. hardcoding
+    me.set().width = c2_min(c2_max(me.v.width, size.v.width), uint32_t(WIDTH_8K));
+    me.set().height = c2_min(c2_max(me.v.height, size.v.height), uint32_t(HEIGHT_8K));
+    ALOGD("zyc, max.w = %d, h = %d", me.set().width, me.set().height);
+    return C2R::Ok();
+}
+
+C2R MfxC2DecoderComponent::MaxInputSizeSetter(bool mayBlock, C2P<C2StreamMaxBufferSizeInfo::input> &me,
+                                const C2P<C2StreamMaxPictureSizeTuning::output> &maxSize) {
+    (void)mayBlock;
+    // assume compression ratio of 2
+    me.set().value = c2_max((((maxSize.v.width + 15) / 16)
+            * ((maxSize.v.height + 15) / 16) * 192), kMinInputBufferSize);
+    ALOGD("zyc, input size = %d", me.set().value);
+    me.set().value = kMinInputBufferSize;
+    return C2R::Ok();
+}
+
+C2R MfxC2DecoderComponent::ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::input> &me,
+                                  const C2P<C2StreamPictureSizeInfo::output> &size) {
+    (void)mayBlock;
+    (void)size;
+    (void)me;  // TODO: validate
+    return C2R::Ok();
+}
+
+C2R MfxC2DecoderComponent::DefaultColorAspectsSetter(bool mayBlock,
+                                            C2P<C2StreamColorAspectsTuning::output> &me) {
+    (void)mayBlock;
+    if (me.v.range > C2Color::RANGE_OTHER) {
+            me.set().range = C2Color::RANGE_OTHER;
+    }
+    if (me.v.primaries > C2Color::PRIMARIES_OTHER) {
+            me.set().primaries = C2Color::PRIMARIES_OTHER;
+    }
+    if (me.v.transfer > C2Color::TRANSFER_OTHER) {
+            me.set().transfer = C2Color::TRANSFER_OTHER;
+    }
+    if (me.v.matrix > C2Color::MATRIX_OTHER) {
+            me.set().matrix = C2Color::MATRIX_OTHER;
+    }
+    return C2R::Ok();
+}
+
+C2R MfxC2DecoderComponent::CodedColorAspectsSetter(bool mayBlock,
+                                            C2P<C2StreamColorAspectsInfo::input> &me) {
+    (void)mayBlock;
+    if (me.v.range > C2Color::RANGE_OTHER) {
+            me.set().range = C2Color::RANGE_OTHER;
+    }
+    if (me.v.primaries > C2Color::PRIMARIES_OTHER) {
+            me.set().primaries = C2Color::PRIMARIES_OTHER;
+    }
+    if (me.v.transfer > C2Color::TRANSFER_OTHER) {
+            me.set().transfer = C2Color::TRANSFER_OTHER;
+    }
+    if (me.v.matrix > C2Color::MATRIX_OTHER) {
+            me.set().matrix = C2Color::MATRIX_OTHER;
+    }
+    return C2R::Ok();
+}
+
+C2R MfxC2DecoderComponent::ColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::output> &me,
+                                const C2P<C2StreamColorAspectsTuning::output> &def,
+                                const C2P<C2StreamColorAspectsInfo::input> &coded) {
+    (void)mayBlock;
+    // take default values for all unspecified fields, and coded values for specified ones
+    me.set().range = coded.v.range == RANGE_UNSPECIFIED ? def.v.range : coded.v.range;
+    me.set().primaries = coded.v.primaries == PRIMARIES_UNSPECIFIED
+            ? def.v.primaries : coded.v.primaries;
+    me.set().transfer = coded.v.transfer == TRANSFER_UNSPECIFIED
+            ? def.v.transfer : coded.v.transfer;
+    me.set().matrix = coded.v.matrix == MATRIX_UNSPECIFIED ? def.v.matrix : coded.v.matrix;
+    return C2R::Ok();
+}
+
 MfxC2DecoderComponent::MfxC2DecoderComponent(const C2String name, const CreateConfig& config,
-    std::shared_ptr<MfxC2ParamReflector> reflector, DecoderType decoder_type) :
+    std::shared_ptr<C2ReflectorHelper> reflector, DecoderType decoder_type) :
         MfxC2Component(name, config, std::move(reflector)),
         m_decoderType(decoder_type),
 #ifdef USE_ONEVPL
@@ -70,298 +175,446 @@ MfxC2DecoderComponent::MfxC2DecoderComponent(const C2String name, const CreateCo
         m_surfaceNum(0)
 {
     MFX_DEBUG_TRACE_FUNC;
-
-    MfxC2ParamStorage& pr = m_paramStorage;
-
-    pr.RegisterParam<C2MemoryTypeSetting>("MemoryType");
-    pr.RegisterParam<C2PortAllocatorsTuning::output>(C2_PARAMKEY_OUTPUT_ALLOCATORS);
-    pr.RegisterParam<C2PortSurfaceAllocatorTuning::output>(C2_PARAMKEY_OUTPUT_SURFACE_ALLOCATOR);
-    pr.RegisterParam<C2PortBlockPoolsTuning::output>(C2_PARAMKEY_OUTPUT_BLOCK_POOLS);
-    pr.RegisterParam<C2StreamUsageTuning::output>(C2_PARAMKEY_OUTPUT_STREAM_USAGE);
-
-    pr.AddValue(C2_PARAMKEY_COMPONENT_DOMAIN,
-        std::make_unique<C2ComponentDomainSetting>(C2Component::DOMAIN_VIDEO));
-
-    pr.AddValue(C2_PARAMKEY_COMPONENT_KIND,
-        std::make_unique<C2ComponentKindSetting>(C2Component::KIND_DECODER));
-
-    pr.AddValue(C2_PARAMKEY_COMPONENT_NAME,
-        AllocUniqueString<C2ComponentNameSetting>(name.c_str()));
-
-    pr.AddValue(C2_PARAMKEY_OUTPUT_MEDIA_TYPE,
-        AllocUniqueString<C2PortMediaTypeSetting::output>("video/raw"));
-
     const unsigned int SINGLE_STREAM_ID = 0u;
-    pr.AddValue(C2_PARAMKEY_INPUT_STREAM_BUFFER_TYPE,
-        std::make_unique<C2StreamBufferTypeSetting::input>(SINGLE_STREAM_ID, C2BufferData::LINEAR));
-    pr.AddValue(C2_PARAMKEY_OUTPUT_STREAM_BUFFER_TYPE,
-        std::make_unique<C2StreamBufferTypeSetting::output>(SINGLE_STREAM_ID, C2BufferData::GRAPHIC));
-
-    pr.AddValue(C2_PARAMKEY_INPUT_MAX_BUFFER_SIZE,
-        std::make_unique<C2StreamMaxBufferSizeInfo::input>(SINGLE_STREAM_ID, kMinInputBufferSize));
-
-    pr.AddStreamInfo<C2StreamPictureSizeInfo::output>(
-        C2_PARAMKEY_PICTURE_SIZE, SINGLE_STREAM_ID,
-        [this] (C2StreamPictureSizeInfo::output* dst)->bool {
-            MFX_DEBUG_TRACE("GetPictureSize");
-            // Called from Query, m_mfxVideoParams is already protected there with lock on m_initDecoderMutex
-            dst->width = m_mfxVideoParams.mfx.FrameInfo.CropW;
-            dst->height = m_mfxVideoParams.mfx.FrameInfo.CropH;
-            MFX_DEBUG_TRACE_STREAM(NAMED(dst->width) << NAMED(dst->height));
-            return true;
-        },
-        [this] (const C2StreamPictureSizeInfo::output& src)->bool {
-            MFX_DEBUG_TRACE("SetPictureSize");
-            MFX_DEBUG_TRACE_STREAM(NAMED(src.width) << NAMED(src.height));
-            // Called from Config, m_mfxVideoParams is already protected there with lock on m_initDecoderMutex
-            m_mfxVideoParams.mfx.FrameInfo.Width = src.width;
-            m_mfxVideoParams.mfx.FrameInfo.Height = src.height;
-            m_mfxVideoParams.mfx.FrameInfo.CropW = src.width;
-            m_mfxVideoParams.mfx.FrameInfo.CropH = src.height;
-            return true;
-        }
-    );
-
-    pr.AddStreamInfo<C2StreamCropRectInfo::output>(
-        C2_PARAMKEY_CROP_RECT, SINGLE_STREAM_ID,
-        [this] (C2StreamCropRectInfo::output* dst)->bool {
-            MFX_DEBUG_TRACE("GetCropRect");
-            // Called from Query, m_mfxVideoParams is already protected there with lock on m_initDecoderMutex
-            dst->width = m_mfxVideoParams.mfx.FrameInfo.CropW;
-            dst->height = m_mfxVideoParams.mfx.FrameInfo.CropH;
-            dst->left = m_mfxVideoParams.mfx.FrameInfo.CropX;
-            dst->top = m_mfxVideoParams.mfx.FrameInfo.CropY;
-            MFX_DEBUG_TRACE_STREAM(NAMED(dst->left) << NAMED(dst->top) <<
-                NAMED(dst->width) << NAMED(dst->height));
-            return true;
-        },
-        [this] (const C2StreamCropRectInfo::output& src)->bool {
-            MFX_DEBUG_TRACE("SetCropRect");
-            // Called from Config, m_mfxVideoParams is already protected there with lock on m_initDecoderMutex
-            MFX_DEBUG_TRACE_STREAM(NAMED(src.left) << NAMED(src.top) <<
-                NAMED(src.width) << NAMED(src.height));
-            m_mfxVideoParams.mfx.FrameInfo.CropW = src.width;
-            m_mfxVideoParams.mfx.FrameInfo.CropH = src.height;
-            m_mfxVideoParams.mfx.FrameInfo.CropX = src.left;
-            m_mfxVideoParams.mfx.FrameInfo.CropY = src.top;
-            return true;
-        }
-    );
-
-    std::vector<C2Config::profile_t> supported_profiles = {};
-    std::vector<C2Config::level_t> supported_levels = {};
+    uint32_t max_w = 0u;
+    uint32_t max_h = 0u;
+
+    addParameter(
+        DefineParam(m_kind, C2_PARAMKEY_COMPONENT_KIND)
+        .withConstValue(new C2ComponentKindSetting(C2Component::KIND_DECODER))
+        .build());
+
+    addParameter(
+        DefineParam(m_domain, C2_PARAMKEY_COMPONENT_DOMAIN)
+        .withConstValue(new C2ComponentDomainSetting(C2Component::DOMAIN_VIDEO))
+        .build());
+
+    addParameter(
+        DefineParam(m_name, C2_PARAMKEY_COMPONENT_NAME)
+        .withConstValue(AllocSharedString<C2ComponentNameSetting>(name.c_str()))
+        .build());
+
+    addParameter(
+        DefineParam(m_surfaceAllocator, C2_PARAMKEY_OUTPUT_SURFACE_ALLOCATOR)
+        .withConstValue(new C2PortSurfaceAllocatorTuning::output(C2PlatformAllocatorStore::BUFFERQUEUE))
+        .withSetter(OutputSurfaceAllocatorSetter)
+        .build());
+
+    C2Allocator::id_t outputAllocators[1] = { C2PlatformAllocatorStore::GRALLOC };
+    addParameter(
+        DefineParam(m_outputAllocators, C2_PARAMKEY_OUTPUT_ALLOCATORS)
+        .withDefault(C2PortAllocatorsTuning::output::AllocShared(outputAllocators))
+        .withFields({ C2F(m_outputAllocators, m.values[0]).any(),
+                      C2F(m_outputAllocators, m.values).inRange(0, 1) })
+        .withSetter(Setter<C2PortAllocatorsTuning::output>::NonStrictValuesWithNoDeps)
+        .build());
+
+    addParameter(
+        DefineParam(m_inputFormat, C2_PARAMKEY_INPUT_STREAM_BUFFER_TYPE)
+        .withConstValue(new C2StreamBufferTypeSetting::input(
+                    SINGLE_STREAM_ID, C2BufferData::LINEAR))
+        .build());
+
+    addParameter(
+        DefineParam(m_outputFormat, C2_PARAMKEY_OUTPUT_STREAM_BUFFER_TYPE)
+        .withConstValue(new C2StreamBufferTypeSetting::output(
+                    SINGLE_STREAM_ID, C2BufferData::GRAPHIC))
+        .build());
+
+    addParameter(
+        DefineParam(m_outputMediaType, C2_PARAMKEY_OUTPUT_MEDIA_TYPE)
+        .withConstValue(AllocSharedString<C2PortMediaTypeSetting::output>("video/raw"))
+        .build());
 
     switch(m_decoderType) {
         case DECODER_H264: {
-            supported_profiles = {
-                PROFILE_AVC_CONSTRAINED_BASELINE,
-                PROFILE_AVC_BASELINE,
-                PROFILE_AVC_MAIN,
-                PROFILE_AVC_CONSTRAINED_HIGH,
-                PROFILE_AVC_PROGRESSIVE_HIGH,
-                PROFILE_AVC_HIGH,
-            };
-            supported_levels = {
-                LEVEL_AVC_1, LEVEL_AVC_1B, LEVEL_AVC_1_1,
-                LEVEL_AVC_1_2, LEVEL_AVC_1_3,
-                LEVEL_AVC_2, LEVEL_AVC_2_1, LEVEL_AVC_2_2,
-                LEVEL_AVC_3, LEVEL_AVC_3_1, LEVEL_AVC_3_2,
-                LEVEL_AVC_4, LEVEL_AVC_4_1, LEVEL_AVC_4_2,
-                LEVEL_AVC_5, LEVEL_AVC_5_1, LEVEL_AVC_5_2,
-            };
-
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_AVC_CONSTRAINED_BASELINE, LEVEL_AVC_5_2));
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_4K, HEIGHT_4K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/avc"));
-
             m_uOutputDelay = /*max_dpb_size*/16 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/avc"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_4K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_4K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_4K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_4K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+            
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
+                    SINGLE_STREAM_ID, PROFILE_AVC_CONSTRAINED_BASELINE, LEVEL_AVC_5_2))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_AVC_BASELINE,
+                            PROFILE_AVC_CONSTRAINED_BASELINE,
+                            PROFILE_AVC_MAIN,
+                            PROFILE_AVC_CONSTRAINED_HIGH,
+                            PROFILE_AVC_PROGRESSIVE_HIGH,
+                            PROFILE_AVC_HIGH,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_AVC_1, LEVEL_AVC_1B, LEVEL_AVC_1_1,
+                            LEVEL_AVC_1_2, LEVEL_AVC_1_3,
+                            LEVEL_AVC_2, LEVEL_AVC_2_1, LEVEL_AVC_2_2,
+                            LEVEL_AVC_3, LEVEL_AVC_3_1, LEVEL_AVC_3_2,
+                            LEVEL_AVC_4, LEVEL_AVC_4_1, LEVEL_AVC_4_2,
+                            LEVEL_AVC_5, LEVEL_AVC_5_1, LEVEL_AVC_5_2,
+                        }),})
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
         case DECODER_H265: {
-            supported_profiles = {
-                PROFILE_HEVC_MAIN,
-                PROFILE_HEVC_MAIN_STILL,
-                PROFILE_HEVC_MAIN_10,
-            };
-
-            supported_levels = {
-                LEVEL_HEVC_MAIN_1,
-                LEVEL_HEVC_MAIN_2, LEVEL_HEVC_MAIN_2_1,
-                LEVEL_HEVC_MAIN_3, LEVEL_HEVC_MAIN_3_1,
-                LEVEL_HEVC_MAIN_4, LEVEL_HEVC_MAIN_4_1,
-                LEVEL_HEVC_MAIN_5, LEVEL_HEVC_MAIN_5_1,
-                LEVEL_HEVC_MAIN_5_2, LEVEL_HEVC_HIGH_4,
-                LEVEL_HEVC_HIGH_4_1, LEVEL_HEVC_HIGH_5,
-                LEVEL_HEVC_HIGH_5_1, LEVEL_HEVC_HIGH_5_2,
-                LEVEL_HEVC_HIGH_6, LEVEL_HEVC_HIGH_6_1, LEVEL_HEVC_HIGH_6_2,
-            };
-
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_HEVC_MAIN, LEVEL_HEVC_MAIN_5_1));
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_8K, HEIGHT_8K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/hevc"));
-
             m_uOutputDelay = /*max_dpb_size*/16 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/hevc"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_8K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_8K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
+                    SINGLE_STREAM_ID, PROFILE_HEVC_MAIN, LEVEL_HEVC_MAIN_5_1))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_HEVC_MAIN,
+                            PROFILE_HEVC_MAIN_STILL,
+                            PROFILE_HEVC_MAIN_10,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_HEVC_MAIN_1,
+                            LEVEL_HEVC_MAIN_2, LEVEL_HEVC_MAIN_2_1,
+                            LEVEL_HEVC_MAIN_3, LEVEL_HEVC_MAIN_3_1,
+                            LEVEL_HEVC_MAIN_4, LEVEL_HEVC_MAIN_4_1,
+                            LEVEL_HEVC_MAIN_5, LEVEL_HEVC_MAIN_5_1,
+                            LEVEL_HEVC_MAIN_5_2, LEVEL_HEVC_HIGH_4,
+                            LEVEL_HEVC_HIGH_4_1, LEVEL_HEVC_HIGH_5,
+                            LEVEL_HEVC_HIGH_5_1, LEVEL_HEVC_HIGH_5_2,
+                            LEVEL_HEVC_MAIN_6, LEVEL_HEVC_MAIN_6_1,
+                            LEVEL_HEVC_MAIN_6_2,
+                        }),})
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
         case DECODER_VP9: {
-            supported_profiles = {
-                PROFILE_VP9_0,
-                PROFILE_VP9_2,
-            };
-
-            supported_levels = {
-                LEVEL_VP9_1, LEVEL_VP9_1_1,
-                LEVEL_VP9_2, LEVEL_VP9_2_1,
-                LEVEL_VP9_3, LEVEL_VP9_3_1,
-                LEVEL_VP9_4, LEVEL_VP9_4_1,
-                LEVEL_VP9_5,
-            };
-
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_VP9_0, LEVEL_VP9_5));
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_8K, HEIGHT_8K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/x-vnd.on2.vp9"));
-
             m_uOutputDelay = /*max_dpb_size*/9 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/x-vnd.on2.vp9"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_8K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_8K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
+                    SINGLE_STREAM_ID, PROFILE_VP9_0, LEVEL_VP9_5))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_VP9_0,
+                            PROFILE_VP9_1,
+                            PROFILE_VP9_2,
+                            PROFILE_VP9_3,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_VP9_1, LEVEL_VP9_1_1,
+                            LEVEL_VP9_2, LEVEL_VP9_2_1,
+                            LEVEL_VP9_3, LEVEL_VP9_3_1,
+                            LEVEL_VP9_4, LEVEL_VP9_4_1,
+                            LEVEL_VP9_5,
+                        }),})
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
         case DECODER_VP8: {
-            supported_profiles = {
-#if MFX_ANDROID_VERSION <= MFX_R
-                (C2Config::profile_t)PROFILE_VP8_0,
-#else
-                PROFILE_VP8_0,
-#endif
-            };
-
-            supported_levels = {
-                (C2Config::level_t)LEVEL_VP8_Version0,
-            };
+            m_uOutputDelay = /*max_dpb_size*/8 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
 
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/x-vnd.on2.vp8"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_4K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_4K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_4K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_4K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
 #if MFX_ANDROID_VERSION <= MFX_R
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, (C2Config::profile_t)PROFILE_VP8_0, (C2Config::level_t)LEVEL_VP8_Version0));
+                    SINGLE_STREAM_ID, PROFILE_VP8_0, C2Config::LEVEL_UNUSED))
+                .withFields({
+                    C2F(m_profileLevel, profile).equalTo(
+                        PROFILE_VP8_0),
 #else
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_VP8_0, (C2Config::level_t)LEVEL_VP8_Version0));
+                    SINGLE_STREAM_ID, C2Config::profile_t::PROFILE_VP8_0, C2Config::LEVEL_UNUSED))
+                .withFields({
+                    C2F(m_profileLevel, profile).equalTo(
+                        C2Config::profile_t::PROFILE_VP8_0),
 #endif
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_4K, HEIGHT_4K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/x-vnd.on2.vp8"));
-
-            m_uOutputDelay = /*max_dpb_size*/8 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+                    C2F(m_profileLevel, level).equalTo(
+                        C2Config::LEVEL_UNUSED),
+                })
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
         case DECODER_MPEG2: {
-            supported_profiles = {
-                PROFILE_MP2V_SIMPLE,
-                PROFILE_MP2V_MAIN,
-            };
-
-            supported_levels = {
-               LEVEL_MP2V_LOW, LEVEL_MP2V_MAIN,
-               LEVEL_MP2V_HIGH_1440,
-            };
-
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_MP2V_MAIN, LEVEL_MP2V_MAIN));
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_2K, HEIGHT_2K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/mpeg2"));
-
             m_uOutputDelay = /*max_dpb_size*/4 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/mpeg2"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_2K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_2K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_2K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_2K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
+                    SINGLE_STREAM_ID, PROFILE_MP2V_MAIN, LEVEL_MP2V_MAIN))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_MP2V_SIMPLE,
+                            PROFILE_MP2V_MAIN,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_MP2V_LOW, LEVEL_MP2V_MAIN,
+                            LEVEL_MP2V_HIGH_1440,
+                        }),})
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
         case DECODER_AV1: {
-            supported_profiles = {
-                PROFILE_AV1_0,
-                PROFILE_AV1_1,
-            };
-
-            supported_levels = {
-                LEVEL_AV1_2, LEVEL_AV1_2_1,
-                LEVEL_AV1_2_1, LEVEL_AV1_2_3,
-                LEVEL_AV1_3, LEVEL_AV1_3_1,
-                LEVEL_AV1_3_2,
-            };
-
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_AV1_0, LEVEL_AV1_2_1));
-
-            pr.AddValue(C2_PARAMKEY_MAX_PICTURE_SIZE,
-                std::make_unique<C2StreamMaxPictureSizeTuning::output>(0u, WIDTH_8K, HEIGHT_8K));
-
-            pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-                    AllocUniqueString<C2PortMediaTypeSetting::input>("video/av01"));
-
             m_uOutputDelay = /*max_dpb_size*/18 + /*for async depth*/1 + /*for msdk unref in sync part*/1;
+
+            addParameter(
+                DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+                .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/av01"))
+                .build());
+
+            addParameter(
+                DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+                .withDefault(new C2StreamPictureSizeInfo::output(SINGLE_STREAM_ID, MIN_W, MIN_H))
+                .withFields({
+                    C2F(m_size, width).inRange(MIN_W, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(MIN_H, HEIGHT_8K, 2),})
+                .withSetter(SizeSetter)
+                .build());
+
+            addParameter(
+                DefineParam(m_maxSize, C2_PARAMKEY_MAX_PICTURE_SIZE)
+                .withDefault(new C2StreamMaxPictureSizeTuning::output(SINGLE_STREAM_ID, WIDTH_8K, HEIGHT_8K))
+                .withFields({
+                    C2F(m_size, width).inRange(2, WIDTH_8K, 2),
+                    C2F(m_size, height).inRange(2, HEIGHT_8K, 2),
+                })
+                .withSetter(MaxPictureSizeSetter, m_size)
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::input(
+                    SINGLE_STREAM_ID, PROFILE_AV1_0, LEVEL_AV1_2))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_AV1_0,
+                            PROFILE_AV1_1,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_AV1_2, LEVEL_AV1_2_1,
+                            LEVEL_AV1_2_1, LEVEL_AV1_2_3,
+                            LEVEL_AV1_3, LEVEL_AV1_3_1,
+                            LEVEL_AV1_3_2,
+                        }),})
+                .withSetter(ProfileLevelSetter, m_size)
+                .build());
             break;
         }
-
         default:
-            MFX_DEBUG_TRACE_STREAM("C2PortDelayTuning::output value is not customized which can lead to hangs:" << m_uOutputDelay);
-            MFX_DEBUG_TRACE_STREAM("C2PortDelayTuning::input value is not customized which can lead to hangs:" << m_uInputDelay);
-            break;
+        break;
     }
 
+    addParameter(
+        DefineParam(m_maxInputSize, C2_PARAMKEY_INPUT_MAX_BUFFER_SIZE)
+        .withDefault(new C2StreamMaxBufferSizeInfo::input(SINGLE_STREAM_ID, kMinInputBufferSize))
+        .withFields({
+            C2F(m_maxInputSize, value).any(),
+        })
+        .calculatedAs(MaxInputSizeSetter, m_maxSize)
+        .build());
+
+    C2BlockPool::local_id_t outputPoolIds[1] = { C2BlockPool::PLATFORM_START };
+    addParameter(
+        DefineParam(m_outputPoolIds, C2_PARAMKEY_OUTPUT_BLOCK_POOLS)
+        .withDefault(C2PortBlockPoolsTuning::output::AllocShared(outputPoolIds))
+        .withFields({ C2F(m_outputPoolIds, m.values[0]).any(),
+                        C2F(m_outputPoolIds, m.values).inRange(0, 1) })
+        .withSetter(Setter<C2PortBlockPoolsTuning::output>::NonStrictValuesWithNoDeps)
+        .build());
+
     // C2PortDelayTuning::output parameter is needed to say framework about the max delay expressed in
     // decoded frames. If parameter is set too low, framework will stop sanding new portions
     // of bitstream and will wait for decoded frames.
     // The parameter value is differet for codecs and must be equal the DPD value is gotten
     // form QueryIOSurf function call result.
-    pr.AddValue(C2_PARAMKEY_OUTPUT_DELAY, std::make_unique<C2PortDelayTuning::output>(m_uOutputDelay));
-
-    // The numInputSlots = inputDelayValue + pipelineDelayValue + kSmoothnessFactor;
-    // pipelineDelayValue is 0, and kSmoothnessFactor is 4, for 4k video the first frame need 6 input
-    pr.AddValue(C2_PARAMKEY_INPUT_DELAY, std::make_unique<C2PortDelayTuning::input>(m_uInputDelay));
-
-    // List all the supported profiles and levels
-    pr.RegisterSupportedValues<C2StreamProfileLevelInfo>(&C2StreamProfileLevelInfo::C2ProfileLevelStruct::profile, supported_profiles);
-    pr.RegisterSupportedValues<C2StreamProfileLevelInfo>(&C2StreamProfileLevelInfo::C2ProfileLevelStruct::level, supported_levels);
-
-    // Default color aspects
-    pr.AddValue(C2_PARAMKEY_DEFAULT_COLOR_ASPECTS, std::make_unique<C2StreamColorAspectsTuning::output>(0u, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
-                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED));
-    pr.RegisterSupportedRange<C2StreamColorAspectsTuning>(&C2StreamColorAspectsTuning::C2ColorAspectsStruct::range, RANGE_UNSPECIFIED, RANGE_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsTuning>(&C2StreamColorAspectsTuning::C2ColorAspectsStruct::primaries, PRIMARIES_UNSPECIFIED, PRIMARIES_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsTuning>(&C2StreamColorAspectsTuning::C2ColorAspectsStruct::transfer, TRANSFER_UNSPECIFIED, TRANSFER_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsTuning>(&C2StreamColorAspectsTuning::C2ColorAspectsStruct::matrix, MATRIX_UNSPECIFIED, MATRIX_OTHER);
-
-    // VUI color aspects
-    pr.AddValue(C2_PARAMKEY_VUI_COLOR_ASPECTS, std::make_unique<C2StreamColorAspectsInfo::input>(0u, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
-                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED));
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::range, RANGE_UNSPECIFIED, RANGE_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::primaries, PRIMARIES_UNSPECIFIED, PRIMARIES_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::transfer, TRANSFER_UNSPECIFIED, TRANSFER_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::matrix, MATRIX_UNSPECIFIED, MATRIX_OTHER);
-
-    // Color aspects
-    pr.AddValue(C2_PARAMKEY_COLOR_ASPECTS, std::make_unique<C2StreamColorAspectsInfo::output>(0u, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
-                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED));
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::range, RANGE_UNSPECIFIED, RANGE_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::primaries, PRIMARIES_UNSPECIFIED, PRIMARIES_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::transfer, TRANSFER_UNSPECIFIED, TRANSFER_OTHER);
-    pr.RegisterSupportedRange<C2StreamColorAspectsInfo>(&C2StreamColorAspectsInfo::C2ColorAspectsStruct::matrix, MATRIX_UNSPECIFIED, MATRIX_OTHER);
+    addParameter(
+        DefineParam(m_actualOutputDelay, C2_PARAMKEY_OUTPUT_DELAY)
+        .withDefault(new C2PortActualDelayTuning::output(m_uOutputDelay))
+        .withFields({C2F(m_actualOutputDelay, value).inRange(0, m_uOutputDelay)})
+        .withSetter(Setter<decltype(*m_actualOutputDelay)>::StrictValueWithNoDeps)
+        .build());
+
+    addParameter(
+        DefineParam(m_inputDelay, C2_PARAMKEY_INPUT_DELAY)
+        .withConstValue(new C2PortDelayTuning::input(m_uInputDelay))
+        .build());
+
+    addParameter(
+        DefineParam(m_defaultColorAspects, C2_PARAMKEY_DEFAULT_COLOR_ASPECTS)
+        .withDefault(new C2StreamColorAspectsTuning::output(
+                SINGLE_STREAM_ID, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
+                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED))
+        .withFields({
+            C2F(m_defaultColorAspects, range).inRange(
+                        C2Color::RANGE_UNSPECIFIED,     C2Color::RANGE_OTHER),
+            C2F(m_defaultColorAspects, primaries).inRange(
+                        C2Color::PRIMARIES_UNSPECIFIED, C2Color::PRIMARIES_OTHER),
+            C2F(m_defaultColorAspects, transfer).inRange(
+                        C2Color::TRANSFER_UNSPECIFIED,  C2Color::TRANSFER_OTHER),
+            C2F(m_defaultColorAspects, matrix).inRange(
+                        C2Color::MATRIX_UNSPECIFIED,    C2Color::MATRIX_OTHER)
+        })
+        .withSetter(DefaultColorAspectsSetter)
+        .build());
+
+    addParameter(
+        DefineParam(m_codedColorAspects, C2_PARAMKEY_VUI_COLOR_ASPECTS)
+        .withDefault(new C2StreamColorAspectsInfo::input(
+                SINGLE_STREAM_ID, C2Color::RANGE_LIMITED, C2Color::PRIMARIES_UNSPECIFIED,
+                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED))
+        .withFields({
+            C2F(m_codedColorAspects, range).inRange(
+                        C2Color::RANGE_UNSPECIFIED,     C2Color::RANGE_OTHER),
+            C2F(m_codedColorAspects, primaries).inRange(
+                        C2Color::PRIMARIES_UNSPECIFIED, C2Color::PRIMARIES_OTHER),
+            C2F(m_codedColorAspects, transfer).inRange(
+                        C2Color::TRANSFER_UNSPECIFIED,  C2Color::TRANSFER_OTHER),
+            C2F(m_codedColorAspects, matrix).inRange(
+                        C2Color::MATRIX_UNSPECIFIED,    C2Color::MATRIX_OTHER)
+        })
+        .withSetter(CodedColorAspectsSetter)
+        .build());
+
+    addParameter(
+        DefineParam(m_colorAspects, C2_PARAMKEY_COLOR_ASPECTS)
+        .withDefault(new C2StreamColorAspectsInfo::output(
+                SINGLE_STREAM_ID, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
+                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED))
+        .withFields({
+            C2F(m_colorAspects, range).inRange(
+                        C2Color::RANGE_UNSPECIFIED,     C2Color::RANGE_OTHER),
+            C2F(m_colorAspects, primaries).inRange(
+                        C2Color::PRIMARIES_UNSPECIFIED, C2Color::PRIMARIES_OTHER),
+            C2F(m_colorAspects, transfer).inRange(
+                        C2Color::TRANSFER_UNSPECIFIED,  C2Color::TRANSFER_OTHER),
+            C2F(m_colorAspects, matrix).inRange(
+                        C2Color::MATRIX_UNSPECIFIED,    C2Color::MATRIX_OTHER)
+        })
+        .withSetter(ColorAspectsSetter, m_defaultColorAspects, m_codedColorAspects)
+        .build());
 
     // Pixel format info. Set to NV12 by default
     m_pixelFormat = std::make_unique<C2StreamPixelFormatInfo::output>(SINGLE_STREAM_ID, HAL_PIXEL_FORMAT_NV12_Y_TILED_INTEL);
@@ -382,7 +635,7 @@ MfxC2DecoderComponent::MfxC2DecoderComponent(const C2String name, const CreateCo
     // By default prepare buffer to be displayed on any of the common surfaces
     m_consumerUsage = kDefaultConsumerUsage;
 
-    m_paramStorage.DumpParams();
+    //m_paramStorage.DumpParams();
 }
 
 MfxC2DecoderComponent::~MfxC2DecoderComponent()
@@ -763,7 +1016,7 @@ mfxStatus MfxC2DecoderComponent::ResetSettings()
         break;
     }
 
-    m_colorAspects.SetCodecID(m_mfxVideoParams.mfx.CodecId);
+    m_colorAspectsWrapper.SetCodecID(m_mfxVideoParams.mfx.CodecId);
 
     mfx_set_defaults_mfxVideoParam_dec(&m_mfxVideoParams);
 
@@ -895,7 +1148,7 @@ mfxStatus MfxC2DecoderComponent::InitDecoder(std::shared_ptr<C2BlockPool> c2_all
 
     if (MFX_ERR_NONE == mfx_res) {
         MFX_DEBUG_TRACE_MSG("InitDecoder: UpdateBitstreamColorAspects");
-        m_colorAspects.UpdateBitstreamColorAspects(m_signalInfo);
+        m_colorAspectsWrapper.UpdateBitstreamColorAspects(m_signalInfo);
 
         MFX_DEBUG_TRACE_MSG("InitDecoder: GetAsyncDepth");
         m_mfxVideoParams.AsyncDepth = GetAsyncDepth();
@@ -1073,69 +1326,70 @@ mfxStatus MfxC2DecoderComponent::HandleFormatChange()
     return mfx_res;
 }
 
-c2_status_t MfxC2DecoderComponent::QueryParam(const mfxVideoParam* src, C2Param::Index index, C2Param** dst) const
+c2_status_t MfxC2DecoderComponent::UpdateC2Param(const mfxVideoParam* src, C2Param::Index index) const
 {
     MFX_DEBUG_TRACE_FUNC;
     c2_status_t res = C2_OK;
 
-    res = m_paramStorage.QueryParam(index, dst);
-    if (C2_NOT_FOUND == res) {
-        switch (index) {
-            case kParamIndexMemoryType: {
-                if (nullptr == *dst) {
-                    *dst = new C2MemoryTypeSetting();
-                }
+    if (C2PortSurfaceAllocatorTuning::output::PARAM_TYPE == index) {
+        m_surfaceAllocator->value = C2PlatformAllocatorStore::BUFFERQUEUE;
+        MFX_DEBUG_TRACE_PRINTF("Set output port surface alloctor to: %d", m_surfaceAllocator->value);
+    }
 
-                C2MemoryTypeSetting* setting = static_cast<C2MemoryTypeSetting*>(*dst);
-                if (!MfxIOPatternToC2MemoryType(false, src->IOPattern, &setting->value)) res = C2_CORRUPTED;
-                break;
+    switch (index.typeIndex()) {
+        case kParamIndexBlockPools: {
+            m_outputPoolIds->m.values[0] = m_outputPoolId;
+            break;
+        }
+        case kParamIndexPictureSize: {
+            if (C2StreamPictureSizeInfo::output::PARAM_TYPE == index) {
+                MFX_DEBUG_TRACE("GetPictureSize");
+                m_size->width = src->mfx.FrameInfo.CropW;
+                m_size->height = src->mfx.FrameInfo.CropH;
+                MFX_DEBUG_TRACE_STREAM(NAMED(m_size->width) << NAMED(m_size->height));
             }
-            case C2PortAllocatorsTuning::output::PARAM_TYPE: {
-                if (nullptr == *dst) {
-                    std::unique_ptr<C2PortAllocatorsTuning::output> outAlloc =
-                        C2PortAllocatorsTuning::output::AllocUnique(1);
-                    if (m_mfxVideoParams.IOPattern == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
+            break;
+        }
+        case kParamIndexAllocators: {
+            if (C2PortAllocatorsTuning::output::PARAM_TYPE == index) {
+                if (m_mfxVideoParams.IOPattern == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
 #ifdef MFX_BUFFER_QUEUE
-                        outAlloc->m.values[0] = MFX_BUFFERQUEUE;
+                    m_outputAllocators->m.values[0] = MFX_BUFFERQUEUE;
 #else
-                        outAlloc->m.values[0] = C2PlatformAllocatorStore::GRALLOC;
+                    m_outputAllocators->m.values[0] = C2PlatformAllocatorStore::GRALLOC;
 #endif
-                    else
-                        outAlloc->m.values[0] = C2PlatformAllocatorStore::GRALLOC;
-                    MFX_DEBUG_TRACE_PRINTF("Set output port alloctor to: %d", outAlloc->m.values[0]);
-                    *dst = outAlloc.release();
-                    res = C2_OK;
-                } else {
-                    // It is not possible to return flexible params through stack
-                    res = C2_NO_MEMORY;
-                }
-                break;
-            }
-            case C2PortSurfaceAllocatorTuning::output::PARAM_TYPE: {
-                if (nullptr == *dst) {
-                    std::unique_ptr<C2PortSurfaceAllocatorTuning::output> outAlloc =
-                        std::make_unique<C2PortSurfaceAllocatorTuning::output>();
-
-                    outAlloc->value = C2PlatformAllocatorStore::BUFFERQUEUE;
-                    MFX_DEBUG_TRACE_PRINTF("Set output port surface alloctor to: %d", outAlloc->value);
-                    *dst = outAlloc.release();
-                    res = C2_OK;
-                } else {
-                    // It is not possible to return flexible params through stack
-                    res = C2_NO_MEMORY;
-                }
-                break;
+                else
+                    m_outputAllocators->m.values[0] = C2PlatformAllocatorStore::GRALLOC;
+                MFX_DEBUG_TRACE_PRINTF("Set output port alloctor to: %d", m_outputAllocators->m.values[0]);
             }
-            default:
-                res = C2_BAD_INDEX;
-                break;
+            break;
+        }
+        case kParamIndexColorAspects: {
+            auto color = getColorAspects_l();
+            m_colorAspects->range = color->range;
+            m_colorAspects->primaries = color->primaries;
+            m_colorAspects->transfer = color->transfer;
+            m_colorAspects->matrix = color->matrix;
+            break;
+        }
+        case kParamIndexDefaultColorAspects: {
+            auto color = getColorAspects_l();
+            m_defaultColorAspects->range = color->range;
+            m_defaultColorAspects->primaries = color->primaries;
+            m_defaultColorAspects->transfer = color->transfer;
+            m_defaultColorAspects->matrix = color->matrix;
+            break;
         }
+        default:
+            MFX_DEBUG_TRACE_STREAM("attempt to query "
+                            << index.typeIndex() << " type, but not found.");
+            break;
     }
 
     return res;
 }
 
-c2_status_t MfxC2DecoderComponent::Query(
+c2_status_t MfxC2DecoderComponent::UpdateMfxParamToC2(
     std::unique_lock<std::mutex> state_lock,
     const std::vector<C2Param*> &stackParams,
     const std::vector<C2Param::Index> &heapParamIndices,
@@ -1150,34 +1404,25 @@ c2_status_t MfxC2DecoderComponent::Query(
     std::lock_guard<std::mutex> lock(m_initDecoderMutex);
 
     c2_status_t res = C2_OK;
+    c2_status_t param_res = C2_OK;
 
     // determine source, update it if needed
     const mfxVideoParam* params_view = &m_mfxVideoParams;
     if (nullptr != params_view) {
         // 1st cycle on stack params
         for (C2Param* param : stackParams) {
-            c2_status_t param_res = C2_OK;
-            if (m_paramStorage.FindParam(param->index())) {
-                param_res = QueryParam(params_view, param->index(), &param);
-            } else {
-                param_res =  C2_BAD_INDEX;
-            }
+            param_res = UpdateC2Param(params_view, param->index());
             if (param_res != C2_OK) {
                 param->invalidate();
                 res = param_res;
             }
         }
+        param_res = C2_OK;
         // 2nd cycle on heap params
         for (C2Param::Index param_index : heapParamIndices) {
-            // allocate in QueryParam
+            // allocate in UpdateC2Param
             C2Param* param = nullptr;
-            // check on presence
-            c2_status_t param_res = C2_OK;
-            if (m_paramStorage.FindParam(param_index.type())) {
-                param_res = QueryParam(params_view, param_index, &param);
-            } else {
-                param_res = C2_BAD_INDEX;
-            }
+            param_res = UpdateC2Param(params_view, param_index);
             if (param_res == C2_OK) {
                 if(nullptr != heapParams) {
                     heapParams->push_back(std::unique_ptr<C2Param>(param));
@@ -1202,129 +1447,92 @@ c2_status_t MfxC2DecoderComponent::Query(
     return res;
 }
 
-void MfxC2DecoderComponent::DoConfig(const std::vector<C2Param*> &params,
+void MfxC2DecoderComponent::DoUpdateMfxParam(const std::vector<C2Param*> &params,
     std::vector<std::unique_ptr<C2SettingResult>>* const failures,
-    bool /*queue_update*/)
+    bool )
 {
     MFX_DEBUG_TRACE_FUNC;
 
     for (const C2Param* param : params) {
-
-        // check whether plugin supports this parameter
-        std::unique_ptr<C2SettingResult> find_res = m_paramStorage.FindParam(param);
-        if(nullptr != find_res) {
-            MFX_DEBUG_TRACE_PRINTF("cannot found param: %X02", param->index());
-            failures->push_back(std::move(find_res));
-            continue;
-        }
-        // check whether plugin is in a correct state to apply this parameter
-        bool modifiable = ((param->kind() & C2Param::TUNING) != 0) ||
-            m_state == State::STOPPED; /* all kinds, even INFO might be set by stagefright */
-
-        if (!modifiable) {
-            MFX_DEBUG_TRACE_PRINTF("cannot modify param: %X02", param->index());
-            failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::READ_ONLY));
-            continue;
-        }
-
-        // check ranges
-        if(!m_paramStorage.ValidateParam(param, failures)) {
-            continue;
-        }
-
         // applying parameter
         switch (C2Param::Type(param->type()).typeIndex()) {
-            case kParamIndexMemoryType: {
-                const C2MemoryTypeSetting* setting = static_cast<const C2MemoryTypeSetting*>(param);
-                bool set_res = C2MemoryTypeToMfxIOPattern(false, setting->value, &m_mfxVideoParams.IOPattern);
-                if (!set_res) {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
+            case kParamIndexPictureSize: {
+                if (C2StreamPictureSizeInfo::output::PARAM_TYPE == param->index()) {
+                    MFX_DEBUG_TRACE("SetPictureSize");
+                    MFX_DEBUG_TRACE_STREAM(NAMED(m_size->width) << NAMED(m_size->height));
+                    m_mfxVideoParams.mfx.FrameInfo.Width = m_size->width;
+                    m_mfxVideoParams.mfx.FrameInfo.Height = m_size->height;
+                    m_mfxVideoParams.mfx.FrameInfo.CropW = m_size->width;
+                    m_mfxVideoParams.mfx.FrameInfo.CropH = m_size->height;
                 }
                 break;
             }
             case kParamIndexBlockPools: {
-                const C2PortBlockPoolsTuning::output* outputPools =
-                                static_cast<const C2PortBlockPoolsTuning::output*>(param);
-
-                if (outputPools && outputPools->flexCount() >= 1) {
-                    m_outputPoolId = outputPools->m.values[0];
-                    MFX_DEBUG_TRACE_PRINTF("config kParamIndexBlockPools to %lu", m_outputPoolId);
+                if (m_outputPoolIds && m_outputPoolIds->flexCount() >= 1) {
+                    m_outputPoolId = m_outputPoolIds->m.values[0];
+                    MFX_DEBUG_TRACE_STREAM("config kParamIndexBlockPools to " << m_outputPoolId);
                 } else {
                     failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
                 }
                 break;
             }
             case kParamIndexColorAspects: {
-                const C2StreamColorAspectsInfo* settings = static_cast<const C2StreamColorAspectsInfo*>(param);
                 android::ColorAspects ca;
-                MFX_DEBUG_TRACE_U32(settings->range);
-                MFX_DEBUG_TRACE_U32(settings->primaries);
-                MFX_DEBUG_TRACE_U32(settings->transfer);
-                MFX_DEBUG_TRACE_U32(settings->matrix);
+                MFX_DEBUG_TRACE_U32(m_colorAspects->range);
+                MFX_DEBUG_TRACE_U32(m_colorAspects->primaries);
+                MFX_DEBUG_TRACE_U32(m_colorAspects->transfer);
+                MFX_DEBUG_TRACE_U32(m_colorAspects->matrix);
 
-                ca.mRange = (android::ColorAspects::Range)settings->range;
-                ca.mTransfer = (android::ColorAspects::Transfer)settings->transfer;
-                ca.mMatrixCoeffs = (android::ColorAspects::MatrixCoeffs)settings->matrix;
-                ca.mPrimaries = (android::ColorAspects::Primaries)settings->primaries;
+                ca.mRange = (android::ColorAspects::Range)m_colorAspects->range;
+                ca.mTransfer = (android::ColorAspects::Transfer)m_colorAspects->transfer;
+                ca.mMatrixCoeffs = (android::ColorAspects::MatrixCoeffs)m_colorAspects->matrix;
+                ca.mPrimaries = (android::ColorAspects::Primaries)m_colorAspects->primaries;
 
                 mfxExtVideoSignalInfo signal_info;
                 MFX_ZERO_MEMORY(signal_info);
-                signal_info.VideoFullRange = settings->range;
-                signal_info.ColourPrimaries = settings->primaries;
-                signal_info.TransferCharacteristics = settings->transfer;
-                signal_info.MatrixCoefficients = settings->matrix;
+                signal_info.VideoFullRange = m_colorAspects->range;
+                signal_info.ColourPrimaries = m_colorAspects->primaries;
+                signal_info.TransferCharacteristics = m_colorAspects->transfer;
+                signal_info.MatrixCoefficients = m_colorAspects->matrix;
 
-                m_colorAspects.UpdateBitstreamColorAspects(signal_info);
-                m_colorAspects.SetFrameworkColorAspects(ca);
+                m_colorAspectsWrapper.UpdateBitstreamColorAspects(signal_info);
+                m_colorAspectsWrapper.SetFrameworkColorAspects(ca);
                 break;
             }
             case kParamIndexDefaultColorAspects: {
-                const C2StreamColorAspectsTuning* settings = static_cast<const C2StreamColorAspectsTuning*>(param);
                 android::ColorAspects ca;
-                MFX_DEBUG_TRACE_U32(settings->range);
-                MFX_DEBUG_TRACE_U32(settings->primaries);
-                MFX_DEBUG_TRACE_U32(settings->transfer);
-                MFX_DEBUG_TRACE_U32(settings->matrix);
+                MFX_DEBUG_TRACE_U32(m_defaultColorAspects->range);
+                MFX_DEBUG_TRACE_U32(m_defaultColorAspects->primaries);
+                MFX_DEBUG_TRACE_U32(m_defaultColorAspects->transfer);
+                MFX_DEBUG_TRACE_U32(m_defaultColorAspects->matrix);
 
-                ca.mRange = (android::ColorAspects::Range)settings->range;
-                ca.mTransfer = (android::ColorAspects::Transfer)settings->transfer;
-                ca.mMatrixCoeffs = (android::ColorAspects::MatrixCoeffs)settings->matrix;
-                ca.mPrimaries = (android::ColorAspects::Primaries)settings->primaries;
+                ca.mRange = (android::ColorAspects::Range)m_defaultColorAspects->range;
+                ca.mTransfer = (android::ColorAspects::Transfer)m_defaultColorAspects->transfer;
+                ca.mMatrixCoeffs = (android::ColorAspects::MatrixCoeffs)m_defaultColorAspects->matrix;
+                ca.mPrimaries = (android::ColorAspects::Primaries)m_defaultColorAspects->primaries;
 
                 mfxExtVideoSignalInfo signal_info;
                 MFX_ZERO_MEMORY(signal_info);
-                signal_info.VideoFullRange = settings->range;
-                signal_info.ColourPrimaries = settings->primaries;
-                signal_info.TransferCharacteristics = settings->transfer;
-                signal_info.MatrixCoefficients = settings->matrix;
-
-                m_colorAspects.UpdateBitstreamColorAspects(signal_info);
-                m_colorAspects.SetFrameworkColorAspects(ca);
-                break;
-            }
-            case kParamIndexUsage: {
-                const C2StreamUsageTuning::output* outputUsage =
-                                static_cast<const C2StreamUsageTuning::output*>(param);
+                signal_info.VideoFullRange = m_defaultColorAspects->range;
+                signal_info.ColourPrimaries = m_defaultColorAspects->primaries;
+                signal_info.TransferCharacteristics = m_defaultColorAspects->transfer;
+                signal_info.MatrixCoefficients = m_defaultColorAspects->matrix;
 
-                if (outputUsage) {
-                    m_consumerUsage = outputUsage->value;
-                    MFX_DEBUG_TRACE_I64(m_consumerUsage);
-                } else {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
-                }
+                m_colorAspectsWrapper.UpdateBitstreamColorAspects(signal_info);
+                m_colorAspectsWrapper.SetFrameworkColorAspects(ca);
                 break;
             }
 	    case kParamIndexMediaType:
 		break;
             default:
-                MFX_DEBUG_TRACE_PRINTF("applying default parameter: %X02", param->index());
-                m_paramStorage.ConfigParam(*param, m_state == State::STOPPED, failures);
+                MFX_DEBUG_TRACE_STREAM("attempt to configure " 
+                                    << C2Param::Type(param->type()).typeIndex() << " type, but not found");
                 break;
         }
     }
 }
 
-c2_status_t MfxC2DecoderComponent::Config(std::unique_lock<std::mutex> state_lock,
+c2_status_t MfxC2DecoderComponent::UpdateC2ParamToMfx(std::unique_lock<std::mutex> state_lock,
     const std::vector<C2Param*> &params,
     c2_blocking_t mayBlock,
     std::vector<std::unique_ptr<C2SettingResult>>* const failures) {
@@ -1345,7 +1553,7 @@ c2_status_t MfxC2DecoderComponent::Config(std::unique_lock<std::mutex> state_loc
 
         std::lock_guard<std::mutex> lock(m_initDecoderMutex);
 
-        DoConfig(params, failures, true);
+        DoUpdateMfxParam(params, failures, true);
 
         res = GetAggregateStatus(failures);
 
@@ -1557,7 +1765,7 @@ c2_status_t MfxC2DecoderComponent::AllocateC2Block(uint32_t width, uint32_t heig
                     usleep(1000);
                     // If always fetch a nocached block, check if width or height have changed
                     // compare to when it was initialized.
-                    MFX_DEBUG_TRACE_PRINTF("fetchGraphicBlock a nocached block, please retune output blocks. id = %d", id);
+                    MFX_DEBUG_TRACE_STREAM("fetchGraphicBlock a nocached block, please retune output blocks. id = " << id);
                 }
             }
         } else if (m_mfxVideoParams.IOPattern == MFX_IOPATTERN_OUT_SYSTEM_MEMORY) {
@@ -2164,8 +2372,8 @@ void MfxC2DecoderComponent::WaitWork(MfxC2FrameOut&& frame_out, mfxSyncPoint syn
             // set color aspects info
             out_buffer->setInfo(getColorAspects_l());
 
-            if (m_colorAspects.IsColorAspectsChanged()) {
-                m_colorAspects.SignalChangedColorAspectsIsSent();
+            if (m_colorAspectsWrapper.IsColorAspectsChanged()) {
+                m_colorAspectsWrapper.SignalChangedColorAspectsIsSent();
             }
 
             std::unique_ptr<C2Worklet>& worklet = work->worklets.front();
@@ -2402,13 +2610,13 @@ void MfxC2DecoderComponent::UpdateHdrStaticInfo()
     MFX_DEBUG_TRACE__hdrStaticInfo(m_hdrStaticInfo);
 }
 
-std::shared_ptr<C2StreamColorAspectsInfo::output> MfxC2DecoderComponent::getColorAspects_l(){
+std::shared_ptr<C2StreamColorAspectsInfo::output> MfxC2DecoderComponent::getColorAspects_l() const {
     MFX_DEBUG_TRACE_FUNC;
     android::ColorAspects sfAspects;
     std::shared_ptr<C2StreamColorAspectsInfo::output> codedAspects = std::make_shared<C2StreamColorAspectsInfo::output>(0u);
     if (!codedAspects) return nullptr;
 
-    m_colorAspects.GetOutputColorAspects(sfAspects);
+    m_colorAspectsWrapper.GetOutputColorAspects(sfAspects);
 
     if (!C2Mapper::map(sfAspects.mPrimaries, &codedAspects->primaries)) {
             codedAspects->primaries = C2Color::PRIMARIES_UNSPECIFIED;
diff --git a/c2_components/src/mfx_c2_encoder_component.cpp b/c2_components/src/mfx_c2_encoder_component.cpp
index 648d1c8..2f81109 100755
--- a/c2_components/src/mfx_c2_encoder_component.cpp
+++ b/c2_components/src/mfx_c2_encoder_component.cpp
@@ -25,7 +25,6 @@
 #include "mfx_c2_debug.h"
 #include "mfx_c2_components_registry.h"
 #include "mfx_c2_utils.h"
-#include "mfx_c2_params.h"
 #include "mfx_defaults.h"
 #include "C2PlatformSupport.h"
 #include "mfx_gralloc_allocator.h"
@@ -48,6 +47,116 @@ const mfxU32 MFX_MAX_H264_FRAMERATE = 172;
 const mfxU32 MFX_MAX_H265_FRAMERATE = 300;
 const mfxU32 MFX_MAX_SURFACE_NUM = 10;
 
+#define MAX_B_FRAMES 1
+
+C2R MfxC2EncoderComponent::SizeSetter(bool mayBlock, const C2P<C2StreamPictureSizeInfo::input> &oldMe,
+                        C2P<C2StreamPictureSizeInfo::input> &me) {
+    
+    MFX_DEBUG_TRACE_FUNC;
+    (void)mayBlock;
+    C2R res = C2R::Ok();
+    if (!me.F(me.v.width).supportsAtAll(me.v.width)) {
+        res = res.plus(C2SettingResultBuilder::BadValue(me.F(me.v.width)));
+        me.set().width = oldMe.v.width;
+    }
+    if (!me.F(me.v.height).supportsAtAll(me.v.height)) {
+        res = res.plus(C2SettingResultBuilder::BadValue(me.F(me.v.height)));
+        me.set().height = oldMe.v.height;
+    }
+
+    return res;
+}
+
+C2R MfxC2EncoderComponent::AVC_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me) {
+    (void)mayBlock;
+    if (!me.F(me.v.profile).supportsAtAll(me.v.profile))
+         me.set().profile = PROFILE_AVC_CONSTRAINED_BASELINE;
+    if (!me.F(me.v.level).supportsAtAll(me.v.level))
+        me.set().level = LEVEL_AVC_5_2;
+
+    return C2R::Ok();
+}
+
+C2R MfxC2EncoderComponent::HEVC_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me) {
+    (void)mayBlock;
+    if (!me.F(me.v.profile).supportsAtAll(me.v.profile))
+        me.set().profile = PROFILE_HEVC_MAIN;
+    if (!me.F(me.v.level).supportsAtAll(me.v.level))
+        me.set().level = LEVEL_HEVC_MAIN_5_1;
+    
+    return C2R::Ok();
+}
+C2R MfxC2EncoderComponent::VP9_ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::output> &me) {
+    (void)mayBlock;
+    if (!me.F(me.v.profile).supportsAtAll(me.v.profile))
+        me.set().profile = PROFILE_VP9_0;
+    if (!me.F(me.v.level).supportsAtAll(me.v.level))
+        me.set().level = LEVEL_VP9_5;
+    
+    return C2R::Ok();
+}
+
+C2R MfxC2EncoderComponent::BitrateSetter(bool mayBlock, C2P<C2StreamBitrateInfo::output> &me) {
+    (void)mayBlock;
+    C2R res = C2R::Ok();
+    if (me.v.value <= 4096) {
+        me.set().value = 4096;
+    }
+    return res;
+}
+
+C2R MfxC2EncoderComponent::GopSetter(bool mayBlock, C2P<C2StreamGopTuning::output> &me) {
+    (void)mayBlock;
+    for (size_t i = 0; i < me.v.flexCount(); ++i) {
+        const C2GopLayerStruct &layer = me.v.m.values[0];
+        if (layer.type_ == C2Config::picture_type_t(C2Config::P_FRAME | C2Config::B_FRAME)
+                && layer.count > MAX_B_FRAMES) {
+            me.set().m.values[i].count = MAX_B_FRAMES;
+        }
+    }
+    return C2R::Ok();
+}
+
+C2R MfxC2EncoderComponent::IntraRefreshSetter(bool mayBlock, C2P<C2StreamIntraRefreshTuning::output> &me) {
+    (void)mayBlock;
+    C2R res = C2R::Ok();
+    if (me.v.period < 1) {
+        me.set().mode = C2Config::INTRA_REFRESH_DISABLED;
+        me.set().period = 0;
+    } else {
+        // only support arbitrary mode (cyclic in our case)
+        me.set().mode = C2Config::INTRA_REFRESH_ARBITRARY;
+    }
+    return res;
+}
+
+C2R MfxC2EncoderComponent::ColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::input> &me) {
+    (void)mayBlock;
+    if (me.v.range > C2Color::RANGE_OTHER) {
+            me.set().range = C2Color::RANGE_OTHER;
+    }
+    if (me.v.primaries > C2Color::PRIMARIES_OTHER) {
+            me.set().primaries = C2Color::PRIMARIES_OTHER;
+    }
+    if (me.v.transfer > C2Color::TRANSFER_OTHER) {
+            me.set().transfer = C2Color::TRANSFER_OTHER;
+    }
+    if (me.v.matrix > C2Color::MATRIX_OTHER) {
+            me.set().matrix = C2Color::MATRIX_OTHER;
+    }
+    return C2R::Ok();
+}
+
+C2R MfxC2EncoderComponent::CodedColorAspectsSetter(bool mayBlock, C2P<C2StreamColorAspectsInfo::output> &me,
+                                    const C2P<C2StreamColorAspectsInfo::input> &coded) {
+    (void)mayBlock;
+    me.set().range = coded.v.range;
+    me.set().primaries = coded.v.primaries;
+    me.set().transfer = coded.v.transfer;
+    me.set().matrix = coded.v.matrix;
+    return C2R::Ok();
+}
+
 std::unique_ptr<mfxEncodeCtrl> EncoderControl::AcquireEncodeCtrl()
 {
     MFX_DEBUG_TRACE_FUNC;
@@ -72,7 +181,7 @@ void EncoderControl::Modify(ModifyFunction& function)
 }
 
 MfxC2EncoderComponent::MfxC2EncoderComponent(const C2String name, const CreateConfig& config,
-    std::shared_ptr<MfxC2ParamReflector> reflector, EncoderType encoder_type) :
+    std::shared_ptr<C2ReflectorHelper> reflector, EncoderType encoder_type) :
         MfxC2Component(name, config, std::move(reflector)),
         m_encoderType(encoder_type),
 #ifdef USE_ONEVPL
@@ -89,168 +198,255 @@ MfxC2EncoderComponent::MfxC2EncoderComponent(const C2String name, const CreateCo
     MFX_DEBUG_TRACE_FUNC;
     MFX_DEBUG_TRACE_U32(m_inputVppType);
 
-    std::vector<C2Config::profile_t> supported_profiles = {};
-    std::vector<C2Config::level_t> supported_levels = {};
-
-    MfxC2ParamStorage& pr = m_paramStorage;
-
-    pr.RegisterParam<C2RateControlSetting>("RateControl");
-    pr.RegisterParam<C2StreamFrameRateInfo::output>(C2_PARAMKEY_FRAME_RATE);
-    pr.RegisterParam<C2StreamBitrateInfo::output>(C2_PARAMKEY_BITRATE);
-    pr.RegisterParam<C2BitrateTuning::output>(MFX_C2_PARAMKEY_BITRATE_TUNING);
-
-    pr.RegisterParam<C2FrameQPSetting>("FrameQP");
-    const uint32_t MIN_QP = 1;
-    const uint32_t MAX_QP = 51;
-    pr.RegisterSupportedRange<C2FrameQPSetting>(&C2FrameQPSetting::qp_i, MIN_QP, MAX_QP);
-    pr.RegisterSupportedRange<C2FrameQPSetting>(&C2FrameQPSetting::qp_p, MIN_QP, MAX_QP);
-    pr.RegisterSupportedRange<C2FrameQPSetting>(&C2FrameQPSetting::qp_b, MIN_QP, MAX_QP);
-
-    pr.RegisterParam<C2IntraRefreshTuning>("IntraRefresh");
-    pr.RegisterSupportedRange<C2IntraRefreshTuning>(&C2IntraRefreshTuning::value, (int)false, (int)true);
-
-    pr.RegisterParam<C2ProfileSetting>("Profile");
-    pr.RegisterParam<C2LevelSetting>("Level");
-    pr.RegisterParam<C2ProfileLevelInfo::output>("SupportedProfilesLevels");
-
-    pr.RegisterParam<C2StreamInitDataInfo::output>(C2_PARAMKEY_INIT_DATA);
-    pr.RegisterParam<C2MemoryTypeSetting>("MemoryType");
-
-    pr.RegisterParam<C2StreamGopTuning::output>(C2_PARAMKEY_GOP);
-
     const unsigned int SINGLE_STREAM_ID = 0u;
-
     uint32_t MIN_W = 176;
     uint32_t MIN_H = 144;
     uint32_t MAX_W = 4096;
     uint32_t MAX_H = 4096;
     getMaxMinResolutionSupported(&MIN_W, &MIN_H, &MAX_W, &MAX_H);
-    pr.RegisterSupportedRange<C2StreamPictureSizeInfo>(&C2StreamPictureSizeInfo::width, MIN_W, MAX_W);
-    pr.RegisterSupportedRange<C2StreamPictureSizeInfo>(&C2StreamPictureSizeInfo::height, MIN_H, MAX_H);
+
+    addParameter(
+        DefineParam(m_kind, C2_PARAMKEY_COMPONENT_KIND)
+        .withConstValue(new C2ComponentKindSetting(C2Component::KIND_ENCODER))
+        .build());
+
+    addParameter(
+        DefineParam(m_domain, C2_PARAMKEY_COMPONENT_DOMAIN)
+        .withConstValue(new C2ComponentDomainSetting(C2Component::DOMAIN_VIDEO))
+        .build());
+
+    addParameter(
+        DefineParam(m_name, C2_PARAMKEY_COMPONENT_NAME)
+        .withConstValue(AllocSharedString<C2ComponentNameSetting>(name.c_str()))
+        .build());
+
+    addParameter(
+        DefineParam(m_size, C2_PARAMKEY_PICTURE_SIZE)
+        .withDefault(new C2StreamPictureSizeInfo::input(SINGLE_STREAM_ID, MIN_W, MIN_H))
+        .withFields({
+            C2F(m_size, width).inRange(MIN_W, MAX_W, 2),
+            C2F(m_size, height).inRange(MIN_H, MAX_H, 2),
+        })
+        .withSetter(SizeSetter)
+        .build());
+
+    addParameter(
+        DefineParam(m_inputMediaType, C2_PARAMKEY_INPUT_MEDIA_TYPE)
+        .withConstValue(AllocSharedString<C2PortMediaTypeSetting::input>("video/raw"))
+        .build());
+    
+    addParameter(
+        DefineParam(m_inputFormat, C2_PARAMKEY_INPUT_STREAM_BUFFER_TYPE)
+        .withConstValue(new C2StreamBufferTypeSetting::input(
+                SINGLE_STREAM_ID, C2BufferData::GRAPHIC))
+        .build());
+    
+    addParameter(
+        DefineParam(m_outputFormat, C2_PARAMKEY_OUTPUT_STREAM_BUFFER_TYPE)
+        .withConstValue(new C2StreamBufferTypeSetting::output(
+                SINGLE_STREAM_ID, C2BufferData::LINEAR))
+        .build());
+
+    addParameter(
+        DefineParam(m_bitrateMode, C2_PARAMKEY_BITRATE_MODE)
+        .withDefault(new C2StreamBitrateModeTuning::output(SINGLE_STREAM_ID, C2Config::BITRATE_VARIABLE))
+        .withFields({
+            C2F(m_bitrateMode, value).oneOf({
+                C2Config::BITRATE_CONST,
+                C2Config::BITRATE_VARIABLE,
+                C2Config::BITRATE_IGNORE
+            })
+        })
+        .withSetter(Setter<decltype(*m_bitrateMode)>::StrictValueWithNoDeps)
+        .build());
+
+    addParameter(
+        DefineParam(m_bitrate, C2_PARAMKEY_BITRATE)
+        .withDefault(new C2StreamBitrateInfo::output(SINGLE_STREAM_ID, 64000))
+        .withFields({C2F(m_bitrate, value).inRange(4096, 40000000)})
+        .withSetter(BitrateSetter)
+        .build());
+
+    addParameter(
+        DefineParam(m_frameRate, C2_PARAMKEY_FRAME_RATE)
+        .withDefault(new C2StreamFrameRateInfo::output(SINGLE_STREAM_ID, 1.))
+        .withFields({C2F(m_frameRate, value).greaterThan(0.)})
+        .withSetter(Setter<decltype(*m_frameRate)>::StrictValueWithNoDeps)
+        .build());
+
+    addParameter(
+        DefineParam(m_gop, C2_PARAMKEY_GOP)
+        .withDefault(C2StreamGopTuning::output::AllocShared(
+                0 /* flexCount */, SINGLE_STREAM_ID /* stream */))
+        .withFields({C2F(m_gop, m.values[0].type_).any(),
+                        C2F(m_gop, m.values[0].count).any()})
+        .withSetter(GopSetter)
+        .build());
+    
+    addParameter(
+        DefineParam(m_requestSync, C2_PARAMKEY_REQUEST_SYNC_FRAME)
+        .withDefault(new C2StreamRequestSyncFrameTuning::output(SINGLE_STREAM_ID, C2_FALSE))
+        .withFields({C2F(m_requestSync, value).oneOf({ C2_FALSE, C2_TRUE }) })
+        .withSetter(Setter<decltype(*m_requestSync)>::NonStrictValueWithNoDeps)
+        .build());
+
+    addParameter(
+        DefineParam(m_syncFramePeriod, C2_PARAMKEY_SYNC_FRAME_INTERVAL)
+        .withDefault(new C2StreamSyncFrameIntervalTuning::output(SINGLE_STREAM_ID, 1000000))
+        .withFields({C2F(m_syncFramePeriod, value).any()})
+        .withSetter(Setter<decltype(*m_syncFramePeriod)>::StrictValueWithNoDeps)
+        .build());
 
     switch(m_encoderType) {
         case ENCODER_H264: {
-            supported_profiles = {
-                PROFILE_AVC_CONSTRAINED_BASELINE,
-                PROFILE_AVC_BASELINE,
-                PROFILE_AVC_MAIN,
-                PROFILE_AVC_CONSTRAINED_HIGH,
-                PROFILE_AVC_PROGRESSIVE_HIGH,
-                PROFILE_AVC_HIGH,
-            };
-            supported_levels = {
-                LEVEL_AVC_1, LEVEL_AVC_1B, LEVEL_AVC_1_1,
-                LEVEL_AVC_1_2, LEVEL_AVC_1_3,
-                LEVEL_AVC_2, LEVEL_AVC_2_1, LEVEL_AVC_2_2,
-                LEVEL_AVC_3, LEVEL_AVC_3_1, LEVEL_AVC_3_2,
-                LEVEL_AVC_4, LEVEL_AVC_4_1, LEVEL_AVC_4_2,
-                LEVEL_AVC_5, LEVEL_AVC_5_1, LEVEL_AVC_5_2,
-            };
-            pr.AddValue(C2_PARAMKEY_OUTPUT_MEDIA_TYPE,
-                AllocUniqueString<C2PortMediaTypeSetting::output>("video/avc"));
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::output>(SINGLE_STREAM_ID, PROFILE_AVC_CONSTRAINED_BASELINE, LEVEL_AVC_5_2));
+            addParameter(
+                DefineParam(m_outputMediaType, C2_PARAMKEY_OUTPUT_MEDIA_TYPE)
+                .withConstValue(C2PortMediaTypeSetting::output::AllocShared("video/avc"))
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::output(
+                    SINGLE_STREAM_ID, PROFILE_AVC_CONSTRAINED_BASELINE, LEVEL_AVC_5_2))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_AVC_BASELINE,
+                            PROFILE_AVC_CONSTRAINED_BASELINE,
+                            PROFILE_AVC_MAIN,
+                            PROFILE_AVC_CONSTRAINED_HIGH,
+                            PROFILE_AVC_PROGRESSIVE_HIGH,
+                            PROFILE_AVC_HIGH,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_AVC_1, LEVEL_AVC_1B, LEVEL_AVC_1_1,
+                            LEVEL_AVC_1_2, LEVEL_AVC_1_3,
+                            LEVEL_AVC_2, LEVEL_AVC_2_1, LEVEL_AVC_2_2,
+                            LEVEL_AVC_3, LEVEL_AVC_3_1, LEVEL_AVC_3_2,
+                            LEVEL_AVC_4, LEVEL_AVC_4_1, LEVEL_AVC_4_2,
+                            LEVEL_AVC_5, LEVEL_AVC_5_1, LEVEL_AVC_5_2,
+                        }),})
+                .withSetter(AVC_ProfileLevelSetter)
+                .build());
             break;
-        }
+        };
         case ENCODER_H265: {
-            supported_profiles = {
-                PROFILE_HEVC_MAIN,
-                PROFILE_HEVC_MAIN_STILL,
-                PROFILE_HEVC_MAIN_10,
-            };
-
-            supported_levels = {
-                LEVEL_HEVC_MAIN_1,
-                LEVEL_HEVC_MAIN_2, LEVEL_HEVC_MAIN_2_1,
-                LEVEL_HEVC_MAIN_3, LEVEL_HEVC_MAIN_3_1,
-                LEVEL_HEVC_MAIN_4, LEVEL_HEVC_MAIN_4_1,
-                LEVEL_HEVC_MAIN_5, LEVEL_HEVC_MAIN_5_1,
-                LEVEL_HEVC_MAIN_5_2, LEVEL_HEVC_HIGH_4,
-                LEVEL_HEVC_HIGH_4_1, LEVEL_HEVC_HIGH_5,
-                LEVEL_HEVC_HIGH_5_1, LEVEL_HEVC_HIGH_5_2,
-            };
-            pr.AddValue(C2_PARAMKEY_OUTPUT_MEDIA_TYPE,
-                AllocUniqueString<C2PortMediaTypeSetting::output>("video/hevc"));
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::output>(SINGLE_STREAM_ID, PROFILE_HEVC_MAIN, LEVEL_HEVC_MAIN_5_1));
+            addParameter(
+                DefineParam(m_outputMediaType, C2_PARAMKEY_OUTPUT_MEDIA_TYPE)
+                .withConstValue(C2PortMediaTypeSetting::output::AllocShared("video/hevc"))
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::output(
+                    SINGLE_STREAM_ID, PROFILE_HEVC_MAIN, LEVEL_HEVC_MAIN_5_1))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_HEVC_MAIN,
+                            PROFILE_HEVC_MAIN_STILL,
+                            PROFILE_HEVC_MAIN_10,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_HEVC_MAIN_1,
+                            LEVEL_HEVC_MAIN_2, LEVEL_HEVC_MAIN_2_1,
+                            LEVEL_HEVC_MAIN_3, LEVEL_HEVC_MAIN_3_1,
+                            LEVEL_HEVC_MAIN_4, LEVEL_HEVC_MAIN_4_1,
+                            LEVEL_HEVC_MAIN_5, LEVEL_HEVC_MAIN_5_1,
+                            LEVEL_HEVC_MAIN_5_2, LEVEL_HEVC_HIGH_4,
+                            LEVEL_HEVC_HIGH_4_1, LEVEL_HEVC_HIGH_5,
+                            LEVEL_HEVC_HIGH_5_1, LEVEL_HEVC_HIGH_5_2,
+                            LEVEL_HEVC_MAIN_6, LEVEL_HEVC_MAIN_6_1,
+                            LEVEL_HEVC_MAIN_6_2,
+                        }),})
+                .withSetter(HEVC_ProfileLevelSetter)
+                .build());
             break;
-        }
+        };
         case ENCODER_VP9: {
-            supported_profiles = {
-                PROFILE_VP9_0,
-                PROFILE_VP9_2,
-            };
-
-            supported_levels = {
-                LEVEL_VP9_1, LEVEL_VP9_1_1,
-                LEVEL_VP9_2, LEVEL_VP9_2_1,
-                LEVEL_VP9_3, LEVEL_VP9_3_1,
-                LEVEL_VP9_4, LEVEL_VP9_4_1,
-                LEVEL_VP9_5,
-            };
-            pr.AddValue(C2_PARAMKEY_OUTPUT_MEDIA_TYPE,
-                AllocUniqueString<C2PortMediaTypeSetting::output>("video/x-vnd.on2.vp9"));
-            pr.AddValue(C2_PARAMKEY_PROFILE_LEVEL,
-                std::make_unique<C2StreamProfileLevelInfo::input>(0u, PROFILE_VP9_0, LEVEL_VP9_5));
+            addParameter(
+                DefineParam(m_outputMediaType, C2_PARAMKEY_OUTPUT_MEDIA_TYPE)
+                .withConstValue(C2PortMediaTypeSetting::output::AllocShared("video/x-vnd.on2.vp9"))
+                .build());
+
+            addParameter(DefineParam(m_profileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                .withDefault(new C2StreamProfileLevelInfo::output(
+                    SINGLE_STREAM_ID, PROFILE_VP9_0, LEVEL_VP9_5))
+                .withFields({
+                    C2F(m_profileLevel, C2ProfileLevelStruct::profile)
+                        .oneOf({
+                            PROFILE_VP9_0,
+                            PROFILE_VP9_1,
+                            PROFILE_VP9_2,
+                            PROFILE_VP9_3,
+                        }),
+                    C2F(m_profileLevel, C2ProfileLevelStruct::level)
+                        .oneOf({
+                            LEVEL_VP9_1, LEVEL_VP9_1_1,
+                            LEVEL_VP9_2, LEVEL_VP9_2_1,
+                            LEVEL_VP9_3, LEVEL_VP9_3_1,
+                            LEVEL_VP9_4, LEVEL_VP9_4_1,
+                            LEVEL_VP9_5,
+                        }),})
+                .withSetter(VP9_ProfileLevelSetter)
+                .build());
             break;
         };
+        default: {
+            // TODO: error
+        };
     }
 
-    pr.AddValue(C2_PARAMKEY_COMPONENT_DOMAIN,
-        std::make_unique<C2ComponentDomainSetting>(C2Component::DOMAIN_VIDEO));
-
-    pr.AddValue(C2_PARAMKEY_COMPONENT_KIND,
-        std::make_unique<C2ComponentKindSetting>(C2Component::KIND_ENCODER));
-
-    pr.AddValue(C2_PARAMKEY_COMPONENT_NAME,
-        AllocUniqueString<C2ComponentNameSetting>(name.c_str()));
-
-    pr.AddValue(C2_PARAMKEY_INPUT_STREAM_BUFFER_TYPE,
-        std::make_unique<C2StreamBufferTypeSetting::input>(SINGLE_STREAM_ID, C2BufferData::GRAPHIC));
-    pr.AddValue(C2_PARAMKEY_OUTPUT_STREAM_BUFFER_TYPE,
-        std::make_unique<C2StreamBufferTypeSetting::output>(SINGLE_STREAM_ID, C2BufferData::LINEAR));
-
-    pr.AddValue(C2_PARAMKEY_INPUT_MEDIA_TYPE,
-        AllocUniqueString<C2PortMediaTypeSetting::input>("video/raw"));
-
-    pr.AddValue(C2_PARAMKEY_BITRATE_MODE,
-        std::make_unique<C2StreamBitrateModeTuning::output>(SINGLE_STREAM_ID, C2Config::bitrate_mode_t::BITRATE_VARIABLE));
-
-    pr.AddValue(C2_PARAMKEY_REQUEST_SYNC_FRAME, 
-        std::make_unique<C2StreamRequestSyncFrameTuning::output>(SINGLE_STREAM_ID, false));
-
-    pr.AddValue(C2_PARAMKEY_SYNC_FRAME_INTERVAL, 
-        std::make_unique<C2StreamSyncFrameIntervalTuning::output>(SINGLE_STREAM_ID, 0));
-
-    pr.AddStreamInfo<C2StreamPictureSizeInfo::input>(
-        C2_PARAMKEY_PICTURE_SIZE, SINGLE_STREAM_ID,
-        [this] (C2StreamPictureSizeInfo::input* dst)->bool {
-            MFX_DEBUG_TRACE("GetPictureSize");
-            dst->width = m_mfxVideoParamsConfig.mfx.FrameInfo.CropW;
-            dst->height = m_mfxVideoParamsConfig.mfx.FrameInfo.CropH;
-            MFX_DEBUG_TRACE_STREAM(NAMED(dst->width) << NAMED(dst->height));
-            return true;
-        },
-        [this] (const C2StreamPictureSizeInfo::input& src)->bool {
-            MFX_DEBUG_TRACE("SetPictureSize");
-            m_mfxVideoParamsConfig.mfx.FrameInfo.Width = MFX_MEM_ALIGN(src.width, 16);
-            m_mfxVideoParamsConfig.mfx.FrameInfo.Height = MFX_MEM_ALIGN(src.height, 16);
-            m_mfxVideoParamsConfig.mfx.FrameInfo.CropX = 0;
-            m_mfxVideoParamsConfig.mfx.FrameInfo.CropY = 0;
-            m_mfxVideoParamsConfig.mfx.FrameInfo.CropW = src.width;
-            m_mfxVideoParamsConfig.mfx.FrameInfo.CropH = src.height;
-            MFX_DEBUG_TRACE_STREAM(NAMED(src.width) << NAMED(src.height));
-            return true;
-        }
-    );
-
-    // List all the supported profiles and levels
-    pr.RegisterSupportedValues<C2StreamProfileLevelInfo>(&C2StreamProfileLevelInfo::C2ProfileLevelStruct::profile, supported_profiles);
-    pr.RegisterSupportedValues<C2StreamProfileLevelInfo>(&C2StreamProfileLevelInfo::C2ProfileLevelStruct::level, supported_levels);
-
+    addParameter(
+        DefineParam(m_colorAspects, C2_PARAMKEY_COLOR_ASPECTS)
+        .withDefault(new C2StreamColorAspectsInfo::input(
+                SINGLE_STREAM_ID, C2Color::RANGE_UNSPECIFIED, C2Color::PRIMARIES_UNSPECIFIED,
+                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED))
+        .withFields({
+            C2F(m_colorAspects, range).inRange(
+                        C2Color::RANGE_UNSPECIFIED,     C2Color::RANGE_OTHER),
+            C2F(m_colorAspects, primaries).inRange(
+                        C2Color::PRIMARIES_UNSPECIFIED, C2Color::PRIMARIES_OTHER),
+            C2F(m_colorAspects, transfer).inRange(
+                        C2Color::TRANSFER_UNSPECIFIED,  C2Color::TRANSFER_OTHER),
+            C2F(m_colorAspects, matrix).inRange(
+                        C2Color::MATRIX_UNSPECIFIED,    C2Color::MATRIX_OTHER)
+        })
+        .withSetter(ColorAspectsSetter)
+        .build());
+
+    addParameter(
+        DefineParam(m_codedColorAspects, C2_PARAMKEY_VUI_COLOR_ASPECTS)
+        .withDefault(new C2StreamColorAspectsInfo::output(
+                SINGLE_STREAM_ID, C2Color::RANGE_LIMITED, C2Color::PRIMARIES_UNSPECIFIED,
+                C2Color::TRANSFER_UNSPECIFIED, C2Color::MATRIX_UNSPECIFIED))
+        .withFields({
+            C2F(m_codedColorAspects, range).inRange(
+                        C2Color::RANGE_UNSPECIFIED,     C2Color::RANGE_OTHER),
+            C2F(m_codedColorAspects, primaries).inRange(
+                        C2Color::PRIMARIES_UNSPECIFIED, C2Color::PRIMARIES_OTHER),
+            C2F(m_codedColorAspects, transfer).inRange(
+                        C2Color::TRANSFER_UNSPECIFIED,  C2Color::TRANSFER_OTHER),
+            C2F(m_codedColorAspects, matrix).inRange(
+                        C2Color::MATRIX_UNSPECIFIED,    C2Color::MATRIX_OTHER)
+        })
+        .withSetter(CodedColorAspectsSetter, m_colorAspects)
+        .build());
+
+    addParameter(
+        DefineParam(m_intraRefresh, C2_PARAMKEY_INTRA_REFRESH)
+        .withDefault(new C2StreamIntraRefreshTuning::output(
+                0u, C2Config::INTRA_REFRESH_DISABLED, 0.))
+        .withFields({
+            C2F(m_intraRefresh, mode).oneOf({
+                C2Config::INTRA_REFRESH_DISABLED, C2Config::INTRA_REFRESH_ARBITRARY }),
+            C2F(m_intraRefresh, period).any()
+        })
+        .withSetter(IntraRefreshSetter)
+        .build());
     // Color aspects
-    pr.RegisterParam<C2StreamColorAspectsInfo::input>(C2_PARAMKEY_COLOR_ASPECTS);
-    pr.RegisterParam<C2StreamColorAspectsInfo::output>(C2_PARAMKEY_VUI_COLOR_ASPECTS);
+    //pr.RegisterParam<C2StreamColorAspectsInfo::input>(C2_PARAMKEY_COLOR_ASPECTS);
+    //pr.RegisterParam<C2StreamColorAspectsInfo::output>(C2_PARAMKEY_VUI_COLOR_ASPECTS);
 
     m_colorAspects = std::make_shared<C2StreamColorAspectsInfo::input>();
     m_colorAspects->range = C2Color::RANGE_UNSPECIFIED;
@@ -264,7 +460,7 @@ MfxC2EncoderComponent::MfxC2EncoderComponent(const C2String name, const CreateCo
     m_codedColorAspects->matrix = C2Color::MATRIX_UNSPECIFIED;
     m_codedColorAspects->primaries = C2Color::PRIMARIES_UNSPECIFIED;
 
-    m_paramStorage.DumpParams();
+    //m_paramStorage.DumpParams();
 }
 
 MfxC2EncoderComponent::~MfxC2EncoderComponent()
@@ -983,7 +1179,8 @@ c2_status_t MfxC2EncoderComponent::ApplyWorkTunings(C2Work& work)
                 // in contrast to Config method protected with state mutex.
                 // So AcquireStableStateLock is needed here.
                 std::unique_lock<std::mutex> lock = AcquireStableStateLock(true);
-                DoConfig(params, &failures, false);
+                res = config(params, C2_DONT_BLOCK, &failures);
+                DoUpdateMfxParam(params, &failures, false);
             }
             for(auto& failure : failures) {
                 worklet->failures.push_back(std::move(failure));
@@ -1401,227 +1598,57 @@ std::unique_ptr<mfxVideoParam> MfxC2EncoderComponent::GetParamsView() const
     return res;
 }
 
-c2_status_t MfxC2EncoderComponent::QueryParam(const mfxVideoParam* src, C2Param::Index index, C2Param** dst) const
+c2_status_t MfxC2EncoderComponent::UpdateC2Param(C2Param::Index index) const
 {
     MFX_DEBUG_TRACE_FUNC;
 
     c2_status_t res = C2_OK;
 
-    res = m_paramStorage.QueryParam(index, dst);
-    if (C2_NOT_FOUND == res) {
-        res = C2_OK; // suppress error as second pass to find param
-
-        switch (index.typeIndex()) {
-            case kParamIndexRateControl: {
-                if (nullptr == *dst) {
-                    *dst = new C2RateControlSetting();
-                }
-                C2RateControlSetting* rate_control = (C2RateControlSetting*)*dst;
-                switch(src->mfx.RateControlMethod) {
-                    case MFX_RATECONTROL_CBR: rate_control->value = C2RateControlCBR; break;
-                    case MFX_RATECONTROL_VBR: rate_control->value = C2RateControlVBR; break;
-                    case MFX_RATECONTROL_CQP: rate_control->value = C2RateControlCQP; break;
-                    default:
-                        res = C2_CORRUPTED;
-                        break;
-                }
-                break;
-            }
-            case kParamIndexFrameRate: {
-                if (nullptr == *dst) {
-                    *dst = new C2StreamFrameRateInfo::output();
-                }
-                C2StreamFrameRateInfo* framerate = (C2StreamFrameRateInfo*)*dst;
-                framerate->value = (float)src->mfx.FrameInfo.FrameRateExtN / src->mfx.FrameInfo.FrameRateExtD;
-                break;
-            }
-            case kParamIndexBitrate: {
-                if (nullptr == *dst) {
-                    *dst = new C2StreamBitrateInfo::output();
-                }
-                C2StreamBitrateInfo* bitrate = (C2StreamBitrateInfo*)*dst;
-                if (src->mfx.RateControlMethod != MFX_RATECONTROL_CQP) {
-                    bitrate->value = src->mfx.TargetKbps * 1000; // Convert from Kbps to bps
-                } else {
-                    res = C2_CORRUPTED;
-                }
-                break;
-            }
-            case kParamIndexFrameQP: {
-                if (nullptr == *dst) {
-                    *dst = new C2FrameQPSetting();
-                }
-                C2FrameQPSetting* frame_qp = (C2FrameQPSetting*)*dst;
-                if (src->mfx.RateControlMethod == MFX_RATECONTROL_CQP) {
-                    frame_qp->qp_i = src->mfx.QPI;
-                    frame_qp->qp_p = src->mfx.QPP;
-                    frame_qp->qp_b = src->mfx.QPB;
-                } else {
-                    res = C2_CORRUPTED;
-                }
-                break;
-            }
-            case kParamIndexProfile: {
-                if (nullptr == *dst) {
-                    *dst = new C2ProfileSetting();
-                }
-                C2Config::profile_t profile {};
-                bool set_res = false;
-                switch (m_encoderType) {
-                    case ENCODER_H264:
-                        set_res = AvcProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &profile);
-                        break;
-                    case ENCODER_H265:
-                        set_res = HevcProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &profile);
-                        break;
-                    case ENCODER_VP9:
-                        set_res = Vp9ProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &profile);
-                        break;
-                    default:
-                        break;
-                }
-                if (set_res) {
-                    C2ProfileSetting* setting = static_cast<C2ProfileSetting*>(*dst);
-                    setting->value = profile;
-                } else {
-                    res = C2_CORRUPTED;
-                }
-                break;
-            }
-            case kParamIndexLevel: {
-                if (nullptr == *dst) {
-                    *dst = new C2LevelSetting();
-                }
-                C2Config::level_t level {};
-                bool set_res = false;
-                switch (m_encoderType) {
-                    case ENCODER_H264:
-                        set_res = AvcLevelMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecLevel, &level);
-                        break;
-                    case ENCODER_H265:
-                        set_res = HevcLevelMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecLevel, &level);
-                        break;
-                    default:
-                        break;
-                }
-                if (set_res) {
-                    C2LevelSetting* setting = static_cast<C2LevelSetting*>(*dst);
-                    setting->value = level;
-                } else {
-                    res = C2_CORRUPTED;
-                }
-                break;
-            }
-            case kParamIndexProfileLevel:
-                if (nullptr == *dst) {
-                    if (m_encoderType == ENCODER_H264) {
-                        std::unique_ptr<C2ProfileLevelInfo::output> info =
-                            C2ProfileLevelInfo::output::AllocUnique(g_h264_profile_levels_count);
-
-                        for (size_t i = 0; i < g_h264_profile_levels_count; ++i) {
-                            info->m.values[i] = g_h264_profile_levels[i];
-                        }
-                        *dst = info.release();
-                    } else if (m_encoderType == ENCODER_H265) {
-                        std::unique_ptr<C2ProfileLevelInfo::output> info =
-                            C2ProfileLevelInfo::output::AllocUnique(g_h265_profile_levels_count);
-
-                        for (size_t i = 0; i < g_h265_profile_levels_count; ++i) {
-                            info->m.values[i] = g_h265_profile_levels[i];
-                        }
-                        *dst = info.release();
-                    } else {
-                        res = C2_CORRUPTED;
-                    }
-                } else { // not possible to return flexible params through stack
-                    res = C2_NO_MEMORY;
-                }
-                break;
-            case kParamIndexMemoryType: {
-                if (nullptr == *dst) {
-                    *dst = new C2MemoryTypeSetting();
-                }
-
-                C2MemoryTypeSetting* setting = static_cast<C2MemoryTypeSetting*>(*dst);
-                if (!MfxIOPatternToC2MemoryType(true, m_mfxVideoParamsConfig.IOPattern, &setting->value)) res = C2_CORRUPTED;
-                break;
-            }
-            case kParamIndexSyncFrameInterval: {
-                if (nullptr == *dst) {
-                    *dst = new C2StreamSyncFrameIntervalTuning();
-                }
-
-                C2StreamSyncFrameIntervalTuning* setting = static_cast<C2StreamSyncFrameIntervalTuning*>(*dst);
-                setting->value = m_mfxVideoParamsConfig.mfx.GopPicSize;
-                break;
-            }
-            case kParamIndexColorAspects: {
-                if (C2StreamColorAspectsInfo::input::PARAM_TYPE == index) {
-                    if (nullptr == *dst) {
-                        *dst = new C2StreamColorAspectsInfo::input();
-                    }
-
-                    C2StreamColorAspectsInfo::input* setting = static_cast<C2StreamColorAspectsInfo::input*>(*dst);
-
-                    setting->range = m_colorAspects->range;
-                    setting->transfer = m_colorAspects->transfer;
-                    setting->matrix = m_colorAspects->matrix;
-                    setting->primaries = m_colorAspects->primaries;
-
-                    MFX_DEBUG_TRACE_U32(setting->range);
-                    MFX_DEBUG_TRACE_U32(setting->primaries);
-                    MFX_DEBUG_TRACE_U32(setting->transfer);
-                    MFX_DEBUG_TRACE_U32(setting->matrix);
-                } else {
-                    if (nullptr == *dst) {
-                       *dst = new C2StreamColorAspectsInfo::output();
-                    }
-
-                    C2StreamColorAspectsInfo::output* setting = static_cast<C2StreamColorAspectsInfo::output*>(*dst);
-
-                    setting->range = m_codedColorAspects->range;
-                    setting->transfer = m_codedColorAspects->transfer;
-                    setting->matrix = m_codedColorAspects->matrix;
-                    setting->primaries = m_codedColorAspects->primaries;
-
-                    MFX_DEBUG_TRACE_U32(setting->range);
-                    MFX_DEBUG_TRACE_U32(setting->primaries);
-                    MFX_DEBUG_TRACE_U32(setting->transfer);
-                    MFX_DEBUG_TRACE_U32(setting->matrix);
-                }
-                break;
-            }
-            case kParamIndexBitrateMode: {
-                if (nullptr == *dst) {
-                    *dst = new C2StreamBitrateModeTuning::output();
-                }
-
-                C2StreamBitrateModeTuning::output* setting = static_cast<C2StreamBitrateModeTuning::output*>(*dst);
-                switch (m_mfxVideoParamsConfig.mfx.RateControlMethod) {
-                    case MFX_RATECONTROL_CBR:
-                        setting->value = C2Config::bitrate_mode_t::BITRATE_CONST;
-                        break;
-                    case MFX_RATECONTROL_VBR:
-                        setting->value = C2Config::bitrate_mode_t::BITRATE_VARIABLE;
-                        break;
-                    default:
-                        setting->value = C2Config::bitrate_mode_t::BITRATE_IGNORE;
-                        break;
-                }
-                MFX_DEBUG_TRACE_STREAM("QueryParam BitrateMode = " << setting->value);
-                break;
+    switch (index.typeIndex()) {
+        case kParamIndexFrameRate: {
+            m_frameRate->value = (float)m_mfxVideoParamsConfig.mfx.FrameInfo.FrameRateExtN / 
+                            m_mfxVideoParamsConfig.mfx.FrameInfo.FrameRateExtD;
+            break;
+        }
+        case kParamIndexBitrate: {
+            m_bitrate->value = m_mfxVideoParamsConfig.mfx.TargetKbps * 1000; // Convert from Kbps to bps
+            break;
+        }
+        case kParamIndexProfileLevel: {
+            switch (m_encoderType) {
+                case ENCODER_H264:
+                    AvcProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &m_profileLevel->profile);
+                    AvcLevelMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecLevel, &m_profileLevel->level);
+                    break;
+                case ENCODER_H265:
+                    HevcProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &m_profileLevel->profile);
+                    HevcLevelMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecLevel, &m_profileLevel->level);
+                    break;
+                case ENCODER_VP9:
+                    Vp9ProfileMfxToAndroid(m_mfxVideoParamsConfig.mfx.CodecProfile, &m_profileLevel->profile);
+                    break;
+                default:
+                    MFX_DEBUG_TRACE_STREAM("cannot find the type " << m_encoderType );
+                    break;
             }
-            default:
-                res = C2_BAD_INDEX;
-                break;
+            MFX_DEBUG_TRACE_STREAM("m_profileLevel->profile = " << m_profileLevel->profile << ", m_profileLevel->level = "
+                            << m_profileLevel->level << ", mfx.CodecProfile = " << m_mfxVideoParamsConfig.mfx.CodecProfile
+                            << ", mfx.CodecLevel = " << m_mfxVideoParamsConfig.mfx.CodecLevel);
+            break;
+        }
+        case kParamIndexSyncFrameInterval: {
+            m_syncFramePeriod->value = m_mfxVideoParamsConfig.mfx.GopPicSize;
+            break;
         }
+        default:
+            break;
     }
 
     MFX_DEBUG_TRACE__android_c2_status_t(res);
     return res;
 }
 
-c2_status_t MfxC2EncoderComponent::Query(
+c2_status_t MfxC2EncoderComponent::UpdateMfxParamToC2(
     std::unique_lock<std::mutex> m_statelock,
     const std::vector<C2Param*> &stackParams,
     const std::vector<C2Param::Index> &heapParamIndices,
@@ -1630,6 +1657,7 @@ c2_status_t MfxC2EncoderComponent::Query(
 {
     (void)m_statelock;
     (void)mayBlock;
+    (void)heapParams;
 
     MFX_DEBUG_TRACE_FUNC;
 
@@ -1637,110 +1665,40 @@ c2_status_t MfxC2EncoderComponent::Query(
 
     c2_status_t res = C2_OK;
 
-    // determine source, update it if needed
-    std::unique_ptr<mfxVideoParam> params_view = GetParamsView();
-    if (nullptr != params_view) {
-        // 1st cycle on stack params
-        for (C2Param* param : stackParams) {
-            c2_status_t param_res = C2_OK;
-            if (m_paramStorage.FindParam(param->index())) {
-                param_res = QueryParam(params_view.get(), param->index(), &param);
-            } else {
-                param_res =  C2_BAD_INDEX;
-            }
-            if (param_res != C2_OK) {
-                param->invalidate();
-                res = param_res;
-            }
-        }
-        // 2nd cycle on heap params
-        for (C2Param::Index param_index : heapParamIndices) {
-            // allocate in QueryParam
-            C2Param* param = nullptr;
-            // check on presence
-            c2_status_t param_res = C2_OK;
-            if (m_paramStorage.FindParam(param_index.type())) {
-                param_res = QueryParam(params_view.get(), param_index, &param);
-            } else {
-                param_res = C2_BAD_INDEX;
-            }
-            if (param_res == C2_OK) {
-                if(nullptr != heapParams) {
-                    heapParams->push_back(std::unique_ptr<C2Param>(param));
-                } else {
-                    MFX_DEBUG_TRACE_MSG("heapParams is null");
-                    res = C2_BAD_VALUE;
-                }
-            } else {
-                delete param;
-                res = param_res;
-            }
-        }
-    } else {
-        // no params_view was acquired
-        for (C2Param* param : stackParams) {
-            param->invalidate();
-        }
-        res = C2_CORRUPTED;
+    // 1st cycle on stack params
+    for (C2Param* param : stackParams) {
+        UpdateC2Param(param->index());
+    }
+    // 2nd cycle on heap params
+    for (C2Param::Index param_index : heapParamIndices) {
+        UpdateC2Param(param_index);
     }
 
     MFX_DEBUG_TRACE__android_c2_status_t(res);
     return res;
 }
 
-void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
+void MfxC2EncoderComponent::DoUpdateMfxParam(const std::vector<C2Param*> &params,
     std::vector<std::unique_ptr<C2SettingResult>>* const failures,
     bool queue_update)
 {
     MFX_DEBUG_TRACE_FUNC;
 
     for (const C2Param* param : params) {
-        // check whether plugin supports this parameter
-        std::unique_ptr<C2SettingResult> find_res = m_paramStorage.FindParam(param);
-        if(nullptr != find_res) {
-            failures->push_back(std::move(find_res));
-            continue;
-        }
-        // check whether plugin is in a correct state to apply this parameter
-        bool modifiable = (param->coreIndex().coreIndex() == kParamIndexBitrate) ||
-		((param->kind() & C2Param::TUNING) != 0) ||
-		m_state == State::STOPPED; /* all kinds, even INFO might be set by stagefright */
-
-        if (!modifiable) {
-            failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::READ_ONLY));
-            continue;
-        }
-
-        // check ranges
-        if(!m_paramStorage.ValidateParam(param, failures)) {
-            continue;
-        }
-
         // applying parameter
         switch (C2Param::Type(param->type()).typeIndex()) {
-            case kParamIndexRateControl: {
-                mfxStatus sts = MFX_ERR_NONE;
-                switch (static_cast<const C2RateControlSetting*>(param)->value) {
-                    case C2RateControlCBR:
-                        sts = mfx_set_RateControlMethod(MFX_RATECONTROL_CBR, &m_mfxVideoParamsConfig);
-                        break;
-                    case C2RateControlVBR:
-                        sts = mfx_set_RateControlMethod(MFX_RATECONTROL_VBR, &m_mfxVideoParamsConfig);
-                        break;
-                    case C2RateControlCQP:
-                        sts = mfx_set_RateControlMethod(MFX_RATECONTROL_CQP, &m_mfxVideoParamsConfig);
-                        break;
-                    default:
-                        sts = MFX_ERR_INVALID_VIDEO_PARAM;
-                        break;
-                }
-                if(MFX_ERR_NONE != sts) {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
-                }
+            case kParamIndexPictureSize: {
+                MFX_DEBUG_TRACE_STREAM("updating m_size->width = " << m_size->width << ", m_size->height = " << m_size->height);
+                m_mfxVideoParamsConfig.mfx.FrameInfo.Width = MFX_MEM_ALIGN(m_size->width, 16);
+                m_mfxVideoParamsConfig.mfx.FrameInfo.Height = MFX_MEM_ALIGN(m_size->height, 16);
+                m_mfxVideoParamsConfig.mfx.FrameInfo.CropX = 0;
+                m_mfxVideoParamsConfig.mfx.FrameInfo.CropY = 0;
+                m_mfxVideoParamsConfig.mfx.FrameInfo.CropW = m_size->width;
+                m_mfxVideoParamsConfig.mfx.FrameInfo.CropH = m_size->height;
                 break;
             }
             case kParamIndexFrameRate: {
-                float framerate_value = static_cast<const C2StreamFrameRateInfo*>(param)->value;
+                float framerate_value = m_frameRate->value;
 
                 if (m_encoderType == ENCODER_H264 && framerate_value > MFX_MAX_H264_FRAMERATE) {
                     framerate_value = MFX_MAX_H264_FRAMERATE;
@@ -1760,7 +1718,7 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
             case kParamIndexBitrate: {
                 // MFX_RATECONTROL_CQP parameter is valid only during initialization.
                 if (m_mfxVideoParamsConfig.mfx.RateControlMethod != MFX_RATECONTROL_CQP) {
-                    uint32_t bitrate_value = static_cast<const C2BitrateTuning*>(param)->value;
+                    uint32_t bitrate_value = m_bitrate->value;
                     if (m_state == State::STOPPED) {
                         m_mfxVideoParamsConfig.mfx.TargetKbps = bitrate_value / 1000; // Convert from bps to Kbps
                     } else {
@@ -1798,8 +1756,8 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                                 MFX_DEBUG_TRACE__mfxStatus(reset_sts);
                                 if (MFX_ERR_NONE != reset_sts) {
                                     if (!queue_update) {
-                                        failures->push_back(MakeC2SettingResult(C2ParamField(param),
-                                            C2SettingResult::CONFLICT, MakeVector(MakeC2ParamField<C2RateControlSetting>())));
+                                        //failures->push_back(MakeC2SettingResult(C2ParamField(param),
+                                        //    C2SettingResult::CONFLICT, MakeVector(MakeC2ParamField<C2RateControlSetting>())));
                                     }
                                 }
                             }
@@ -1816,146 +1774,64 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                         }
                     }
                 } else {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param),
-                        C2SettingResult::CONFLICT, MakeVector(MakeC2ParamField<C2RateControlSetting>())));
+                    //failures->push_back(MakeC2SettingResult(C2ParamField(param),
+                    //    C2SettingResult::CONFLICT, MakeVector(MakeC2ParamField<C2RateControlSetting>())));
                 }
                 break;
             }
             case kParamIndexBitrateMode: {
-                C2Config::bitrate_mode_t c2_bitmode = static_cast<const C2StreamBitrateModeTuning*>(param)->value;
-                int32_t bitrate_mode = -1;
-                C2Mapper::map(c2_bitmode, &bitrate_mode);
-                MFX_DEBUG_TRACE_U32(bitrate_mode);
                 mfxStatus sts = MFX_ERR_NONE;
-                switch (bitrate_mode) {
-                    case C2RateControlCBR:
+                switch (m_bitrateMode->value) {
+                    case C2Config::BITRATE_CONST:
                         sts = mfx_set_RateControlMethod(MFX_RATECONTROL_CBR, &m_mfxVideoParamsConfig);
                         break;
-                    case C2RateControlVBR:
+                    case C2Config::BITRATE_VARIABLE:
                         sts = mfx_set_RateControlMethod(MFX_RATECONTROL_VBR, &m_mfxVideoParamsConfig);
                         break;
-                    case C2RateControlCQP:
+                    case C2Config::BITRATE_IGNORE:
                         sts = mfx_set_RateControlMethod(MFX_RATECONTROL_CQP, &m_mfxVideoParamsConfig);
                         break;
                     default:
                         sts = MFX_ERR_INVALID_VIDEO_PARAM;
                         break;
                 }
+                MFX_DEBUG_TRACE_STREAM("set m_bitrateMode->value = " << m_bitrateMode->value);
                 if(MFX_ERR_NONE != sts) {
                     failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
                 }
                 break;
             }
-            case kParamIndexFrameQP: {
-                const C2FrameQPSetting* qp_setting = static_cast<const C2FrameQPSetting*>(param);
-                    if(m_mfxVideoParamsConfig.mfx.RateControlMethod != MFX_RATECONTROL_CQP) {
-                        failures->push_back(MakeC2SettingResult(C2ParamField(param),
-                            C2SettingResult::CONFLICT, MakeVector(MakeC2ParamField<C2RateControlSetting>())));
-                    } else {
-                        MFX_DEBUG_TRACE_STREAM(
-                            NAMED(qp_setting->qp_i) << NAMED(qp_setting->qp_p) << NAMED(qp_setting->qp_b));
-                        m_mfxVideoParamsConfig.mfx.QPI = qp_setting->qp_i;
-                        m_mfxVideoParamsConfig.mfx.QPP = qp_setting->qp_p;
-                        m_mfxVideoParamsConfig.mfx.QPB = qp_setting->qp_b;
-                    }
-                break;
-            }
             case kParamIndexIntraRefresh: {
-                const C2IntraRefreshTuning* intra_refresh = static_cast<const C2IntraRefreshTuning*>(param);
-                if (intra_refresh->value != 0) {
-
-                    auto update = [this] () {
-                        EncoderControl::ModifyFunction modify = [] (mfxEncodeCtrl* ctrl) {
-                            ctrl->FrameType = MFX_FRAMETYPE_IDR | MFX_FRAMETYPE_I;
-                        };
-                        m_encoderControl.Modify(modify);
-                    };
-
-                    if (queue_update) {
-                        m_workingQueue.Push(std::move(update));
-                    } else {
-                        update();
-                    }
-                }
-                break;
-            }
-            case kParamIndexProfile: {
-                const C2ProfileSetting* profile_setting = static_cast<const C2ProfileSetting*>(param);
-                C2Config::profile_t profile = static_cast<C2Config::profile_t>(profile_setting->value);
-                bool set_res = false;
-                switch (m_encoderType) {
-                    case ENCODER_H264:
-                        set_res = AvcProfileAndroidToMfx(profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
-                        break;
-                    case ENCODER_H265:
-                        set_res = HevcProfileAndroidToMfx(profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
-                        break;
-                    default:
-                        break;
-                }
-
-                if (!set_res) {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
-                }
-                break;
-            }
-            case kParamIndexLevel: {
-                const C2LevelSetting* setting = static_cast<const C2LevelSetting*>(param);
-                C2Config::level_t level = static_cast<C2Config::level_t>(setting->value);
-                bool set_res = false;
-                switch (m_encoderType) {
-                    case ENCODER_H264:
-                        set_res = AvcLevelAndroidToMfx(level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
-                        break;
-                    case ENCODER_H265:
-                        set_res = HevcLevelAndroidToMfx(level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
-                        break;
-                    // TODO: MediaSDK unsupport VP9 level?
-                    case ENCODER_VP9:
-                        set_res = true;
-                        break;
-                    default:
-                        break;
-                }
-
-                if (!set_res) {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
-                }
+                MFX_DEBUG_TRACE_MSG("got kParamIndexIntraRefresh");
+                // TODO:
                 break;
             }
             case kParamIndexProfileLevel: {
-                const C2StreamProfileLevelInfo* info = static_cast<const C2StreamProfileLevelInfo*>(param);
                 switch (m_encoderType) {
                     case ENCODER_H264:
-                        AvcProfileAndroidToMfx(info->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
-                        AvcLevelAndroidToMfx(info->level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
+                        AvcProfileAndroidToMfx(m_profileLevel->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
+                        AvcLevelAndroidToMfx(m_profileLevel->level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
                         break;
                     case ENCODER_H265:
-                        HevcProfileAndroidToMfx(info->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
-                        HevcLevelAndroidToMfx(info->level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
+                        HevcProfileAndroidToMfx(m_profileLevel->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
+                        HevcLevelAndroidToMfx(m_profileLevel->level, &m_mfxVideoParamsConfig.mfx.CodecLevel);
                         break;
                     case ENCODER_VP9:
-                        Vp9ProfileAndroidToMfx(info->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
+                        Vp9ProfileAndroidToMfx(m_profileLevel->profile, &m_mfxVideoParamsConfig.mfx.CodecProfile);
                         break;
                     default:
                         break;
                 }
-                break;
-            }
-            case kParamIndexMemoryType: {
-                const C2MemoryTypeSetting* setting = static_cast<const C2MemoryTypeSetting*>(param);
-                bool set_res = C2MemoryTypeToMfxIOPattern(true, setting->value, &m_mfxVideoParamsConfig.IOPattern);
-                if (!set_res) {
-                    failures->push_back(MakeC2SettingResult(C2ParamField(param), C2SettingResult::BAD_VALUE));
-                }
+                MFX_DEBUG_TRACE_STREAM("m_profileLevel->profile = " << m_profileLevel->profile << ", m_profileLevel->level = "
+                            << m_profileLevel->level << ", mfx.CodecProfile = " << m_mfxVideoParamsConfig.mfx.CodecProfile
+                            << ", mfx.CodecLevel = " << m_mfxVideoParamsConfig.mfx.CodecLevel);
                 break;
             }
             case kParamIndexGop: {
-                const C2StreamGopTuning* setting = static_cast<const C2StreamGopTuning*>(param);
                 uint32_t syncInterval = 1;
                 uint32_t iInterval = 1;   // unused
                 uint32_t maxBframes = 0;  // unused
-                ParseGop(*setting, syncInterval, iInterval, maxBframes);
+                ParseGop(m_gop, syncInterval, iInterval, maxBframes);
                 if (syncInterval > 0) {
                     MFX_DEBUG_TRACE_PRINTF("updating m_mfxVideoParamsConfig.mfx.IdrInterval from %d to %d",
                         m_mfxVideoParamsConfig.mfx.IdrInterval, syncInterval);
@@ -1964,8 +1840,7 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                 break;
             }
             case kParamIndexRequestSyncFrame: {
-                const C2StreamRequestSyncFrameTuning* setting = static_cast<const C2StreamRequestSyncFrameTuning*>(param);
-                if (setting->value) {
+                if (m_requestSync->value) {
                     MFX_DEBUG_TRACE_MSG("Got sync request");
                     auto update = [this] () {
                         EncoderControl::ModifyFunction modify = [this] (mfxEncodeCtrl* ctrl) {
@@ -1986,9 +1861,8 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                 break;
             }
             case kParamIndexSyncFrameInterval: {
-                const C2StreamSyncFrameIntervalTuning* setting = static_cast<const C2StreamSyncFrameIntervalTuning*>(param);
-                if (setting->value > 0) {
-                    uint32_t gop_size = getSyncFramePeriod_l(setting->value);
+                if (m_syncFramePeriod->value > 0) {
+                    uint32_t gop_size = getSyncFramePeriod_l(m_syncFramePeriod->value);
                     MFX_DEBUG_TRACE_PRINTF("updating m_mfxVideoParamsConfig.mfx.GopPicSize from %d to %d",
                         m_mfxVideoParamsConfig.mfx.GopPicSize, gop_size);
                     m_mfxVideoParamsConfig.mfx.GopPicSize = gop_size;
@@ -1997,12 +1871,10 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
             }
             case kParamIndexColorAspects: {
                 if (C2StreamColorAspectsInfo::input::PARAM_TYPE == param->index()) {
-                    const C2StreamColorAspectsInfo::input* setting = static_cast<const C2StreamColorAspectsInfo::input*>(param);
-
-                    m_colorAspects->range = setting->range;
-                    m_colorAspects->transfer = setting->transfer;
-                    m_colorAspects->matrix = setting->matrix;
-                    m_colorAspects->primaries = setting->primaries;
+                    m_colorAspects->range = m_colorAspects->range;
+                    m_colorAspects->transfer = m_colorAspects->transfer;
+                    m_colorAspects->matrix = m_colorAspects->matrix;
+                    m_colorAspects->primaries = m_colorAspects->primaries;
 
                     // set video signal info
                     setColorAspects_l();
@@ -2012,12 +1884,10 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                     MFX_DEBUG_TRACE_U32(m_colorAspects->transfer);
                     MFX_DEBUG_TRACE_U32(m_colorAspects->matrix);
                 } else {
-                    const C2StreamColorAspectsInfo::output* setting = static_cast<const C2StreamColorAspectsInfo::output*>(param);
-
-                    m_codedColorAspects->range = setting->range;
-                    m_codedColorAspects->transfer = setting->transfer;
-                    m_codedColorAspects->matrix = setting->matrix;
-                    m_codedColorAspects->primaries = setting->primaries;
+                    m_codedColorAspects->range = m_codedColorAspects->range;
+                    m_codedColorAspects->transfer = m_codedColorAspects->transfer;
+                    m_codedColorAspects->matrix = m_codedColorAspects->matrix;
+                    m_codedColorAspects->primaries = m_codedColorAspects->primaries;
 
                     MFX_DEBUG_TRACE_U32(m_codedColorAspects->range);
                     MFX_DEBUG_TRACE_U32(m_codedColorAspects->primaries);
@@ -2027,13 +1897,12 @@ void MfxC2EncoderComponent::DoConfig(const std::vector<C2Param*> &params,
                 break;
             }
             default:
-                m_paramStorage.ConfigParam(*param, m_state == State::STOPPED, failures);
                 break;
         }
     }
 }
 
-c2_status_t MfxC2EncoderComponent::Config(std::unique_lock<std::mutex> m_statelock,
+c2_status_t MfxC2EncoderComponent::UpdateC2ParamToMfx(std::unique_lock<std::mutex> m_statelock,
     const std::vector<C2Param*> &params,
     c2_blocking_t mayBlock,
     std::vector<std::unique_ptr<C2SettingResult>>* const failures) {
@@ -2054,7 +1923,7 @@ c2_status_t MfxC2EncoderComponent::Config(std::unique_lock<std::mutex> m_statelo
 
         std::lock_guard<std::mutex> lock(m_initEncoderMutex);
 
-        DoConfig(params, failures, true);
+        DoUpdateMfxParam(params, failures, true);
 
         res = GetAggregateStatus(failures);
 
@@ -2221,7 +2090,7 @@ bool MfxC2EncoderComponent::CodedColorAspectsDiffer(std::shared_ptr<C2StreamColo
 
 uint32_t MfxC2EncoderComponent::getSyncFramePeriod_l(int32_t sync_frame_period) const
 {
-     MFX_DEBUG_TRACE_FUNC;
+    MFX_DEBUG_TRACE_FUNC;
 
     if (sync_frame_period < 0 || sync_frame_period == INT64_MAX) {
         return 0;
diff --git a/c2_store/include/mfx_c2_store.h b/c2_store/include/mfx_c2_store.h
index bc7650f..30c8144 100755
--- a/c2_store/include/mfx_c2_store.h
+++ b/c2_store/include/mfx_c2_store.h
@@ -90,6 +90,6 @@ private: // data
 
     MfxXmlParser m_xmlParser;
 
-    std::shared_ptr<MfxC2ParamReflector> m_reflector = std::make_shared<MfxC2ParamReflector>();
+    std::shared_ptr<C2ReflectorHelper> m_reflector = std::make_shared<C2ReflectorHelper>();
     mutable std::mutex m_reflectorMutex;
 };
diff --git a/c2_store/src/mfx_c2_store.cpp b/c2_store/src/mfx_c2_store.cpp
index 776ce68..fca86e4 100755
--- a/c2_store/src/mfx_c2_store.cpp
+++ b/c2_store/src/mfx_c2_store.cpp
@@ -93,7 +93,7 @@ c2_status_t MfxC2ComponentStore::createComponent(C2String name, std::shared_ptr<
                     reinterpret_cast<CreateMfxC2ComponentFunc*>(dlsym(dso.get(), CREATE_MFX_C2_COMPONENT_FUNC_NAME));
                 if(create_func != nullptr) {
 
-                    std::shared_ptr<MfxC2ParamReflector> reflector;
+                    std::shared_ptr<C2ReflectorHelper> reflector;
                     {
                         std::lock_guard<std::mutex> lock(m_reflectorMutex);
                         reflector = m_reflector; // safe copy
@@ -208,10 +208,10 @@ c2_status_t MfxC2ComponentStore::config_sm(
 std::shared_ptr<C2ParamReflector> MfxC2ComponentStore::getParamReflector() const
 {
     MFX_DEBUG_TRACE_FUNC;
-    std::shared_ptr<MfxC2ParamReflector> reflector;
+    std::shared_ptr<C2ParamReflector> reflector;
     {
         std::lock_guard<std::mutex> lock(m_reflectorMutex);
-        reflector = m_reflector; // safe copy
+        reflector = dynamic_pointer_cast<C2ParamReflector>(m_reflector); // safe copy
     }
     return reflector;
 }
diff --git a/c2_utils/include/mfx_c2_color_aspects_wrapper.h b/c2_utils/include/mfx_c2_color_aspects_wrapper.h
index 0f28922..f115af8 100644
--- a/c2_utils/include/mfx_c2_color_aspects_wrapper.h
+++ b/c2_utils/include/mfx_c2_color_aspects_wrapper.h
@@ -33,7 +33,7 @@ public:
 
     void SetFrameworkColorAspects(const android::ColorAspects &colorAspects);
     void UpdateBitstreamColorAspects(const mfxExtVideoSignalInfo &signalInfo);
-    void GetOutputColorAspects(android::ColorAspects &outColorAspects);
+    void GetOutputColorAspects(android::ColorAspects &outColorAspects) const;
     void GetColorAspectsFromVideoSignal(const mfxExtVideoSignalInfo &signalInfo, android::ColorAspects &outColorAspects);
 
     bool IsColorAspectsChanged();
diff --git a/c2_utils/include/mfx_c2_defs.h b/c2_utils/include/mfx_c2_defs.h
index 89b7eac..48809da 100755
--- a/c2_utils/include/mfx_c2_defs.h
+++ b/c2_utils/include/mfx_c2_defs.h
@@ -21,7 +21,7 @@
 #pragma once
 
 #include <C2Component.h>
-#include "mfx_c2_params.h"
+#include <C2Config.h>
 #include "mfx_c2_param_reflector.h"
 
 #define MFX_C2_COMPONENT_STORE_NAME "MfxC2ComponentStore"
diff --git a/c2_utils/include/mfx_c2_param_storage.h b/c2_utils/include/mfx_c2_param_storage.h
index b82a28c..13e02a5 100755
--- a/c2_utils/include/mfx_c2_param_storage.h
+++ b/c2_utils/include/mfx_c2_param_storage.h
@@ -22,6 +22,7 @@
 
 #include "mfx_c2_param_reflector.h"
 
+// deprecated
 class MfxC2ParamStorage
 {
 public:
diff --git a/c2_utils/include/mfx_c2_params.h b/c2_utils/include/mfx_c2_params.h
deleted file mode 100755
index 8a8ac80..0000000
--- a/c2_utils/include/mfx_c2_params.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright (c) 2017-2021 Intel Corporation
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in all
-// copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-// SOFTWARE.
-
-#pragma once
-
-#include <C2Config.h>
-
-enum C2ParamIndexKindVendor : C2Param::type_index_t {
-
-    kParamIndexRateControl = C2Param::TYPE_INDEX_VENDOR_START,
-    kParamIndexProfile,
-    kParamIndexLevel,
-    kParamIndexFrameQP,
-    kParamIndexMemoryType,
-};
-
-// not existing tuning, Google defines bitrate as Info,
-// so define bitrate tuning here for test purpose,
-// otherwise cannot push_back it into C2Worklet::tunings
-typedef C2StreamParam<C2Tuning, C2Uint32Value, kParamIndexBitrate> C2BitrateTuning;
-constexpr char MFX_C2_PARAMKEY_BITRATE_TUNING[] = "coded.bitrate.tuning";
-
-C2ENUM(C2RateControlMethod, int32_t,
-    C2RateControlCQP,
-    C2RateControlCBR,
-    C2RateControlVBR,
-);
-
-typedef C2PortParam<C2Setting, C2SimpleValueStruct<C2RateControlMethod>, kParamIndexRateControl>::output
-    C2RateControlSetting;
-
-struct C2FrameQPStruct {
-    uint32_t qp_i;
-    uint32_t qp_p;
-    uint32_t qp_b;
-
-    DEFINE_AND_DESCRIBE_C2STRUCT(FrameQP)
-    C2FIELD(qp_i, "QPI")
-    C2FIELD(qp_p, "QPP")
-    C2FIELD(qp_b, "QPB")
-};
-
-typedef C2PortParam<C2Tuning, C2FrameQPStruct, kParamIndexFrameQP>::output C2FrameQPSetting;
-
-typedef C2PortParam<C2Tuning, C2Int32Value, kParamIndexIntraRefresh>::output C2IntraRefreshTuning;
-
-typedef C2PortParam<C2Setting, C2Uint32Value, kParamIndexProfile>::output C2ProfileSetting;
-
-typedef C2PortParam<C2Setting, C2Uint32Value, kParamIndexLevel>::output C2LevelSetting;
-
-typedef C2PortParam<C2Info, C2SimpleArrayStruct<C2ProfileLevelStruct>, kParamIndexProfileLevel> C2ProfileLevelInfo;
-
-C2ENUM(C2MemoryType, int32_t,
-    C2MemoryTypeSystem,
-    C2MemoryTypeGraphics,
-);
-
-typedef C2GlobalParam<C2Setting, C2SimpleValueStruct<C2MemoryType>, kParamIndexMemoryType> C2MemoryTypeSetting;
diff --git a/c2_utils/include/mfx_c2_setters.h b/c2_utils/include/mfx_c2_setters.h
new file mode 100644
index 0000000..f1e93b5
--- /dev/null
+++ b/c2_utils/include/mfx_c2_setters.h
@@ -0,0 +1,76 @@
+// Copyright (c) 2018-2021 Intel Corporation
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#pragma once
+
+#include <C2Config.h>
+#include "util/C2InterfaceHelper.h"
+
+using namespace android;
+
+template<typename T>
+using C2P = C2InterfaceHelper::Param<T>;
+
+template<typename T, typename ...Args>
+std::shared_ptr<T> AllocSharedString(const Args(&... args), const char *str) {
+    size_t len = strlen(str) + 1;
+    std::shared_ptr<T> ret = T::AllocShared(len, args...);
+    strcpy(ret->m.value, str);
+    return ret;
+}
+
+template<typename T, typename ...Args>
+std::shared_ptr<T> AllocSharedString(const Args(&... args), const std::string &str) {
+    std::shared_ptr<T> ret = T::AllocShared(str.length() + 1, args...);
+    strcpy(ret->m.value, str.c_str());
+    return ret;
+}
+
+template <typename T>
+struct Setter {
+    typedef typename std::remove_reference<T>::type type;
+
+    static C2R NonStrictValueWithNoDeps(
+            bool mayBlock, C2InterfaceHelper::C2P<type> &me) {
+        (void)mayBlock;
+        return me.F(me.v.value).validatePossible(me.v.value);
+    }
+
+    static C2R NonStrictValuesWithNoDeps(
+            bool mayBlock, C2InterfaceHelper::C2P<type> &me) {
+        (void)mayBlock;
+        C2R res = C2R::Ok();
+        for (size_t ix = 0; ix < me.v.flexCount(); ++ix) {
+            res.plus(me.F(me.v.m.values[ix]).validatePossible(me.v.m.values[ix]));
+        }
+        return res;
+    }
+
+    static C2R StrictValueWithNoDeps(
+            bool mayBlock,
+            const C2InterfaceHelper::C2P<type> &old,
+            C2InterfaceHelper::C2P<type> &me) {
+        (void)mayBlock;
+        if (!me.F(me.v.value).supportsNow(me.v.value)) {
+            me.set().value = old.v.value;
+        }
+        return me.F(me.v.value).validatePossible(me.v.value);
+    }
+};
\ No newline at end of file
diff --git a/c2_utils/include/mfx_c2_utils.h b/c2_utils/include/mfx_c2_utils.h
index 39637bc..fca3921 100755
--- a/c2_utils/include/mfx_c2_utils.h
+++ b/c2_utils/include/mfx_c2_utils.h
@@ -110,10 +110,6 @@ void InitNV12PlaneLayout(uint32_t pitches[C2PlanarLayout::MAX_NUM_PLANES], C2Pla
 
 void InitNV12PlaneData(int32_t pitch_y, int32_t alloc_height, uint8_t* base, uint8_t** plane_data);
 
-bool C2MemoryTypeToMfxIOPattern(bool input, C2MemoryType memory_type, mfxU16* io_pattern);
-
-bool MfxIOPatternToC2MemoryType(bool input, mfxU16 io_pattern, C2MemoryType* memory_type);
-
 int MfxFourCCToGralloc(mfxU32 fourcc, bool using_video_memory = true);
 
 bool IsYUV420(const C2GraphicView &view);
@@ -124,7 +120,8 @@ bool IsI420(const C2GraphicView &view);
 
 bool IsYV12(const C2GraphicView &view);
 
-void ParseGop(const C2StreamGopTuning &gop, uint32_t &syncInterval, uint32_t &iInterval, uint32_t &maxBframes);
+void ParseGop(const std::shared_ptr<C2StreamGopTuning::output> gop, 
+    uint32_t &syncInterval, uint32_t &iInterval, uint32_t &maxBframes);
 
 inline mfxU16 av1_mfx_profile_to_native_profile(mfxU16 profile)
 {
diff --git a/c2_utils/src/mfx_c2_color_aspects_wrapper.cpp b/c2_utils/src/mfx_c2_color_aspects_wrapper.cpp
index 5320a4a..2deb315 100755
--- a/c2_utils/src/mfx_c2_color_aspects_wrapper.cpp
+++ b/c2_utils/src/mfx_c2_color_aspects_wrapper.cpp
@@ -110,7 +110,7 @@ void MfxC2ColorAspectsWrapper::UpdateBitstreamColorAspects(const mfxExtVideoSign
     MFX_DEBUG_TRACE_I32(m_bitstreamColorAspects.mMatrixCoeffs);
 }
 
-void MfxC2ColorAspectsWrapper::GetOutputColorAspects(android::ColorAspects &outColorAspects)
+void MfxC2ColorAspectsWrapper::GetOutputColorAspects(android::ColorAspects &outColorAspects) const
 {
     MFX_DEBUG_TRACE_FUNC;
 
diff --git a/c2_utils/src/mfx_c2_defs.cpp b/c2_utils/src/mfx_c2_defs.cpp
index b665f33..7f0fdbf 100755
--- a/c2_utils/src/mfx_c2_defs.cpp
+++ b/c2_utils/src/mfx_c2_defs.cpp
@@ -20,7 +20,6 @@
 
 #include "mfx_defs.h"
 #include "mfx_c2_defs.h"
-#include "mfx_c2_params.h"
 
 using namespace android;
 
diff --git a/c2_utils/src/mfx_c2_params.cpp b/c2_utils/src/mfx_c2_params.cpp
deleted file mode 100755
index ad273ea..0000000
--- a/c2_utils/src/mfx_c2_params.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright (c) 2017-2021 Intel Corporation
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in all
-// copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-// SOFTWARE.
-
-// The sole purpose of this cpp file is to define global reflection parameters
-// for vendor types.
-
-#include <C2Config.h> // Include before define __C2_GENERATE_GLOBAL_VARS__
-// to avoid generation of global reflection variables _FIELD_LIST
-// for C2 standard structures. Those variables should be used from vndk.
-
-#define __C2_GENERATE_GLOBAL_VARS__ // Define before mfx_c2_params.h
-// to generate global reflection variables for vendor types.
-
-#include "mfx_c2_params.h"
diff --git a/c2_utils/src/mfx_c2_utils.cpp b/c2_utils/src/mfx_c2_utils.cpp
index 79d739c..0745648 100755
--- a/c2_utils/src/mfx_c2_utils.cpp
+++ b/c2_utils/src/mfx_c2_utils.cpp
@@ -340,9 +340,11 @@ std::unique_ptr<C2SettingResult> FindC2Param(
 
 static const std::pair<C2Config::profile_t, mfxU16> g_h264_profiles[] =
 {
-    { PROFILE_AVC_BASELINE, MFX_PROFILE_AVC_CONSTRAINED_BASELINE },
+    { PROFILE_AVC_BASELINE, MFX_PROFILE_AVC_BASELINE },
+    { PROFILE_AVC_CONSTRAINED_BASELINE, MFX_PROFILE_AVC_CONSTRAINED_BASELINE },
     { PROFILE_AVC_MAIN, MFX_PROFILE_AVC_MAIN },
-    { PROFILE_AVC_EXTENDED, MFX_PROFILE_AVC_EXTENDED },
+    { PROFILE_AVC_CONSTRAINED_HIGH, MFX_PROFILE_AVC_CONSTRAINED_HIGH },
+    { PROFILE_AVC_PROGRESSIVE_HIGH, MFX_PROFILE_AVC_PROGRESSIVE_HIGH },
     { PROFILE_AVC_HIGH, MFX_PROFILE_AVC_HIGH }
     /* PROFILE_AVC_HIGH_10, PROFILE_AVC_HIGH_422, PROFILE_AVC_HIGH_444
     are not supported */
@@ -371,7 +373,9 @@ static const std::pair<C2Config::level_t, mfxU16> g_h264_levels[] =
 static const std::pair<C2Config::profile_t, mfxU16> g_h265_profiles[] =
 {
     { PROFILE_HEVC_MAIN,  MFX_PROFILE_HEVC_MAIN },
+    { PROFILE_HEVC_MAIN_STILL, MFX_PROFILE_HEVC_MAINSP },
     { PROFILE_HEVC_MAIN_10, MFX_PROFILE_HEVC_MAIN10 }
+
     /* PROFILE_HEVC_MAINSP, PROFILE_HEVC_REXT, PROFILE_HEVC_SCC
     are not supported */
 };
@@ -500,30 +504,6 @@ void InitNV12PlaneLayout(uint32_t pitches[C2PlanarLayout::MAX_NUM_PLANES], C2Pla
     }
 }
 
-static const std::pair<C2MemoryType, mfxU16> g_input_memory_types[] =
-{
-    { C2MemoryTypeSystem, MFX_IOPATTERN_IN_SYSTEM_MEMORY },
-    { C2MemoryTypeGraphics, MFX_IOPATTERN_IN_VIDEO_MEMORY }
-};
-
-static const std::pair<C2MemoryType, mfxU16> g_output_memory_types[] =
-{
-    { C2MemoryTypeSystem, MFX_IOPATTERN_OUT_SYSTEM_MEMORY },
-    { C2MemoryTypeGraphics, MFX_IOPATTERN_OUT_VIDEO_MEMORY }
-};
-
-bool C2MemoryTypeToMfxIOPattern(bool input, C2MemoryType memory_type, mfxU16* io_pattern)
-{
-    return FirstToSecond(input ? g_input_memory_types : g_output_memory_types,
-        memory_type, io_pattern);
-}
-
-bool MfxIOPatternToC2MemoryType(bool input, mfxU16 io_pattern, C2MemoryType* memory_type)
-{
-    return SecondToFirst(input ? g_input_memory_types : g_output_memory_types,
-        io_pattern, memory_type);
-}
-
 int MfxFourCCToGralloc(mfxU32 fourcc, bool using_video_memory)
 {
     MFX_DEBUG_TRACE_FUNC;
@@ -786,12 +766,12 @@ bool IsYV12(const C2GraphicView &view) {
 }
 
 void ParseGop(
-        const C2StreamGopTuning &gop,
+        const std::shared_ptr<C2StreamGopTuning::output> gop,
         uint32_t &syncInterval, uint32_t &iInterval, uint32_t &maxBframes) {
     uint32_t syncInt = 1;
     uint32_t iInt = 1;
-    for (size_t i = 0; i < gop.flexCount(); ++i) {
-        const C2GopLayerStruct &layer = gop.m.values[i];
+    for (size_t i = 0; i < gop->flexCount(); ++i) {
+        const C2GopLayerStruct &layer = gop->m.values[i];
         if (layer.count == UINT32_MAX) {
             syncInt = 0;
         } else if (syncInt <= UINT32_MAX / (layer.count + 1)) {
-- 
2.38.1

