From a36cfa926db00e8feb19b5f7866428059a42e006 Mon Sep 17 00:00:00 2001
From: "Suresh, Prashanth" <prashanth.suresh@intel.com>
Date: Thu, 9 Jun 2022 20:33:46 +0530
Subject: [PATCH] Remove QEMU patches which are not required.

Tracked-On: OAM-102390
Signed-off-by: Suresh, Prashanth <prashanth.suresh@intel.com>
---
 ...r-to-select-monitor-to-show-qemu-in-.patch |  106 -
 ...o-gpu-virtio-gpu-enablement-baseline.patch | 2616 -----------------
 ...reate-a-common-release_dmabuf-helper.patch |   90 -
 ...helpers-to-help-with-synchronization.patch |   82 -
 ...nc-objects-and-fences-only-for-blobs.patch |  230 --
 ...for-the-draw-signal-for-dmabuf-blobs.patch |   71 -
 ...0-virtio-gpu-Add-gl_flushed-callback.patch |   79 -
 ...extra-draw-of-same-guest-scanout-blo.patch |  135 -
 ...b-and-re-tab-should-destory-egl-surf.patch |   53 -
 ...sure-the-right-context-is-the-curren.patch |   48 -
 ...vent-returns-FALSE-when-no-cairo-sur.patch |   31 -
 ...-fb-texture-needs-to-be-regenerated-.patch |   33 -
 ...d-Added-support-for-4k-60-Hz-monitor.patch |   34 -
 ...ting-one-extended-mode-guest-fb-into.patch |  160 -
 ...ing-partial-guest-fb-to-the-proper-s.patch |   63 -
 .../qemu/0019-ui-Add-in-clipboard-infra.patch |  634 ----
 ...l-option-for-making-all-VCs-detached.patch |   66 -
 ...-detached-window-s-size-and-location.patch |   48 -
 ...tatus-bar-for-expressing-ups-and-fps.patch |  200 --
 ...d_gl_frame_counter-at-every-draw-swa.patch |   49 -
 ...dpy_gl_frame_counter-at-every-guest-.patch |   38 -
 ...rtio-gpu-Fix-memory-leak-CID-1453811.patch |   78 -
 ...tio-gpu-no-point-of-checking-res-iov.patch |   30 -
 ...f-scanout-only-when-scanout_mode-is-.patch |   88 -
 ...w_gl_flushed-after-closing-dmabuf-fe.patch |   41 -
 ...evert-full-screen-on.-optional-param.patch |  102 -
 ...-monitor-to-specify-target-monitor-f.patch |   98 -
 ...ape-or-portrait-mode-display-dynamic.patch |  236 --
 28 files changed, 5539 deletions(-)
 delete mode 100644 host/qemu/0004-ui-gtk-Allow-user-to-select-monitor-to-show-qemu-in-.patch
 delete mode 100644 host/qemu/0005-virtio-gpu-virtio-gpu-enablement-baseline.patch
 delete mode 100644 host/qemu/0006-ui-gtk-Create-a-common-release_dmabuf-helper.patch
 delete mode 100644 host/qemu/0007-ui-egl-Add-egl-helpers-to-help-with-synchronization.patch
 delete mode 100644 host/qemu/0008-ui-Create-sync-objects-and-fences-only-for-blobs.patch
 delete mode 100644 host/qemu/0009-ui-gtk-egl-Wait-for-the-draw-signal-for-dmabuf-blobs.patch
 delete mode 100644 host/qemu/0010-virtio-gpu-Add-gl_flushed-callback.patch
 delete mode 100644 host/qemu/0011-ui-gtk-skip-any-extra-draw-of-same-guest-scanout-blo.patch
 delete mode 100644 host/qemu/0012-ui-gtk-egl-un-tab-and-re-tab-should-destory-egl-surf.patch
 delete mode 100644 host/qemu/0013-ui-gtk-egl-make-sure-the-right-context-is-the-curren.patch
 delete mode 100644 host/qemu/0014-ui-gtk-gd_draw_event-returns-FALSE-when-no-cairo-sur.patch
 delete mode 100644 host/qemu/0015-ui-gtk-egl-guest-fb-texture-needs-to-be-regenerated-.patch
 delete mode 100644 host/qemu/0016-edid-Added-support-for-4k-60-Hz-monitor.patch
 delete mode 100644 host/qemu/0017-virtio-gpu-splitting-one-extended-mode-guest-fb-into.patch
 delete mode 100644 host/qemu/0018-ui-gtk-egl-blitting-partial-guest-fb-to-the-proper-s.patch
 delete mode 100644 host/qemu/0019-ui-Add-in-clipboard-infra.patch
 delete mode 100644 host/qemu/0020-ui-gtk-detach_all-option-for-making-all-VCs-detached.patch
 delete mode 100644 host/qemu/0021-ui-gtk-specify-detached-window-s-size-and-location.patch
 delete mode 100644 host/qemu/0022-ui-gtk-adds-status-bar-for-expressing-ups-and-fps.patch
 delete mode 100644 host/qemu/0023-ui-gtk-calling-gd_gl_frame_counter-at-every-draw-swa.patch
 delete mode 100644 host/qemu/0024-virtio-gpu-call-dpy_gl_frame_counter-at-every-guest-.patch
 delete mode 100644 host/qemu/0025-hw-display-virtio-gpu-Fix-memory-leak-CID-1453811.patch
 delete mode 100644 host/qemu/0026-virtio-gpu-no-point-of-checking-res-iov.patch
 delete mode 100644 host/qemu/0027-ui-gtk-egl-dmabuf-scanout-only-when-scanout_mode-is-.patch
 delete mode 100644 host/qemu/0028-ui-gtk-graphic_hw_gl_flushed-after-closing-dmabuf-fe.patch
 delete mode 100644 host/qemu/0029-ui-gtk-revert-full-screen-on.-optional-param.patch
 delete mode 100644 host/qemu/0030-ui-gtk-new-param-monitor-to-specify-target-monitor-f.patch
 delete mode 100644 host/qemu/0032-Adapt-APP-landscape-or-portrait-mode-display-dynamic.patch

diff --git a/host/qemu/0004-ui-gtk-Allow-user-to-select-monitor-to-show-qemu-in-.patch b/host/qemu/0004-ui-gtk-Allow-user-to-select-monitor-to-show-qemu-in-.patch
deleted file mode 100644
index 39ba987..0000000
--- a/host/qemu/0004-ui-gtk-Allow-user-to-select-monitor-to-show-qemu-in-.patch
+++ /dev/null
@@ -1,106 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: sweeaun <swee.aun.khor@intel.com>
-Date: Thu, 27 May 2021 11:09:47 +0800
-Subject: [PATCH] ui/gtk: Allow user to select monitor to show qemu in full
- screen through new gtk display options
-
--display gtk,monitor-num=<value>
-
-Signed-off-by: sweeaun <swee.aun.khor@intel.com>
----
- qapi/ui.json    |  9 ++++++---
- qemu-options.hx |  2 +-
- ui/gtk.c        | 32 ++++++++++++++++++++++++++++++++
- 3 files changed, 39 insertions(+), 4 deletions(-)
-
-diff --git a/qapi/ui.json b/qapi/ui.json
-index 1052ca9c38..398d1774ac 100644
---- a/qapi/ui.json
-+++ b/qapi/ui.json
-@@ -1035,14 +1035,17 @@
- #               assuming the guest will resize the display to match
- #               the window size then.  Otherwise it defaults to "off".
- #               Since 3.1
--#
-+# @full-screen-on-monitor: Monitor number to display QEMU in full screen.
-+#                          Monitor number started from index 1. If total number
-+#                          of monitors is 3, possible values for this option are
-+#                          1, 2 or 3.
- # Since: 2.12
- #
- ##
- { 'struct'  : 'DisplayGTK',
-   'data'    : { '*grab-on-hover' : 'bool',
--                '*zoom-to-fit'   : 'bool'  } }
--
-+                '*zoom-to-fit'   : 'bool',
-+		'*full-screen-on-monitor' : 'int' } }
- ##
- # @DisplayEGLHeadless:
- #
-diff --git a/qemu-options.hx b/qemu-options.hx
-index fd21002bd6..d0bb48c728 100644
---- a/qemu-options.hx
-+++ b/qemu-options.hx
-@@ -1775,7 +1775,7 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
-     "            [,window_close=on|off][,gl=on|core|es|off]\n"
- #endif
- #if defined(CONFIG_GTK)
--    "-display gtk[,grab_on_hover=on|off][,gl=on|off]|\n"
-+    "-display gtk[,grab-on-hover=on|off][,gl=on|off][,full-screen-on-monitor=<value>]\n"
- #endif
- #if defined(CONFIG_VNC)
-     "-display vnc=<display>[,<optargs>]\n"
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 1ea1253528..77353a620d 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -2244,6 +2244,8 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     GdkDisplay *window_display;
-     GtkIconTheme *theme;
-     char *dir;
-+    int monitor_n;
-+    bool monitor_status = false;
- 
-     if (!gtkinit) {
-         fprintf(stderr, "gtk initialization failed\n");
-@@ -2322,6 +2324,36 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-         opts->u.gtk.grab_on_hover) {
-         gtk_menu_item_activate(GTK_MENU_ITEM(s->grab_on_hover_item));
-     }
-+
-+     if (opts->u.gtk.has_full_screen_on_monitor) {
-+        monitor_n = gdk_display_get_n_monitors(window_display);
-+
-+        if (opts->u.gtk.full_screen_on_monitor <= monitor_n &&
-+            opts->u.gtk.full_screen_on_monitor > 0) {
-+            gtk_window_fullscreen_on_monitor(GTK_WINDOW(s->window),
-+                gdk_display_get_default_screen(window_display),
-+                opts->u.gtk.full_screen_on_monitor - 1);
-+
-+            if (gdk_display_get_monitor(window_display,
-+                                        opts->u.gtk.full_screen_on_monitor
-+                                        - 1) != NULL) {
-+                monitor_status = true;
-+            }
-+        }
-+        if (monitor_status == false) {
-+            /*
-+             * Calling GDK API to read the number of monitors again in case
-+             * monitor added or removed since last read.
-+             */
-+            monitor_n = gdk_display_get_n_monitors(window_display);
-+            warn_report("Failed to enable full screen on monitor %" PRId64 ". "
-+                        "Current total number of monitors is %d, "
-+                        "please verify full-screen-on-monitor option value.",
-+                        opts->u.gtk.full_screen_on_monitor, monitor_n);
-+        }
-+    }
-+
-+
- }
- 
- static void early_gtk_display_init(DisplayOptions *opts)
--- 
-2.17.1
-
diff --git a/host/qemu/0005-virtio-gpu-virtio-gpu-enablement-baseline.patch b/host/qemu/0005-virtio-gpu-virtio-gpu-enablement-baseline.patch
deleted file mode 100644
index 11e681b..0000000
--- a/host/qemu/0005-virtio-gpu-virtio-gpu-enablement-baseline.patch
+++ /dev/null
@@ -1,2616 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Gerd Hoffmann <kraxel@redhat.com>
-Date: Thu, 6 May 2021 11:10:01 +0200
-Subject: [PATCH] virtio-gpu: virtio-gpu enablement baseline
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Mazlan, Hazwan Arif <hazwan.arif.mazlan@intel.com>
-
-virtio-gpu: handle partial maps properly
-
-dma_memory_map() may map only a part of the request.  Happens if the
-request can't be mapped in one go, for example due to a iommu creating
-a linear dma mapping for scattered physical pages.  Should that be the
-case virtio-gpu must call dma_memory_map() again with the remaining
-range instead of simply throwing an error.
-
-Note that this change implies the number of iov entries may differ from
-the number of mapping entries sent by the guest.  Therefore the iov_len
-bookkeeping needs some updates too, we have to explicitly pass around
-the iov length now.
-
-Reported-by: Auger Eric <eric.auger@redhat.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210506091001.1301250-1-kraxel@redhat.com
-Reviewed-by: Eric Auger <eric.auger@redhat.com>
-Tested-by: Eric Auger <eric.auger@redhat.com>
-Message-Id: <20210506091001.1301250-1-kraxel@redhat.com>
-
-virtio-gpu: rename virgl source file.
-
-"3d" -> "virgl" as 3d is a rather broad term.
-Hopefully a bit less confusing.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-2-kraxel@redhat.com>
-
-virtio-gpu: add virtio-gpu-gl-device
-
-Just a skeleton for starters, following patches will add more code.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-3-kraxel@redhat.com>
-
-virtio-gpu: move virgl realize + properties
-
-Move device init (realize) and properties.
-
-Drop the virgl property, the virtio-gpu-gl-device has virgl enabled no
-matter what.  Just use virtio-gpu-device instead if you don't want
-enable virgl and opengl.  This simplifies the logic and reduces the test
-matrix.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-4-kraxel@redhat.com>
-
-virtio-gpu: move virgl reset
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-5-kraxel@redhat.com>
-
-virtio-gpu: use class function for ctrl queue handlers
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-6-kraxel@redhat.com>
-
-virtio-gpu: move virgl handle_ctrl
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-7-kraxel@redhat.com>
-
-virtio-gpu: move virgl gl_flushed
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-8-kraxel@redhat.com>
-
-virtio-gpu: move virgl process_cmd
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-9-kraxel@redhat.com>
-
-virtio-gpu: move update_cursor_data
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-10-kraxel@redhat.com>
-
-virtio-gpu: drop VIRGL() macro
-
-Drops last virgl/opengl dependency from virtio-gpu-device.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-11-kraxel@redhat.com>
-
-virtio-gpu: move virtio-gpu-gl-device to separate module
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-12-kraxel@redhat.com>
-
-virtio-gpu: drop use_virgl_renderer
-
-Now that we have separated the gl and non-gl code flows to two different
-devices there is little reason turn on and off virglrenderer usage at
-runtime.  The gl code can simply use virglrenderer unconditionally.
-
-So drop use_virgl_renderer field and just do that.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-13-kraxel@redhat.com>
-
-virtio-gpu: move fields to struct VirtIOGPUGL
-
-Move two virglrenderer state variables to struct VirtIOGPUGL.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-14-kraxel@redhat.com>
-
-virtio-gpu: add virtio-gpu-gl-pci
-
-Add pci proxy for virtio-gpu-gl-device.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-15-kraxel@redhat.com>
-
-modules: add have_vga
-
-Introduce a symbol which can be used to prevent display modules which
-need vga support being loaded into system emulators with CONFIG_VGA=n.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-16-kraxel@redhat.com>
-
-virtio-gpu: add virtio-vga-gl
-
-Add pci proxy for virtio-gpu-gl-device, with vga compatibility.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Message-id: 20210430113547.1816178-1-kraxel@redhat.com
-Message-Id: <20210430113547.1816178-17-kraxel@redhat.com>
-
-ui/gtk: move struct GtkDisplayState to ui/gtk.h
-
-Want place gtk clipboard code in a separate C file, which in turn
-requires GtkDisplayState being in a header file.  So move it.  No
-functional change.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Reviewed-by: Marc-Andr√© Lureau <marcandre.lureau@redhat.com>
-Message-id: 20210519053940.1888907-1-kraxel@redhat.com
-Message-Id: <20210519053940.1888907-9-kraxel@redhat.com>
-
-ui: Get the fd associated with udmabuf driver
-
-Try to open the udmabuf dev node for the first time or return the
-fd if the device was previously opened.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-2-vivek.kasireddy@intel.com>
-
-[ kraxel: fixup fcntl.h include ]
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-headers: Add udmabuf.h
-
-This adds udmabuf header to standard headers so that the
-relevant udmabuf objects can be accessed in subsequent
-patches.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-3-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add udmabuf helpers
-
-Add helper functions to create a dmabuf for a resource and mmap it.
-Also, introduce the fields blob and blob_size so that these helpers
-can start to use them but the full picture will emerge only after
-adding create_blob API in patch 8 of this series.
-
-To be able to create a dmabuf using the udmabuf driver, Qemu needs
-to be lauched with the memfd memory backend like this:
-
-qemu-system-x86_64 -m 8192m -object memory-backend-memfd,id=mem1,size=8192M
--machine memory-backend=mem1
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-4-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-stubs: Add stubs for udmabuf helpers
-
-This is needed to ensure that virtio-gpu device works for
-non-linux builds.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-5-vivek.kasireddy@intel.com>
-
-[ kraxel: add virtio-gpu-udmabuf.c stubs only when building
-          system emulation ]
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add virtio_gpu_find_check_resource
-
-Move finding the resource and validating its backing storage into one
-function.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-6-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Refactor virtio_gpu_set_scanout
-
-Store the meta-data associated with a FB in a new object
-(struct virtio_gpu_framebuffer) and pass the object to set_scanout.
-Also move code in set_scanout into a do_set_scanout function.
-This will be helpful when adding set_scanout_blob API.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-7-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Refactor virtio_gpu_create_mapping_iov
-
-Instead of passing the attach_backing object to extract nr_entries
-and offset, explicitly pass these as arguments to this function.
-This will be helpful when adding create_blob API.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-8-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add initial definitions for blob resources
-
-Add the property bit, configuration flag and other relevant
-macros and definitions associated with this feature.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-9-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add virtio_gpu_resource_create_blob
-
-This API allows Qemu to register the blob allocated by the Guest
-as a new resource and map its backing storage.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-10-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-ui/pixman: Add qemu_pixman_to_drm_format()
-
-This new function to get the drm_format associated with a pixman
-format will be useful while creating a dmabuf.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-11-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add helpers to create and destroy dmabuf objects
-
-These helpers can be useful for creating dmabuf objects from blobs
-and submitting them to the UI.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-12-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Factor out update scanout
-
-Creating a small helper function for updating the scanout
-will be useful in the next patch where this needs to be
-done early in do_set_scanout before returning.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-13-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Add virtio_gpu_set_scanout_blob
-
-This API allows Qemu to set the blob allocated by the Guest as
-the scanout buffer. If Opengl support is available, then the
-scanout buffer would be submitted as a dmabuf to the UI; if not,
-a pixman image is created from the scanout buffer and is
-submitted to the UI via the display surface.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-14-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: Update cursor data using blob
-
-If a blob is available for the cursor, copy the data from the blob.
-
-Based-on-patch-by: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Message-Id: <20210526231429.1045476-15-vivek.kasireddy@intel.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-virtio-gpu: move scanout_id sanity check
-
-Checking scanout_id in virtio_gpu_do_set_scanout() is too late, for the
-"resource_id == 0" case (aka disable scanout) the scanout_id is used
-unchecked.  Move the check into the callers to fix that.
-
-Fixes: e64d4b6a9bc3 ("virtio-gpu: Refactor virtio_gpu_set_scanout")
-Fixes: 32db3c63ae11 ("virtio-gpu: Add virtio_gpu_set_scanout_blob")
-Resolves: https://gitlab.com/qemu-project/qemu/-/issues/383
-Reported-by: Alexander Bulekov <alxndr@bu.edu>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Reviewed-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Reviewed-by: Li Qiang <liq3ea@gmail.com>
-Message-Id: <20210604075029.1201478-1-kraxel@redhat.com>
----
- hw/display/meson.build                        |  20 +-
- hw/display/trace-events                       |   2 +
- hw/display/vga.c                              |   2 +
- hw/display/virtio-gpu-base.c                  |   9 +-
- hw/display/virtio-gpu-gl.c                    | 163 +++++
- hw/display/virtio-gpu-pci-gl.c                |  55 ++
- hw/display/virtio-gpu-udmabuf.c               | 223 ++++++
- .../{virtio-gpu-3d.c => virtio-gpu-virgl.c}   |   8 +-
- hw/display/virtio-gpu.c                       | 637 +++++++++++-------
- hw/display/virtio-vga-gl.c                    |  47 ++
- include/hw/display/vga.h                      |   6 +
- include/hw/virtio/virtio-gpu-bswap.h          |  16 +
- include/hw/virtio/virtio-gpu.h                |  73 +-
- include/standard-headers/linux/udmabuf.h      |  32 +
- include/ui/console.h                          |   3 +
- include/ui/gtk.h                              |  57 ++
- include/ui/qemu-pixman.h                      |   1 +
- meson.build                                   |   2 +-
- scripts/update-linux-headers.sh               |   3 +
- stubs/meson.build                             |   1 +
- stubs/virtio-gpu-udmabuf.c                    |  27 +
- ui/gtk.c                                      |  55 --
- ui/meson.build                                |   1 +
- ui/qemu-pixman.c                              |  35 +-
- ui/udmabuf.c                                  |  40 ++
- util/module.c                                 |   7 +
- 26 files changed, 1203 insertions(+), 322 deletions(-)
- create mode 100644 hw/display/virtio-gpu-gl.c
- create mode 100644 hw/display/virtio-gpu-pci-gl.c
- create mode 100644 hw/display/virtio-gpu-udmabuf.c
- rename hw/display/{virtio-gpu-3d.c => virtio-gpu-virgl.c} (98%)
- create mode 100644 hw/display/virtio-vga-gl.c
- create mode 100644 include/standard-headers/linux/udmabuf.h
- create mode 100644 stubs/virtio-gpu-udmabuf.c
- create mode 100644 ui/udmabuf.c
-
-diff --git a/hw/display/meson.build b/hw/display/meson.build
-index 9d79e3951d..9e0060acd4 100644
---- a/hw/display/meson.build
-+++ b/hw/display/meson.build
-@@ -56,11 +56,15 @@ softmmu_ss.add(when: [pixman, 'CONFIG_ATI_VGA'], if_true: files('ati.c', 'ati_2d
- if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
-   virtio_gpu_ss = ss.source_set()
-   virtio_gpu_ss.add(when: 'CONFIG_VIRTIO_GPU',
--                    if_true: [files('virtio-gpu-base.c', 'virtio-gpu.c'), pixman, virgl])
--  virtio_gpu_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRGL'],
--                    if_true: [files('virtio-gpu-3d.c'), pixman, virgl])
-+                    if_true: [files('virtio-gpu-base.c', 'virtio-gpu.c'), pixman])
-+  virtio_gpu_ss.add(when: 'CONFIG_LINUX', if_true: files('virtio-gpu-udmabuf.c'))
-   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
-   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
-+
-+  virtio_gpu_gl_ss = ss.source_set()
-+  virtio_gpu_gl_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRGL', opengl],
-+                       if_true: [files('virtio-gpu-gl.c', 'virtio-gpu-virgl.c'), pixman, virgl])
-+  hw_display_modules += {'virtio-gpu-gl': virtio_gpu_gl_ss}
- endif
- 
- if config_all_devices.has_key('CONFIG_VIRTIO_PCI')
-@@ -70,6 +74,11 @@ if config_all_devices.has_key('CONFIG_VIRTIO_PCI')
-   virtio_gpu_pci_ss.add(when: ['CONFIG_VHOST_USER_GPU', 'CONFIG_VIRTIO_PCI'],
-                         if_true: files('vhost-user-gpu-pci.c'))
-   hw_display_modules += {'virtio-gpu-pci': virtio_gpu_pci_ss}
-+
-+  virtio_gpu_pci_gl_ss = ss.source_set()
-+  virtio_gpu_pci_gl_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRTIO_PCI', 'CONFIG_VIRGL', opengl],
-+                           if_true: [files('virtio-gpu-pci-gl.c'), pixman])
-+  hw_display_modules += {'virtio-gpu-pci-gl': virtio_gpu_pci_gl_ss}
- endif
- 
- if config_all_devices.has_key('CONFIG_VIRTIO_VGA')
-@@ -79,6 +88,11 @@ if config_all_devices.has_key('CONFIG_VIRTIO_VGA')
-   virtio_vga_ss.add(when: 'CONFIG_VHOST_USER_VGA',
-                     if_true: files('vhost-user-vga.c'))
-   hw_display_modules += {'virtio-vga': virtio_vga_ss}
-+
-+  virtio_vga_gl_ss = ss.source_set()
-+  virtio_vga_gl_ss.add(when: ['CONFIG_VIRTIO_VGA', 'CONFIG_VIRGL', opengl],
-+                       if_true: [files('virtio-vga-gl.c'), pixman])
-+  hw_display_modules += {'virtio-vga-gl': virtio_vga_gl_ss}
- endif
- 
- specific_ss.add(when: [x11, opengl, 'CONFIG_MILKYMIST_TMU2'], if_true: files('milkymist-tmu2.c'))
-diff --git a/hw/display/trace-events b/hw/display/trace-events
-index 957b8ba994..96fe1ea3de 100644
---- a/hw/display/trace-events
-+++ b/hw/display/trace-events
-@@ -40,8 +40,10 @@ virtio_gpu_features(bool virgl) "virgl %d"
- virtio_gpu_cmd_get_display_info(void) ""
- virtio_gpu_cmd_get_edid(uint32_t scanout) "scanout %d"
- virtio_gpu_cmd_set_scanout(uint32_t id, uint32_t res, uint32_t w, uint32_t h, uint32_t x, uint32_t y) "id %d, res 0x%x, w %d, h %d, x %d, y %d"
-+virtio_gpu_cmd_set_scanout_blob(uint32_t id, uint32_t res, uint32_t w, uint32_t h, uint32_t x, uint32_t y) "id %d, res 0x%x, w %d, h %d, x %d, y %d"
- virtio_gpu_cmd_res_create_2d(uint32_t res, uint32_t fmt, uint32_t w, uint32_t h) "res 0x%x, fmt 0x%x, w %d, h %d"
- virtio_gpu_cmd_res_create_3d(uint32_t res, uint32_t fmt, uint32_t w, uint32_t h, uint32_t d) "res 0x%x, fmt 0x%x, w %d, h %d, d %d"
-+virtio_gpu_cmd_res_create_blob(uint32_t res, uint64_t size) "res 0x%x, size %" PRId64
- virtio_gpu_cmd_res_unref(uint32_t res) "res 0x%x"
- virtio_gpu_cmd_res_back_attach(uint32_t res) "res 0x%x"
- virtio_gpu_cmd_res_back_detach(uint32_t res) "res 0x%x"
-diff --git a/hw/display/vga.c b/hw/display/vga.c
-index 836ad50c7b..28a90e30d0 100644
---- a/hw/display/vga.c
-+++ b/hw/display/vga.c
-@@ -39,6 +39,8 @@
- //#define DEBUG_VGA_MEM
- //#define DEBUG_VGA_REG
- 
-+bool have_vga = true;
-+
- /* 16 state changes per vertical frame @60 Hz */
- #define VGA_TEXT_CURSOR_PERIOD_MS       (1000 * 2 * 16 / 60)
- 
-diff --git a/hw/display/virtio-gpu-base.c b/hw/display/virtio-gpu-base.c
-index 25f8920fdb..dd294276cb 100644
---- a/hw/display/virtio-gpu-base.c
-+++ b/hw/display/virtio-gpu-base.c
-@@ -25,7 +25,6 @@ virtio_gpu_base_reset(VirtIOGPUBase *g)
-     int i;
- 
-     g->enable = 0;
--    g->use_virgl_renderer = false;
- 
-     for (i = 0; i < g->conf.max_outputs; i++) {
-         g->scanout[i].resource_id = 0;
-@@ -162,7 +161,6 @@ virtio_gpu_base_device_realize(DeviceState *qdev,
-         return false;
-     }
- 
--    g->use_virgl_renderer = false;
-     if (virtio_gpu_virgl_enabled(g->conf)) {
-         error_setg(&g->migration_blocker, "virgl is not yet migratable");
-         if (migrate_add_blocker(g->migration_blocker, errp) < 0) {
-@@ -210,6 +208,9 @@ virtio_gpu_base_get_features(VirtIODevice *vdev, uint64_t features,
-     if (virtio_gpu_edid_enabled(g->conf)) {
-         features |= (1 << VIRTIO_GPU_F_EDID);
-     }
-+    if (virtio_gpu_blob_enabled(g->conf)) {
-+        features |= (1 << VIRTIO_GPU_F_RESOURCE_BLOB);
-+    }
- 
-     return features;
- }
-@@ -218,10 +219,8 @@ static void
- virtio_gpu_base_set_features(VirtIODevice *vdev, uint64_t features)
- {
-     static const uint32_t virgl = (1 << VIRTIO_GPU_F_VIRGL);
--    VirtIOGPUBase *g = VIRTIO_GPU_BASE(vdev);
- 
--    g->use_virgl_renderer = ((features & virgl) == virgl);
--    trace_virtio_gpu_features(g->use_virgl_renderer);
-+    trace_virtio_gpu_features(((features & virgl) == virgl));
- }
- 
- static void
-diff --git a/hw/display/virtio-gpu-gl.c b/hw/display/virtio-gpu-gl.c
-new file mode 100644
-index 0000000000..d971b48080
---- /dev/null
-+++ b/hw/display/virtio-gpu-gl.c
-@@ -0,0 +1,163 @@
-+/*
-+ * Virtio GPU Device
-+ *
-+ * Copyright Red Hat, Inc. 2013-2014
-+ *
-+ * Authors:
-+ *     Dave Airlie <airlied@redhat.com>
-+ *     Gerd Hoffmann <kraxel@redhat.com>
-+ *
-+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
-+ * See the COPYING file in the top-level directory.
-+ */
-+
-+#include "qemu/osdep.h"
-+#include "qemu/iov.h"
-+#include "qemu/module.h"
-+#include "qemu/error-report.h"
-+#include "qapi/error.h"
-+#include "sysemu/sysemu.h"
-+#include "hw/virtio/virtio.h"
-+#include "hw/virtio/virtio-gpu.h"
-+#include "hw/virtio/virtio-gpu-bswap.h"
-+#include "hw/virtio/virtio-gpu-pixman.h"
-+#include "hw/qdev-properties.h"
-+
-+#include <virglrenderer.h>
-+
-+static void virtio_gpu_gl_update_cursor_data(VirtIOGPU *g,
-+                                             struct virtio_gpu_scanout *s,
-+                                             uint32_t resource_id)
-+{
-+    uint32_t width, height;
-+    uint32_t pixels, *data;
-+
-+    data = virgl_renderer_get_cursor_data(resource_id, &width, &height);
-+    if (!data) {
-+        return;
-+    }
-+
-+    if (width != s->current_cursor->width ||
-+        height != s->current_cursor->height) {
-+        free(data);
-+        return;
-+    }
-+
-+    pixels = s->current_cursor->width * s->current_cursor->height;
-+    memcpy(s->current_cursor->data, data, pixels * sizeof(uint32_t));
-+    free(data);
-+}
-+
-+static void virtio_gpu_gl_flushed(VirtIOGPUBase *b)
-+{
-+    VirtIOGPU *g = VIRTIO_GPU(b);
-+    VirtIOGPUGL *gl = VIRTIO_GPU_GL(b);
-+
-+    if (gl->renderer_reset) {
-+        gl->renderer_reset = false;
-+        virtio_gpu_virgl_reset(g);
-+    }
-+    virtio_gpu_process_cmdq(g);
-+}
-+
-+static void virtio_gpu_gl_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
-+{
-+    VirtIOGPU *g = VIRTIO_GPU(vdev);
-+    VirtIOGPUGL *gl = VIRTIO_GPU_GL(vdev);
-+    struct virtio_gpu_ctrl_command *cmd;
-+
-+    if (!virtio_queue_ready(vq)) {
-+        return;
-+    }
-+
-+    if (!gl->renderer_inited) {
-+        virtio_gpu_virgl_init(g);
-+        gl->renderer_inited = true;
-+    }
-+
-+    cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command));
-+    while (cmd) {
-+        cmd->vq = vq;
-+        cmd->error = 0;
-+        cmd->finished = false;
-+        QTAILQ_INSERT_TAIL(&g->cmdq, cmd, next);
-+        cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command));
-+    }
-+
-+    virtio_gpu_process_cmdq(g);
-+    virtio_gpu_virgl_fence_poll(g);
-+}
-+
-+static void virtio_gpu_gl_reset(VirtIODevice *vdev)
-+{
-+    VirtIOGPU *g = VIRTIO_GPU(vdev);
-+    VirtIOGPUGL *gl = VIRTIO_GPU_GL(vdev);
-+
-+    virtio_gpu_reset(vdev);
-+
-+    if (gl->renderer_inited) {
-+        if (g->parent_obj.renderer_blocked) {
-+            gl->renderer_reset = true;
-+        } else {
-+            virtio_gpu_virgl_reset(g);
-+        }
-+    }
-+}
-+
-+static void virtio_gpu_gl_device_realize(DeviceState *qdev, Error **errp)
-+{
-+    VirtIOGPU *g = VIRTIO_GPU(qdev);
-+
-+#if defined(HOST_WORDS_BIGENDIAN)
-+    error_setg(errp, "virgl is not supported on bigendian platforms");
-+    return;
-+#endif
-+
-+    if (!display_opengl) {
-+        error_setg(errp, "opengl is not available");
-+        return;
-+    }
-+
-+    g->parent_obj.conf.flags |= (1 << VIRTIO_GPU_FLAG_VIRGL_ENABLED);
-+    VIRTIO_GPU_BASE(g)->virtio_config.num_capsets =
-+        virtio_gpu_virgl_get_num_capsets(g);
-+
-+    virtio_gpu_device_realize(qdev, errp);
-+}
-+
-+static Property virtio_gpu_gl_properties[] = {
-+    DEFINE_PROP_BIT("stats", VirtIOGPU, parent_obj.conf.flags,
-+                    VIRTIO_GPU_FLAG_STATS_ENABLED, false),
-+    DEFINE_PROP_END_OF_LIST(),
-+};
-+
-+static void virtio_gpu_gl_class_init(ObjectClass *klass, void *data)
-+{
-+    DeviceClass *dc = DEVICE_CLASS(klass);
-+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
-+    VirtIOGPUBaseClass *vbc = VIRTIO_GPU_BASE_CLASS(klass);
-+    VirtIOGPUClass *vgc = VIRTIO_GPU_CLASS(klass);
-+
-+    vbc->gl_flushed = virtio_gpu_gl_flushed;
-+    vgc->handle_ctrl = virtio_gpu_gl_handle_ctrl;
-+    vgc->process_cmd = virtio_gpu_virgl_process_cmd;
-+    vgc->update_cursor_data = virtio_gpu_gl_update_cursor_data;
-+
-+    vdc->realize = virtio_gpu_gl_device_realize;
-+    vdc->reset = virtio_gpu_gl_reset;
-+    device_class_set_props(dc, virtio_gpu_gl_properties);
-+}
-+
-+static const TypeInfo virtio_gpu_gl_info = {
-+    .name = TYPE_VIRTIO_GPU_GL,
-+    .parent = TYPE_VIRTIO_GPU,
-+    .instance_size = sizeof(VirtIOGPUGL),
-+    .class_init = virtio_gpu_gl_class_init,
-+};
-+
-+static void virtio_register_types(void)
-+{
-+    type_register_static(&virtio_gpu_gl_info);
-+}
-+
-+type_init(virtio_register_types)
-diff --git a/hw/display/virtio-gpu-pci-gl.c b/hw/display/virtio-gpu-pci-gl.c
-new file mode 100644
-index 0000000000..902dda3452
---- /dev/null
-+++ b/hw/display/virtio-gpu-pci-gl.c
-@@ -0,0 +1,55 @@
-+/*
-+ * Virtio video device
-+ *
-+ * Copyright Red Hat
-+ *
-+ * Authors:
-+ *  Dave Airlie
-+ *
-+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
-+ * See the COPYING file in the top-level directory.
-+ *
-+ */
-+
-+#include "qemu/osdep.h"
-+#include "qapi/error.h"
-+#include "qemu/module.h"
-+#include "hw/pci/pci.h"
-+#include "hw/qdev-properties.h"
-+#include "hw/virtio/virtio.h"
-+#include "hw/virtio/virtio-bus.h"
-+#include "hw/virtio/virtio-gpu-pci.h"
-+#include "qom/object.h"
-+
-+#define TYPE_VIRTIO_GPU_GL_PCI "virtio-gpu-gl-pci"
-+typedef struct VirtIOGPUGLPCI VirtIOGPUGLPCI;
-+DECLARE_INSTANCE_CHECKER(VirtIOGPUGLPCI, VIRTIO_GPU_GL_PCI,
-+                         TYPE_VIRTIO_GPU_GL_PCI)
-+
-+struct VirtIOGPUGLPCI {
-+    VirtIOGPUPCIBase parent_obj;
-+    VirtIOGPUGL vdev;
-+};
-+
-+static void virtio_gpu_gl_initfn(Object *obj)
-+{
-+    VirtIOGPUGLPCI *dev = VIRTIO_GPU_GL_PCI(obj);
-+
-+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-+                                TYPE_VIRTIO_GPU_GL);
-+    VIRTIO_GPU_PCI_BASE(obj)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
-+}
-+
-+static const VirtioPCIDeviceTypeInfo virtio_gpu_gl_pci_info = {
-+    .generic_name = TYPE_VIRTIO_GPU_GL_PCI,
-+    .parent = TYPE_VIRTIO_GPU_PCI_BASE,
-+    .instance_size = sizeof(VirtIOGPUGLPCI),
-+    .instance_init = virtio_gpu_gl_initfn,
-+};
-+
-+static void virtio_gpu_gl_pci_register_types(void)
-+{
-+    virtio_pci_types_register(&virtio_gpu_gl_pci_info);
-+}
-+
-+type_init(virtio_gpu_gl_pci_register_types)
-diff --git a/hw/display/virtio-gpu-udmabuf.c b/hw/display/virtio-gpu-udmabuf.c
-new file mode 100644
-index 0000000000..3c01a415e7
---- /dev/null
-+++ b/hw/display/virtio-gpu-udmabuf.c
-@@ -0,0 +1,223 @@
-+/*
-+ * Virtio GPU Device
-+ *
-+ * Copyright Red Hat, Inc. 2013-2014
-+ *
-+ * Authors:
-+ *     Dave Airlie <airlied@redhat.com>
-+ *     Gerd Hoffmann <kraxel@redhat.com>
-+ *
-+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
-+ * See the COPYING file in the top-level directory.
-+ */
-+
-+#include "qemu/osdep.h"
-+#include "qemu/units.h"
-+#include "qemu-common.h"
-+#include "qemu/iov.h"
-+#include "ui/console.h"
-+#include "hw/virtio/virtio-gpu.h"
-+#include "hw/virtio/virtio-gpu-pixman.h"
-+#include "trace.h"
-+#include "exec/ramblock.h"
-+#include "sysemu/hostmem.h"
-+#include <sys/ioctl.h>
-+#include <fcntl.h>
-+#include <linux/memfd.h>
-+#include "qemu/memfd.h"
-+#include "standard-headers/linux/udmabuf.h"
-+
-+static void virtio_gpu_create_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    struct udmabuf_create_list *list;
-+    RAMBlock *rb;
-+    ram_addr_t offset;
-+    int udmabuf, i;
-+
-+    udmabuf = udmabuf_fd();
-+    if (udmabuf < 0) {
-+        return;
-+    }
-+
-+    list = g_malloc0(sizeof(struct udmabuf_create_list) +
-+                     sizeof(struct udmabuf_create_item) * res->iov_cnt);
-+
-+    for (i = 0; i < res->iov_cnt; i++) {
-+        rcu_read_lock();
-+        rb = qemu_ram_block_from_host(res->iov[i].iov_base, false, &offset);
-+        rcu_read_unlock();
-+
-+        if (!rb || rb->fd < 0) {
-+            g_free(list);
-+            return;
-+        }
-+
-+        list->list[i].memfd  = rb->fd;
-+        list->list[i].offset = offset;
-+        list->list[i].size   = res->iov[i].iov_len;
-+    }
-+
-+    list->count = res->iov_cnt;
-+    list->flags = UDMABUF_FLAGS_CLOEXEC;
-+
-+    res->dmabuf_fd = ioctl(udmabuf, UDMABUF_CREATE_LIST, list);
-+    if (res->dmabuf_fd < 0) {
-+        warn_report("%s: UDMABUF_CREATE_LIST: %s", __func__,
-+                    strerror(errno));
-+    }
-+    g_free(list);
-+}
-+
-+static void virtio_gpu_remap_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    res->remapped = mmap(NULL, res->blob_size, PROT_READ,
-+                         MAP_SHARED, res->dmabuf_fd, 0);
-+    if (res->remapped == MAP_FAILED) {
-+        warn_report("%s: dmabuf mmap failed: %s", __func__,
-+                    strerror(errno));
-+        res->remapped = NULL;
-+    }
-+}
-+
-+static void virtio_gpu_destroy_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    if (res->remapped) {
-+        munmap(res->remapped, res->blob_size);
-+        res->remapped = NULL;
-+    }
-+    if (res->dmabuf_fd >= 0) {
-+        close(res->dmabuf_fd);
-+        res->dmabuf_fd = -1;
-+    }
-+}
-+
-+static int find_memory_backend_type(Object *obj, void *opaque)
-+{
-+    bool *memfd_backend = opaque;
-+    int ret;
-+
-+    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {
-+        HostMemoryBackend *backend = MEMORY_BACKEND(obj);
-+        RAMBlock *rb = backend->mr.ram_block;
-+
-+        if (rb && rb->fd > 0) {
-+            ret = fcntl(rb->fd, F_GET_SEALS);
-+            if (ret > 0) {
-+                *memfd_backend = true;
-+            }
-+        }
-+    }
-+
-+    return 0;
-+}
-+
-+bool virtio_gpu_have_udmabuf(void)
-+{
-+    Object *memdev_root;
-+    int udmabuf;
-+    bool memfd_backend = false;
-+
-+    udmabuf = udmabuf_fd();
-+    if (udmabuf < 0) {
-+        return false;
-+    }
-+
-+    memdev_root = object_resolve_path("/objects", NULL);
-+    object_child_foreach(memdev_root, find_memory_backend_type, &memfd_backend);
-+
-+    return memfd_backend;
-+}
-+
-+void virtio_gpu_init_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    void *pdata = NULL;
-+
-+    res->dmabuf_fd = -1;
-+    if (res->iov_cnt == 1) {
-+        pdata = res->iov[0].iov_base;
-+    } else {
-+        virtio_gpu_create_udmabuf(res);
-+        if (res->dmabuf_fd < 0) {
-+            return;
-+        }
-+        virtio_gpu_remap_udmabuf(res);
-+        if (!res->remapped) {
-+            return;
-+        }
-+        pdata = res->remapped;
-+    }
-+
-+    res->blob = pdata;
-+}
-+
-+void virtio_gpu_fini_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    if (res->remapped) {
-+        virtio_gpu_destroy_udmabuf(res);
-+    }
-+}
-+
-+static void virtio_gpu_free_dmabuf(VirtIOGPU *g, VGPUDMABuf *dmabuf)
-+{
-+    struct virtio_gpu_scanout *scanout;
-+
-+    scanout = &g->parent_obj.scanout[dmabuf->scanout_id];
-+    dpy_gl_release_dmabuf(scanout->con, &dmabuf->buf);
-+    QTAILQ_REMOVE(&g->dmabuf.bufs, dmabuf, next);
-+    g_free(dmabuf);
-+}
-+
-+static VGPUDMABuf
-+*virtio_gpu_create_dmabuf(VirtIOGPU *g,
-+                          uint32_t scanout_id,
-+                          struct virtio_gpu_simple_resource *res,
-+                          struct virtio_gpu_framebuffer *fb)
-+{
-+    VGPUDMABuf *dmabuf;
-+
-+    if (res->dmabuf_fd < 0) {
-+        return NULL;
-+    }
-+
-+    dmabuf = g_new0(VGPUDMABuf, 1);
-+    dmabuf->buf.width = fb->width;
-+    dmabuf->buf.height = fb->height;
-+    dmabuf->buf.stride = fb->stride;
-+    dmabuf->buf.fourcc = qemu_pixman_to_drm_format(fb->format);
-+    dmabuf->buf.fd = res->dmabuf_fd;
-+
-+    dmabuf->scanout_id = scanout_id;
-+    QTAILQ_INSERT_HEAD(&g->dmabuf.bufs, dmabuf, next);
-+
-+    return dmabuf;
-+}
-+
-+int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-+                             uint32_t scanout_id,
-+                             struct virtio_gpu_simple_resource *res,
-+                             struct virtio_gpu_framebuffer *fb)
-+{
-+    struct virtio_gpu_scanout *scanout = &g->parent_obj.scanout[scanout_id];
-+    VGPUDMABuf *new_primary, *old_primary = NULL;
-+
-+    new_primary = virtio_gpu_create_dmabuf(g, scanout_id, res, fb);
-+    if (!new_primary) {
-+        return -EINVAL;
-+    }
-+
-+    if (g->dmabuf.primary) {
-+        old_primary = g->dmabuf.primary;
-+    }
-+
-+    g->dmabuf.primary = new_primary;
-+    qemu_console_resize(scanout->con,
-+                        new_primary->buf.width,
-+                        new_primary->buf.height);
-+    dpy_gl_scanout_dmabuf(scanout->con, &new_primary->buf);
-+
-+    if (old_primary) {
-+        virtio_gpu_free_dmabuf(g, old_primary);
-+    }
-+
-+    return 0;
-+}
-diff --git a/hw/display/virtio-gpu-3d.c b/hw/display/virtio-gpu-virgl.c
-similarity index 98%
-rename from hw/display/virtio-gpu-3d.c
-rename to hw/display/virtio-gpu-virgl.c
-index d98964858e..092c6dc380 100644
---- a/hw/display/virtio-gpu-3d.c
-+++ b/hw/display/virtio-gpu-virgl.c
-@@ -283,22 +283,24 @@ static void virgl_resource_attach_backing(VirtIOGPU *g,
- {
-     struct virtio_gpu_resource_attach_backing att_rb;
-     struct iovec *res_iovs;
-+    uint32_t res_niov;
-     int ret;
- 
-     VIRTIO_GPU_FILL_CMD(att_rb);
-     trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);
- 
--    ret = virtio_gpu_create_mapping_iov(g, &att_rb, cmd, NULL, &res_iovs);
-+    ret = virtio_gpu_create_mapping_iov(g, att_rb.nr_entries, sizeof(att_rb),
-+                                        cmd, NULL, &res_iovs, &res_niov);
-     if (ret != 0) {
-         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-         return;
-     }
- 
-     ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,
--                                             res_iovs, att_rb.nr_entries);
-+                                             res_iovs, res_niov);
- 
-     if (ret != 0)
--        virtio_gpu_cleanup_mapping_iov(g, res_iovs, att_rb.nr_entries);
-+        virtio_gpu_cleanup_mapping_iov(g, res_iovs, res_niov);
- }
- 
- static void virgl_resource_detach_backing(VirtIOGPU *g,
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index c9f5e36fd0..e183f4ecda 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -35,80 +35,51 @@
- 
- static struct virtio_gpu_simple_resource*
- virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id);
-+static struct virtio_gpu_simple_resource *
-+virtio_gpu_find_check_resource(VirtIOGPU *g, uint32_t resource_id,
-+                               bool require_backing,
-+                               const char *caller, uint32_t *error);
- 
- static void virtio_gpu_cleanup_mapping(VirtIOGPU *g,
-                                        struct virtio_gpu_simple_resource *res);
- 
--#ifdef CONFIG_VIRGL
--#include <virglrenderer.h>
--#define VIRGL(_g, _virgl, _simple, ...)                     \
--    do {                                                    \
--        if (_g->parent_obj.use_virgl_renderer) {            \
--            _virgl(__VA_ARGS__);                            \
--        } else {                                            \
--            _simple(__VA_ARGS__);                           \
--        }                                                   \
--    } while (0)
--#else
--#define VIRGL(_g, _virgl, _simple, ...)                 \
--    do {                                                \
--        _simple(__VA_ARGS__);                           \
--    } while (0)
--#endif
--
--static void update_cursor_data_simple(VirtIOGPU *g,
--                                      struct virtio_gpu_scanout *s,
--                                      uint32_t resource_id)
-+void virtio_gpu_update_cursor_data(VirtIOGPU *g,
-+                                   struct virtio_gpu_scanout *s,
-+                                   uint32_t resource_id)
- {
-     struct virtio_gpu_simple_resource *res;
-     uint32_t pixels;
-+    void *data;
- 
--    res = virtio_gpu_find_resource(g, resource_id);
-+    res = virtio_gpu_find_check_resource(g, resource_id, false,
-+                                         __func__, NULL);
-     if (!res) {
-         return;
-     }
- 
--    if (pixman_image_get_width(res->image)  != s->current_cursor->width ||
--        pixman_image_get_height(res->image) != s->current_cursor->height) {
--        return;
-+    if (res->blob_size) {
-+        if (res->blob_size < (s->current_cursor->width *
-+                              s->current_cursor->height * 4)) {
-+            return;
-+        }
-+        data = res->blob;
-+    } else {
-+        if (pixman_image_get_width(res->image)  != s->current_cursor->width ||
-+            pixman_image_get_height(res->image) != s->current_cursor->height) {
-+            return;
-+        }
-+        data = pixman_image_get_data(res->image);
-     }
- 
-     pixels = s->current_cursor->width * s->current_cursor->height;
--    memcpy(s->current_cursor->data,
--           pixman_image_get_data(res->image),
-+    memcpy(s->current_cursor->data, data,
-            pixels * sizeof(uint32_t));
- }
- 
--#ifdef CONFIG_VIRGL
--
--static void update_cursor_data_virgl(VirtIOGPU *g,
--                                     struct virtio_gpu_scanout *s,
--                                     uint32_t resource_id)
--{
--    uint32_t width, height;
--    uint32_t pixels, *data;
--
--    data = virgl_renderer_get_cursor_data(resource_id, &width, &height);
--    if (!data) {
--        return;
--    }
--
--    if (width != s->current_cursor->width ||
--        height != s->current_cursor->height) {
--        free(data);
--        return;
--    }
--
--    pixels = s->current_cursor->width * s->current_cursor->height;
--    memcpy(s->current_cursor->data, data, pixels * sizeof(uint32_t));
--    free(data);
--}
--
--#endif
--
- static void update_cursor(VirtIOGPU *g, struct virtio_gpu_update_cursor *cursor)
- {
-     struct virtio_gpu_scanout *s;
-+    VirtIOGPUClass *vgc = VIRTIO_GPU_GET_CLASS(g);
-     bool move = cursor->hdr.type == VIRTIO_GPU_CMD_MOVE_CURSOR;
- 
-     if (cursor->pos.scanout_id >= g->parent_obj.conf.max_outputs) {
-@@ -131,8 +102,7 @@ static void update_cursor(VirtIOGPU *g, struct virtio_gpu_update_cursor *cursor)
-         s->current_cursor->hot_y = cursor->hot_y;
- 
-         if (cursor->resource_id > 0) {
--            VIRGL(g, update_cursor_data_virgl, update_cursor_data_simple,
--                  g, s, cursor->resource_id);
-+            vgc->update_cursor_data(g, s, cursor->resource_id);
-         }
-         dpy_cursor_define(s->con, s->current_cursor);
- 
-@@ -158,6 +128,37 @@ virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id)
-     return NULL;
- }
- 
-+static struct virtio_gpu_simple_resource *
-+virtio_gpu_find_check_resource(VirtIOGPU *g, uint32_t resource_id,
-+                               bool require_backing,
-+                               const char *caller, uint32_t *error)
-+{
-+    struct virtio_gpu_simple_resource *res;
-+
-+    res = virtio_gpu_find_resource(g, resource_id);
-+    if (!res) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid resource specified %d\n",
-+                      caller, resource_id);
-+        if (error) {
-+            *error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-+        }
-+        return NULL;
-+    }
-+
-+    if (require_backing) {
-+        if (!res->iov || (!res->image && !res->blob)) {
-+            qemu_log_mask(LOG_GUEST_ERROR, "%s: no backing storage %d\n",
-+                          caller, resource_id);
-+            if (error) {
-+                *error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+            }
-+            return NULL;
-+        }
-+    }
-+
-+    return res;
-+}
-+
- void virtio_gpu_ctrl_response(VirtIOGPU *g,
-                               struct virtio_gpu_ctrl_command *cmd,
-                               struct virtio_gpu_ctrl_hdr *resp,
-@@ -321,6 +322,62 @@ static void virtio_gpu_resource_create_2d(VirtIOGPU *g,
-     g->hostmem += res->hostmem;
- }
- 
-+static void virtio_gpu_resource_create_blob(VirtIOGPU *g,
-+                                            struct virtio_gpu_ctrl_command *cmd)
-+{
-+    struct virtio_gpu_simple_resource *res;
-+    struct virtio_gpu_resource_create_blob cblob;
-+    int ret;
-+
-+    VIRTIO_GPU_FILL_CMD(cblob);
-+    virtio_gpu_create_blob_bswap(&cblob);
-+    trace_virtio_gpu_cmd_res_create_blob(cblob.resource_id, cblob.size);
-+
-+    if (cblob.resource_id == 0) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: resource id 0 is not allowed\n",
-+                      __func__);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-+        return;
-+    }
-+
-+    res = virtio_gpu_find_resource(g, cblob.resource_id);
-+    if (res) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: resource already exists %d\n",
-+                      __func__, cblob.resource_id);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-+        return;
-+    }
-+
-+    res = g_new0(struct virtio_gpu_simple_resource, 1);
-+    res->resource_id = cblob.resource_id;
-+    res->blob_size = cblob.size;
-+
-+    if (cblob.blob_mem != VIRTIO_GPU_BLOB_MEM_GUEST &&
-+        cblob.blob_flags != VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid memory type\n",
-+                      __func__);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+        g_free(res);
-+        return;
-+    }
-+
-+    if (res->iov) {
-+        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+        return;
-+    }
-+
-+    ret = virtio_gpu_create_mapping_iov(g, cblob.nr_entries, sizeof(cblob),
-+                                        cmd, &res->addrs, &res->iov,
-+                                        &res->iov_cnt);
-+    if (ret != 0) {
-+        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+        return;
-+    }
-+
-+    virtio_gpu_init_udmabuf(res);
-+    QTAILQ_INSERT_HEAD(&g->reslist, res, next);
-+}
-+
- static void virtio_gpu_disable_scanout(VirtIOGPU *g, int scanout_id)
- {
-     struct virtio_gpu_scanout *scanout = &g->parent_obj.scanout[scanout_id];
-@@ -355,7 +412,7 @@ static void virtio_gpu_resource_destroy(VirtIOGPU *g,
-         }
-     }
- 
--    pixman_image_unref(res->image);
-+    qemu_pixman_image_unref(res->image);
-     virtio_gpu_cleanup_mapping(g, res);
-     QTAILQ_REMOVE(&g->reslist, res, next);
-     g->hostmem -= res->hostmem;
-@@ -396,11 +453,9 @@ static void virtio_gpu_transfer_to_host_2d(VirtIOGPU *g,
-     virtio_gpu_t2d_bswap(&t2d);
-     trace_virtio_gpu_cmd_res_xfer_toh_2d(t2d.resource_id);
- 
--    res = virtio_gpu_find_resource(g, t2d.resource_id);
--    if (!res || !res->iov) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal resource specified %d\n",
--                      __func__, t2d.resource_id);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-+    res = virtio_gpu_find_check_resource(g, t2d.resource_id, true,
-+                                         __func__, &cmd->error);
-+    if (!res || res->blob) {
-         return;
-     }
- 
-@@ -446,6 +501,7 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
- {
-     struct virtio_gpu_simple_resource *res;
-     struct virtio_gpu_resource_flush rf;
-+    struct virtio_gpu_scanout *scanout;
-     pixman_region16_t flush_region;
-     int i;
- 
-@@ -454,20 +510,31 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
-     trace_virtio_gpu_cmd_res_flush(rf.resource_id,
-                                    rf.r.width, rf.r.height, rf.r.x, rf.r.y);
- 
--    res = virtio_gpu_find_resource(g, rf.resource_id);
-+    res = virtio_gpu_find_check_resource(g, rf.resource_id, false,
-+                                         __func__, &cmd->error);
-     if (!res) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal resource specified %d\n",
--                      __func__, rf.resource_id);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-         return;
-     }
- 
--    if (rf.r.x > res->width ||
-+    if (res->blob) {
-+        for (i = 0; i < g->parent_obj.conf.max_outputs; i++) {
-+            scanout = &g->parent_obj.scanout[i];
-+            if (scanout->resource_id == res->resource_id &&
-+                console_has_gl(scanout->con)) {
-+                dpy_gl_update(scanout->con, 0, 0, scanout->width,
-+                              scanout->height);
-+                return;
-+            }
-+        }
-+    }
-+
-+    if (!res->blob &&
-+        (rf.r.x > res->width ||
-         rf.r.y > res->height ||
-         rf.r.width > res->width ||
-         rf.r.height > res->height ||
-         rf.r.x + rf.r.width > res->width ||
--        rf.r.y + rf.r.height > res->height) {
-+        rf.r.y + rf.r.height > res->height)) {
-         qemu_log_mask(LOG_GUEST_ERROR, "%s: flush bounds outside resource"
-                       " bounds for resource %d: %d %d %d %d vs %d %d\n",
-                       __func__, rf.resource_id, rf.r.x, rf.r.y,
-@@ -479,7 +546,6 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
-     pixman_region_init_rect(&flush_region,
-                             rf.r.x, rf.r.y, rf.r.width, rf.r.height);
-     for (i = 0; i < g->parent_obj.conf.max_outputs; i++) {
--        struct virtio_gpu_scanout *scanout;
-         pixman_region16_t region, finalregion;
-         pixman_box16_t *extents;
- 
-@@ -512,14 +578,109 @@ static void virtio_unref_resource(pixman_image_t *image, void *data)
-     pixman_image_unref(data);
- }
- 
-+static void virtio_gpu_update_scanout(VirtIOGPU *g,
-+                                      uint32_t scanout_id,
-+                                      struct virtio_gpu_simple_resource *res,
-+                                      struct virtio_gpu_rect *r)
-+{
-+    struct virtio_gpu_simple_resource *ores;
-+    struct virtio_gpu_scanout *scanout;
-+
-+    scanout = &g->parent_obj.scanout[scanout_id];
-+    ores = virtio_gpu_find_resource(g, scanout->resource_id);
-+    if (ores) {
-+        ores->scanout_bitmask &= ~(1 << scanout_id);
-+    }
-+
-+    res->scanout_bitmask |= (1 << scanout_id);
-+    scanout->resource_id = res->resource_id;
-+    scanout->x = r->x;
-+    scanout->y = r->y;
-+    scanout->width = r->width;
-+    scanout->height = r->height;
-+}
-+
-+static void virtio_gpu_do_set_scanout(VirtIOGPU *g,
-+                                      uint32_t scanout_id,
-+                                      struct virtio_gpu_framebuffer *fb,
-+                                      struct virtio_gpu_simple_resource *res,
-+                                      struct virtio_gpu_rect *r,
-+                                      uint32_t *error)
-+{
-+    struct virtio_gpu_scanout *scanout;
-+    uint8_t *data;
-+
-+    scanout = &g->parent_obj.scanout[scanout_id];
-+
-+    if (r->x > fb->width ||
-+        r->y > fb->height ||
-+        r->width < 16 ||
-+        r->height < 16 ||
-+        r->width > fb->width ||
-+        r->height > fb->height ||
-+        r->x + r->width > fb->width ||
-+        r->y + r->height > fb->height) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal scanout %d bounds for"
-+                      " resource %d, rect (%d,%d)+%d,%d, fb %d %d\n",
-+                      __func__, scanout_id, res->resource_id,
-+                      r->x, r->y, r->width, r->height,
-+                      fb->width, fb->height);
-+        *error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+        return;
-+    }
-+
-+    g->parent_obj.enable = 1;
-+
-+    if (res->blob) {
-+        if (console_has_gl(scanout->con)) {
-+            if (!virtio_gpu_update_dmabuf(g, scanout_id, res, fb)) {
-+                virtio_gpu_update_scanout(g, scanout_id, res, r);
-+                return;
-+            }
-+        }
-+
-+        data = res->blob;
-+    } else {
-+        data = (uint8_t *)pixman_image_get_data(res->image);
-+    }
-+
-+    /* create a surface for this scanout */
-+    if ((res->blob && !console_has_gl(scanout->con)) ||
-+        !scanout->ds ||
-+        surface_data(scanout->ds) != data + fb->offset ||
-+        scanout->width != r->width ||
-+        scanout->height != r->height) {
-+        pixman_image_t *rect;
-+        void *ptr = data + fb->offset;
-+        rect = pixman_image_create_bits(fb->format, r->width, r->height,
-+                                        ptr, fb->stride);
-+
-+        if (res->image) {
-+            pixman_image_ref(res->image);
-+            pixman_image_set_destroy_function(rect, virtio_unref_resource,
-+                                              res->image);
-+        }
-+
-+        /* realloc the surface ptr */
-+        scanout->ds = qemu_create_displaysurface_pixman(rect);
-+        if (!scanout->ds) {
-+            *error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+            return;
-+        }
-+
-+        pixman_image_unref(rect);
-+        dpy_gfx_replace_surface(g->parent_obj.scanout[scanout_id].con,
-+                                scanout->ds);
-+    }
-+
-+    virtio_gpu_update_scanout(g, scanout_id, res, r);
-+}
-+
- static void virtio_gpu_set_scanout(VirtIOGPU *g,
-                                    struct virtio_gpu_ctrl_command *cmd)
- {
--    struct virtio_gpu_simple_resource *res, *ores;
--    struct virtio_gpu_scanout *scanout;
--    pixman_format_code_t format;
--    uint32_t offset;
--    int bpp;
-+    struct virtio_gpu_simple_resource *res;
-+    struct virtio_gpu_framebuffer fb = { 0 };
-     struct virtio_gpu_set_scanout ss;
- 
-     VIRTIO_GPU_FILL_CMD(ss);
-@@ -534,97 +695,111 @@ static void virtio_gpu_set_scanout(VirtIOGPU *g,
-         return;
-     }
- 
--    g->parent_obj.enable = 1;
-     if (ss.resource_id == 0) {
-         virtio_gpu_disable_scanout(g, ss.scanout_id);
-         return;
-     }
- 
--    /* create a surface for this scanout */
--    res = virtio_gpu_find_resource(g, ss.resource_id);
-+    res = virtio_gpu_find_check_resource(g, ss.resource_id, true,
-+                                         __func__, &cmd->error);
-     if (!res) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal resource specified %d\n",
--                      __func__, ss.resource_id);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-         return;
-     }
- 
--    if (ss.r.x > res->width ||
--        ss.r.y > res->height ||
--        ss.r.width < 16 ||
--        ss.r.height < 16 ||
--        ss.r.width > res->width ||
--        ss.r.height > res->height ||
--        ss.r.x + ss.r.width > res->width ||
--        ss.r.y + ss.r.height > res->height) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal scanout %d bounds for"
--                      " resource %d, (%d,%d)+%d,%d vs %d %d\n",
--                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,
--                      ss.r.width, ss.r.height, res->width, res->height);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+    fb.format = pixman_image_get_format(res->image);
-+    fb.bytes_pp = DIV_ROUND_UP(PIXMAN_FORMAT_BPP(fb.format), 8);
-+    fb.width  = pixman_image_get_width(res->image);
-+    fb.height = pixman_image_get_height(res->image);
-+    fb.stride = pixman_image_get_stride(res->image);
-+    fb.offset = ss.r.x * fb.bytes_pp + ss.r.y * fb.stride;
-+
-+    virtio_gpu_do_set_scanout(g, ss.scanout_id,
-+                              &fb, res, &ss.r, &cmd->error);
-+}
-+
-+static void virtio_gpu_set_scanout_blob(VirtIOGPU *g,
-+                                        struct virtio_gpu_ctrl_command *cmd)
-+{
-+    struct virtio_gpu_simple_resource *res;
-+    struct virtio_gpu_framebuffer fb = { 0 };
-+    struct virtio_gpu_set_scanout_blob ss;
-+    uint64_t fbend;
-+
-+    VIRTIO_GPU_FILL_CMD(ss);
-+    virtio_gpu_scanout_blob_bswap(&ss);
-+    trace_virtio_gpu_cmd_set_scanout_blob(ss.scanout_id, ss.resource_id,
-+                                          ss.r.width, ss.r.height, ss.r.x,
-+                                          ss.r.y);
-+
-+    if (ss.scanout_id >= g->parent_obj.conf.max_outputs) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal scanout id specified %d",
-+                      __func__, ss.scanout_id);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
-         return;
-     }
- 
--    scanout = &g->parent_obj.scanout[ss.scanout_id];
-+    if (ss.resource_id == 0) {
-+        virtio_gpu_disable_scanout(g, ss.scanout_id);
-+        return;
-+    }
- 
--    format = pixman_image_get_format(res->image);
--    bpp = DIV_ROUND_UP(PIXMAN_FORMAT_BPP(format), 8);
--    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);
--    if (!scanout->ds || surface_data(scanout->ds)
--        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||
--        scanout->width != ss.r.width ||
--        scanout->height != ss.r.height) {
--        pixman_image_t *rect;
--        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;
--        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,
--                                        pixman_image_get_stride(res->image));
--        pixman_image_ref(res->image);
--        pixman_image_set_destroy_function(rect, virtio_unref_resource,
--                                          res->image);
--        /* realloc the surface ptr */
--        scanout->ds = qemu_create_displaysurface_pixman(rect);
--        if (!scanout->ds) {
--            cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
--            return;
--        }
--        pixman_image_unref(rect);
--        dpy_gfx_replace_surface(g->parent_obj.scanout[ss.scanout_id].con,
--                                scanout->ds);
-+    res = virtio_gpu_find_check_resource(g, ss.resource_id, true,
-+                                         __func__, &cmd->error);
-+    if (!res) {
-+        return;
-     }
- 
--    ores = virtio_gpu_find_resource(g, scanout->resource_id);
--    if (ores) {
--        ores->scanout_bitmask &= ~(1 << ss.scanout_id);
-+    fb.format = virtio_gpu_get_pixman_format(ss.format);
-+    if (!fb.format) {
-+        qemu_log_mask(LOG_GUEST_ERROR,
-+                      "%s: host couldn't handle guest format %d\n",
-+                      __func__, ss.format);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+        return;
-+    }
-+
-+    fb.bytes_pp = DIV_ROUND_UP(PIXMAN_FORMAT_BPP(fb.format), 8);
-+    fb.width = ss.width;
-+    fb.height = ss.height;
-+    fb.stride = ss.strides[0];
-+    fb.offset = ss.offsets[0] + ss.r.x * fb.bytes_pp + ss.r.y * fb.stride;
-+
-+    fbend = fb.offset;
-+    fbend += fb.stride * (ss.r.height - 1);
-+    fbend += fb.bytes_pp * ss.r.width;
-+    if (fbend > res->blob_size) {
-+        qemu_log_mask(LOG_GUEST_ERROR,
-+                      "%s: fb end out of range\n",
-+                      __func__);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+        return;
-     }
- 
--    res->scanout_bitmask |= (1 << ss.scanout_id);
--    scanout->resource_id = ss.resource_id;
--    scanout->x = ss.r.x;
--    scanout->y = ss.r.y;
--    scanout->width = ss.r.width;
--    scanout->height = ss.r.height;
-+    virtio_gpu_do_set_scanout(g, ss.scanout_id,
-+                              &fb, res, &ss.r, &cmd->error);
- }
- 
- int virtio_gpu_create_mapping_iov(VirtIOGPU *g,
--                                  struct virtio_gpu_resource_attach_backing *ab,
-+                                  uint32_t nr_entries, uint32_t offset,
-                                   struct virtio_gpu_ctrl_command *cmd,
--                                  uint64_t **addr, struct iovec **iov)
-+                                  uint64_t **addr, struct iovec **iov,
-+                                  uint32_t *niov)
- {
-     struct virtio_gpu_mem_entry *ents;
-     size_t esize, s;
--    int i;
-+    int e, v;
- 
--    if (ab->nr_entries > 16384) {
-+    if (nr_entries > 16384) {
-         qemu_log_mask(LOG_GUEST_ERROR,
-                       "%s: nr_entries is too big (%d > 16384)\n",
--                      __func__, ab->nr_entries);
-+                      __func__, nr_entries);
-         return -1;
-     }
- 
--    esize = sizeof(*ents) * ab->nr_entries;
-+    esize = sizeof(*ents) * nr_entries;
-     ents = g_malloc(esize);
-     s = iov_to_buf(cmd->elem.out_sg, cmd->elem.out_num,
--                   sizeof(*ab), ents, esize);
-+                   offset, ents, esize);
-     if (s != esize) {
-         qemu_log_mask(LOG_GUEST_ERROR,
-                       "%s: command data size incorrect %zu vs %zu\n",
-@@ -633,37 +808,52 @@ int virtio_gpu_create_mapping_iov(VirtIOGPU *g,
-         return -1;
-     }
- 
--    *iov = g_malloc0(sizeof(struct iovec) * ab->nr_entries);
-+    *iov = NULL;
-     if (addr) {
--        *addr = g_malloc0(sizeof(uint64_t) * ab->nr_entries);
--    }
--    for (i = 0; i < ab->nr_entries; i++) {
--        uint64_t a = le64_to_cpu(ents[i].addr);
--        uint32_t l = le32_to_cpu(ents[i].length);
--        hwaddr len = l;
--        (*iov)[i].iov_base = dma_memory_map(VIRTIO_DEVICE(g)->dma_as,
--                                            a, &len, DMA_DIRECTION_TO_DEVICE);
--        (*iov)[i].iov_len = len;
--        if (addr) {
--            (*addr)[i] = a;
--        }
--        if (!(*iov)[i].iov_base || len != l) {
--            qemu_log_mask(LOG_GUEST_ERROR, "%s: failed to map MMIO memory for"
--                          " resource %d element %d\n",
--                          __func__, ab->resource_id, i);
--            if ((*iov)[i].iov_base) {
--                i++; /* cleanup the 'i'th map */
-+        *addr = NULL;
-+    }
-+    for (e = 0, v = 0; e < nr_entries; e++) {
-+        uint64_t a = le64_to_cpu(ents[e].addr);
-+        uint32_t l = le32_to_cpu(ents[e].length);
-+        hwaddr len;
-+        void *map;
-+
-+        do {
-+            len = l;
-+            map = dma_memory_map(VIRTIO_DEVICE(g)->dma_as,
-+                                 a, &len, DMA_DIRECTION_TO_DEVICE);
-+            if (!map) {
-+                qemu_log_mask(LOG_GUEST_ERROR, "%s: failed to map MMIO memory for"
-+                              " element %d\n", __func__, e);
-+                virtio_gpu_cleanup_mapping_iov(g, *iov, v);
-+                g_free(ents);
-+                *iov = NULL;
-+                if (addr) {
-+                    g_free(*addr);
-+                    *addr = NULL;
-+                }
-+                return -1;
-             }
--            virtio_gpu_cleanup_mapping_iov(g, *iov, i);
--            g_free(ents);
--            *iov = NULL;
-+
-+            if (!(v % 16)) {
-+                *iov = g_realloc(*iov, sizeof(struct iovec) * (v + 16));
-+                if (addr) {
-+                    *addr = g_realloc(*addr, sizeof(uint64_t) * (v + 16));
-+                }
-+            }
-+            (*iov)[v].iov_base = map;
-+            (*iov)[v].iov_len = len;
-             if (addr) {
--                g_free(*addr);
--                *addr = NULL;
-+                (*addr)[v] = a;
-             }
--            return -1;
--        }
-+
-+            a += len;
-+            l -= len;
-+            v += 1;
-+        } while (l > 0);
-     }
-+    *niov = v;
-+
-     g_free(ents);
-     return 0;
- }
-@@ -690,6 +880,10 @@ static void virtio_gpu_cleanup_mapping(VirtIOGPU *g,
-     res->iov_cnt = 0;
-     g_free(res->addrs);
-     res->addrs = NULL;
-+
-+    if (res->blob) {
-+        virtio_gpu_fini_udmabuf(res);
-+    }
- }
- 
- static void
-@@ -717,13 +911,12 @@ virtio_gpu_resource_attach_backing(VirtIOGPU *g,
-         return;
-     }
- 
--    ret = virtio_gpu_create_mapping_iov(g, &ab, cmd, &res->addrs, &res->iov);
-+    ret = virtio_gpu_create_mapping_iov(g, ab.nr_entries, sizeof(ab), cmd,
-+                                        &res->addrs, &res->iov, &res->iov_cnt);
-     if (ret != 0) {
-         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-         return;
-     }
--
--    res->iov_cnt = ab.nr_entries;
- }
- 
- static void
-@@ -737,18 +930,16 @@ virtio_gpu_resource_detach_backing(VirtIOGPU *g,
-     virtio_gpu_bswap_32(&detach, sizeof(detach));
-     trace_virtio_gpu_cmd_res_back_detach(detach.resource_id);
- 
--    res = virtio_gpu_find_resource(g, detach.resource_id);
--    if (!res || !res->iov) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: illegal resource specified %d\n",
--                      __func__, detach.resource_id);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-+    res = virtio_gpu_find_check_resource(g, detach.resource_id, true,
-+                                         __func__, &cmd->error);
-+    if (!res) {
-         return;
-     }
-     virtio_gpu_cleanup_mapping(g, res);
- }
- 
--static void virtio_gpu_simple_process_cmd(VirtIOGPU *g,
--                                          struct virtio_gpu_ctrl_command *cmd)
-+void virtio_gpu_simple_process_cmd(VirtIOGPU *g,
-+                                   struct virtio_gpu_ctrl_command *cmd)
- {
-     VIRTIO_GPU_FILL_CMD(cmd->cmd_hdr);
-     virtio_gpu_ctrl_hdr_bswap(&cmd->cmd_hdr);
-@@ -763,6 +954,13 @@ static void virtio_gpu_simple_process_cmd(VirtIOGPU *g,
-     case VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:
-         virtio_gpu_resource_create_2d(g, cmd);
-         break;
-+    case VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB:
-+        if (!virtio_gpu_blob_enabled(g->parent_obj.conf)) {
-+            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+            break;
-+        }
-+        virtio_gpu_resource_create_blob(g, cmd);
-+        break;
-     case VIRTIO_GPU_CMD_RESOURCE_UNREF:
-         virtio_gpu_resource_unref(g, cmd);
-         break;
-@@ -775,6 +973,13 @@ static void virtio_gpu_simple_process_cmd(VirtIOGPU *g,
-     case VIRTIO_GPU_CMD_SET_SCANOUT:
-         virtio_gpu_set_scanout(g, cmd);
-         break;
-+    case VIRTIO_GPU_CMD_SET_SCANOUT_BLOB:
-+        if (!virtio_gpu_blob_enabled(g->parent_obj.conf)) {
-+            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
-+            break;
-+        }
-+        virtio_gpu_set_scanout_blob(g, cmd);
-+        break;
-     case VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:
-         virtio_gpu_resource_attach_backing(g, cmd);
-         break;
-@@ -806,6 +1011,7 @@ static void virtio_gpu_handle_cursor_cb(VirtIODevice *vdev, VirtQueue *vq)
- void virtio_gpu_process_cmdq(VirtIOGPU *g)
- {
-     struct virtio_gpu_ctrl_command *cmd;
-+    VirtIOGPUClass *vgc = VIRTIO_GPU_GET_CLASS(g);
- 
-     if (g->processing_cmdq) {
-         return;
-@@ -819,8 +1025,7 @@ void virtio_gpu_process_cmdq(VirtIOGPU *g)
-         }
- 
-         /* process command */
--        VIRGL(g, virtio_gpu_virgl_process_cmd, virtio_gpu_simple_process_cmd,
--              g, cmd);
-+        vgc->process_cmd(g, cmd);
- 
-         QTAILQ_REMOVE(&g->cmdq, cmd, next);
-         if (virtio_gpu_stats_enabled(g->parent_obj.conf)) {
-@@ -843,19 +1048,6 @@ void virtio_gpu_process_cmdq(VirtIOGPU *g)
-     g->processing_cmdq = false;
- }
- 
--static void virtio_gpu_gl_flushed(VirtIOGPUBase *b)
--{
--    VirtIOGPU *g = VIRTIO_GPU(b);
--
--#ifdef CONFIG_VIRGL
--    if (g->renderer_reset) {
--        g->renderer_reset = false;
--        virtio_gpu_virgl_reset(g);
--    }
--#endif
--    virtio_gpu_process_cmdq(g);
--}
--
- static void virtio_gpu_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
- {
-     VirtIOGPU *g = VIRTIO_GPU(vdev);
-@@ -865,13 +1057,6 @@ static void virtio_gpu_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
-         return;
-     }
- 
--#ifdef CONFIG_VIRGL
--    if (!g->renderer_inited && g->parent_obj.use_virgl_renderer) {
--        virtio_gpu_virgl_init(g);
--        g->renderer_inited = true;
--    }
--#endif
--
-     cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command));
-     while (cmd) {
-         cmd->vq = vq;
-@@ -882,18 +1067,14 @@ static void virtio_gpu_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
-     }
- 
-     virtio_gpu_process_cmdq(g);
--
--#ifdef CONFIG_VIRGL
--    if (g->parent_obj.use_virgl_renderer) {
--        virtio_gpu_virgl_fence_poll(g);
--    }
--#endif
- }
- 
- static void virtio_gpu_ctrl_bh(void *opaque)
- {
-     VirtIOGPU *g = opaque;
--    virtio_gpu_handle_ctrl(&g->parent_obj.parent_obj, g->ctrl_vq);
-+    VirtIOGPUClass *vgc = VIRTIO_GPU_GET_CLASS(g);
-+
-+    vgc->handle_ctrl(&g->parent_obj.parent_obj, g->ctrl_vq);
- }
- 
- static void virtio_gpu_handle_cursor(VirtIODevice *vdev, VirtQueue *vq)
-@@ -1105,24 +1286,21 @@ static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size,
-     return 0;
- }
- 
--static void virtio_gpu_device_realize(DeviceState *qdev, Error **errp)
-+void virtio_gpu_device_realize(DeviceState *qdev, Error **errp)
- {
-     VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
-     VirtIOGPU *g = VIRTIO_GPU(qdev);
--    bool have_virgl;
--
--#if !defined(CONFIG_VIRGL) || defined(HOST_WORDS_BIGENDIAN)
--    have_virgl = false;
--#else
--    have_virgl = display_opengl;
--#endif
--    if (!have_virgl) {
--        g->parent_obj.conf.flags &= ~(1 << VIRTIO_GPU_FLAG_VIRGL_ENABLED);
--    } else {
--#if defined(CONFIG_VIRGL)
--        VIRTIO_GPU_BASE(g)->virtio_config.num_capsets =
--            virtio_gpu_virgl_get_num_capsets(g);
--#endif
-+
-+    if (virtio_gpu_blob_enabled(g->parent_obj.conf)) {
-+        if (!virtio_gpu_have_udmabuf()) {
-+            error_setg(errp, "cannot enable blob resources without udmabuf");
-+            return;
-+        }
-+
-+        if (virtio_gpu_virgl_enabled(g->parent_obj.conf)) {
-+            error_setg(errp, "blobs and virgl are not compatible (yet)");
-+            return;
-+        }
-     }
- 
-     if (!virtio_gpu_base_device_realize(qdev,
-@@ -1141,18 +1319,12 @@ static void virtio_gpu_device_realize(DeviceState *qdev, Error **errp)
-     QTAILQ_INIT(&g->fenceq);
- }
- 
--static void virtio_gpu_reset(VirtIODevice *vdev)
-+void virtio_gpu_reset(VirtIODevice *vdev)
- {
-     VirtIOGPU *g = VIRTIO_GPU(vdev);
-     struct virtio_gpu_simple_resource *res, *tmp;
-     struct virtio_gpu_ctrl_command *cmd;
- 
--#ifdef CONFIG_VIRGL
--    if (g->parent_obj.use_virgl_renderer) {
--        virtio_gpu_virgl_reset(g);
--    }
--#endif
--
-     QTAILQ_FOREACH_SAFE(res, &g->reslist, next, tmp) {
-         virtio_gpu_resource_destroy(g, res);
-     }
-@@ -1170,17 +1342,6 @@ static void virtio_gpu_reset(VirtIODevice *vdev)
-         g_free(cmd);
-     }
- 
--#ifdef CONFIG_VIRGL
--    if (g->parent_obj.use_virgl_renderer) {
--        if (g->parent_obj.renderer_blocked) {
--            g->renderer_reset = true;
--        } else {
--            virtio_gpu_virgl_reset(g);
--        }
--        g->parent_obj.use_virgl_renderer = false;
--    }
--#endif
--
-     virtio_gpu_base_reset(VIRTIO_GPU_BASE(vdev));
- }
- 
-@@ -1235,12 +1396,8 @@ static Property virtio_gpu_properties[] = {
-     VIRTIO_GPU_BASE_PROPERTIES(VirtIOGPU, parent_obj.conf),
-     DEFINE_PROP_SIZE("max_hostmem", VirtIOGPU, conf_max_hostmem,
-                      256 * MiB),
--#ifdef CONFIG_VIRGL
--    DEFINE_PROP_BIT("virgl", VirtIOGPU, parent_obj.conf.flags,
--                    VIRTIO_GPU_FLAG_VIRGL_ENABLED, true),
--    DEFINE_PROP_BIT("stats", VirtIOGPU, parent_obj.conf.flags,
--                    VIRTIO_GPU_FLAG_STATS_ENABLED, false),
--#endif
-+    DEFINE_PROP_BIT("blob", VirtIOGPU, parent_obj.conf.flags,
-+                    VIRTIO_GPU_FLAG_BLOB_ENABLED, false),
-     DEFINE_PROP_END_OF_LIST(),
- };
- 
-@@ -1248,9 +1405,12 @@ static void virtio_gpu_class_init(ObjectClass *klass, void *data)
- {
-     DeviceClass *dc = DEVICE_CLASS(klass);
-     VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
--    VirtIOGPUBaseClass *vgc = VIRTIO_GPU_BASE_CLASS(klass);
-+    VirtIOGPUClass *vgc = VIRTIO_GPU_CLASS(klass);
-+
-+    vgc->handle_ctrl = virtio_gpu_handle_ctrl;
-+    vgc->process_cmd = virtio_gpu_simple_process_cmd;
-+    vgc->update_cursor_data = virtio_gpu_update_cursor_data;
- 
--    vgc->gl_flushed = virtio_gpu_gl_flushed;
-     vdc->realize = virtio_gpu_device_realize;
-     vdc->reset = virtio_gpu_reset;
-     vdc->get_config = virtio_gpu_get_config;
-@@ -1264,6 +1424,7 @@ static const TypeInfo virtio_gpu_info = {
-     .name = TYPE_VIRTIO_GPU,
-     .parent = TYPE_VIRTIO_GPU_BASE,
-     .instance_size = sizeof(VirtIOGPU),
-+    .class_size = sizeof(VirtIOGPUClass),
-     .class_init = virtio_gpu_class_init,
- };
- 
-diff --git a/hw/display/virtio-vga-gl.c b/hw/display/virtio-vga-gl.c
-new file mode 100644
-index 0000000000..c971340ebb
---- /dev/null
-+++ b/hw/display/virtio-vga-gl.c
-@@ -0,0 +1,47 @@
-+#include "qemu/osdep.h"
-+#include "hw/pci/pci.h"
-+#include "hw/qdev-properties.h"
-+#include "hw/virtio/virtio-gpu.h"
-+#include "hw/display/vga.h"
-+#include "qapi/error.h"
-+#include "qemu/module.h"
-+#include "virtio-vga.h"
-+#include "qom/object.h"
-+
-+#define TYPE_VIRTIO_VGA_GL "virtio-vga-gl"
-+
-+typedef struct VirtIOVGAGL VirtIOVGAGL;
-+DECLARE_INSTANCE_CHECKER(VirtIOVGAGL, VIRTIO_VGA_GL,
-+                         TYPE_VIRTIO_VGA_GL)
-+
-+struct VirtIOVGAGL {
-+    VirtIOVGABase parent_obj;
-+
-+    VirtIOGPUGL   vdev;
-+};
-+
-+static void virtio_vga_gl_inst_initfn(Object *obj)
-+{
-+    VirtIOVGAGL *dev = VIRTIO_VGA_GL(obj);
-+
-+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-+                                TYPE_VIRTIO_GPU_GL);
-+    VIRTIO_VGA_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
-+}
-+
-+
-+static VirtioPCIDeviceTypeInfo virtio_vga_gl_info = {
-+    .generic_name  = TYPE_VIRTIO_VGA_GL,
-+    .parent        = TYPE_VIRTIO_VGA_BASE,
-+    .instance_size = sizeof(VirtIOVGAGL),
-+    .instance_init = virtio_vga_gl_inst_initfn,
-+};
-+
-+static void virtio_vga_register_types(void)
-+{
-+    if (have_vga) {
-+        virtio_pci_types_register(&virtio_vga_gl_info);
-+    }
-+}
-+
-+type_init(virtio_vga_register_types)
-diff --git a/include/hw/display/vga.h b/include/hw/display/vga.h
-index ca0003dbfd..5f7825e0e3 100644
---- a/include/hw/display/vga.h
-+++ b/include/hw/display/vga.h
-@@ -11,6 +11,12 @@
- 
- #include "exec/hwaddr.h"
- 
-+/*
-+ * modules can reference this symbol to avoid being loaded
-+ * into system emulators without vga support
-+ */
-+extern bool have_vga;
-+
- enum vga_retrace_method {
-     VGA_RETRACE_DUMB,
-     VGA_RETRACE_PRECISE
-diff --git a/include/hw/virtio/virtio-gpu-bswap.h b/include/hw/virtio/virtio-gpu-bswap.h
-index 203f9e1718..e2bee8f595 100644
---- a/include/hw/virtio/virtio-gpu-bswap.h
-+++ b/include/hw/virtio/virtio-gpu-bswap.h
-@@ -59,4 +59,20 @@ virtio_gpu_t2d_bswap(struct virtio_gpu_transfer_to_host_2d *t2d)
-     le32_to_cpus(&t2d->padding);
- }
- 
-+static inline void
-+virtio_gpu_create_blob_bswap(struct virtio_gpu_resource_create_blob *cblob)
-+{
-+    virtio_gpu_ctrl_hdr_bswap(&cblob->hdr);
-+    le32_to_cpus(&cblob->resource_id);
-+    le32_to_cpus(&cblob->blob_flags);
-+    le64_to_cpus(&cblob->size);
-+}
-+
-+static inline void
-+virtio_gpu_scanout_blob_bswap(struct virtio_gpu_set_scanout_blob *ssb)
-+{
-+    virtio_gpu_bswap_32(ssb, sizeof(*ssb) - sizeof(ssb->offsets[3]));
-+    le32_to_cpus(&ssb->offsets[3]);
-+}
-+
- #endif
-diff --git a/include/hw/virtio/virtio-gpu.h b/include/hw/virtio/virtio-gpu.h
-index fae149235c..bcf54d970f 100644
---- a/include/hw/virtio/virtio-gpu.h
-+++ b/include/hw/virtio/virtio-gpu.h
-@@ -29,7 +29,10 @@ OBJECT_DECLARE_TYPE(VirtIOGPUBase, VirtIOGPUBaseClass,
-                     VIRTIO_GPU_BASE)
- 
- #define TYPE_VIRTIO_GPU "virtio-gpu-device"
--OBJECT_DECLARE_SIMPLE_TYPE(VirtIOGPU, VIRTIO_GPU)
-+OBJECT_DECLARE_TYPE(VirtIOGPU, VirtIOGPUClass, VIRTIO_GPU)
-+
-+#define TYPE_VIRTIO_GPU_GL "virtio-gpu-gl-device"
-+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOGPUGL, VIRTIO_GPU_GL)
- 
- #define TYPE_VHOST_USER_GPU "vhost-user-gpu"
- OBJECT_DECLARE_SIMPLE_TYPE(VhostUserGPU, VHOST_USER_GPU)
-@@ -47,9 +50,23 @@ struct virtio_gpu_simple_resource {
-     uint32_t scanout_bitmask;
-     pixman_image_t *image;
-     uint64_t hostmem;
-+
-+    uint64_t blob_size;
-+    void *blob;
-+    int dmabuf_fd;
-+    uint8_t *remapped;
-+
-     QTAILQ_ENTRY(virtio_gpu_simple_resource) next;
- };
- 
-+struct virtio_gpu_framebuffer {
-+    pixman_format_code_t format;
-+    uint32_t bytes_pp;
-+    uint32_t width, height;
-+    uint32_t stride;
-+    uint32_t offset;
-+};
-+
- struct virtio_gpu_scanout {
-     QemuConsole *con;
-     DisplaySurface *ds;
-@@ -72,6 +89,7 @@ enum virtio_gpu_base_conf_flags {
-     VIRTIO_GPU_FLAG_STATS_ENABLED,
-     VIRTIO_GPU_FLAG_EDID_ENABLED,
-     VIRTIO_GPU_FLAG_DMABUF_ENABLED,
-+    VIRTIO_GPU_FLAG_BLOB_ENABLED,
- };
- 
- #define virtio_gpu_virgl_enabled(_cfg) \
-@@ -82,6 +100,8 @@ enum virtio_gpu_base_conf_flags {
-     (_cfg.flags & (1 << VIRTIO_GPU_FLAG_EDID_ENABLED))
- #define virtio_gpu_dmabuf_enabled(_cfg) \
-     (_cfg.flags & (1 << VIRTIO_GPU_FLAG_DMABUF_ENABLED))
-+#define virtio_gpu_blob_enabled(_cfg) \
-+    (_cfg.flags & (1 << VIRTIO_GPU_FLAG_BLOB_ENABLED))
- 
- struct virtio_gpu_base_conf {
-     uint32_t max_outputs;
-@@ -108,7 +128,6 @@ struct VirtIOGPUBase {
-     struct virtio_gpu_config virtio_config;
-     const GraphicHwOps *hw_ops;
- 
--    bool use_virgl_renderer;
-     int renderer_blocked;
-     int enable;
- 
-@@ -131,6 +150,12 @@ struct VirtIOGPUBaseClass {
-     DEFINE_PROP_UINT32("xres", _state, _conf.xres, 1024), \
-     DEFINE_PROP_UINT32("yres", _state, _conf.yres, 768)
- 
-+typedef struct VGPUDMABuf {
-+    QemuDmaBuf buf;
-+    uint32_t scanout_id;
-+    QTAILQ_ENTRY(VGPUDMABuf) next;
-+} VGPUDMABuf;
-+
- struct VirtIOGPU {
-     VirtIOGPUBase parent_obj;
- 
-@@ -149,8 +174,6 @@ struct VirtIOGPU {
-     uint64_t hostmem;
- 
-     bool processing_cmdq;
--    bool renderer_inited;
--    bool renderer_reset;
-     QEMUTimer *fence_poll;
-     QEMUTimer *print_stats;
- 
-@@ -161,6 +184,28 @@ struct VirtIOGPU {
-         uint32_t req_3d;
-         uint32_t bytes_3d;
-     } stats;
-+
-+    struct {
-+        QTAILQ_HEAD(, VGPUDMABuf) bufs;
-+        VGPUDMABuf *primary;
-+    } dmabuf;
-+};
-+
-+struct VirtIOGPUClass {
-+    VirtIOGPUBaseClass parent;
-+
-+    void (*handle_ctrl)(VirtIODevice *vdev, VirtQueue *vq);
-+    void (*process_cmd)(VirtIOGPU *g, struct virtio_gpu_ctrl_command *cmd);
-+    void (*update_cursor_data)(VirtIOGPU *g,
-+                               struct virtio_gpu_scanout *s,
-+                               uint32_t resource_id);
-+};
-+
-+struct VirtIOGPUGL {
-+    struct VirtIOGPU parent_obj;
-+
-+    bool renderer_inited;
-+    bool renderer_reset;
- };
- 
- struct VhostUserGPU {
-@@ -207,12 +252,28 @@ void virtio_gpu_get_display_info(VirtIOGPU *g,
- void virtio_gpu_get_edid(VirtIOGPU *g,
-                          struct virtio_gpu_ctrl_command *cmd);
- int virtio_gpu_create_mapping_iov(VirtIOGPU *g,
--                                  struct virtio_gpu_resource_attach_backing *ab,
-+                                  uint32_t nr_entries, uint32_t offset,
-                                   struct virtio_gpu_ctrl_command *cmd,
--                                  uint64_t **addr, struct iovec **iov);
-+                                  uint64_t **addr, struct iovec **iov,
-+                                  uint32_t *niov);
- void virtio_gpu_cleanup_mapping_iov(VirtIOGPU *g,
-                                     struct iovec *iov, uint32_t count);
- void virtio_gpu_process_cmdq(VirtIOGPU *g);
-+void virtio_gpu_device_realize(DeviceState *qdev, Error **errp);
-+void virtio_gpu_reset(VirtIODevice *vdev);
-+void virtio_gpu_simple_process_cmd(VirtIOGPU *g, struct virtio_gpu_ctrl_command *cmd);
-+void virtio_gpu_update_cursor_data(VirtIOGPU *g,
-+                                   struct virtio_gpu_scanout *s,
-+                                   uint32_t resource_id);
-+
-+/* virtio-gpu-udmabuf.c */
-+bool virtio_gpu_have_udmabuf(void);
-+void virtio_gpu_init_udmabuf(struct virtio_gpu_simple_resource *res);
-+void virtio_gpu_fini_udmabuf(struct virtio_gpu_simple_resource *res);
-+int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-+                             uint32_t scanout_id,
-+                             struct virtio_gpu_simple_resource *res,
-+                             struct virtio_gpu_framebuffer *fb);
- 
- /* virtio-gpu-3d.c */
- void virtio_gpu_virgl_process_cmd(VirtIOGPU *g,
-diff --git a/include/standard-headers/linux/udmabuf.h b/include/standard-headers/linux/udmabuf.h
-new file mode 100644
-index 0000000000..e19eb5b5ce
---- /dev/null
-+++ b/include/standard-headers/linux/udmabuf.h
-@@ -0,0 +1,32 @@
-+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-+#ifndef _LINUX_UDMABUF_H
-+#define _LINUX_UDMABUF_H
-+
-+#include "standard-headers/linux/types.h"
-+
-+#define UDMABUF_FLAGS_CLOEXEC	0x01
-+
-+struct udmabuf_create {
-+	uint32_t memfd;
-+	uint32_t flags;
-+	uint64_t offset;
-+	uint64_t size;
-+};
-+
-+struct udmabuf_create_item {
-+	uint32_t memfd;
-+	uint32_t __pad;
-+	uint64_t offset;
-+	uint64_t size;
-+};
-+
-+struct udmabuf_create_list {
-+	uint32_t flags;
-+	uint32_t count;
-+	struct udmabuf_create_item list[];
-+};
-+
-+#define UDMABUF_CREATE       _IOW('u', 0x42, struct udmabuf_create)
-+#define UDMABUF_CREATE_LIST  _IOW('u', 0x43, struct udmabuf_create_list)
-+
-+#endif /* _LINUX_UDMABUF_H */
-diff --git a/include/ui/console.h b/include/ui/console.h
-index ca3c7af6a6..b30b63976a 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -471,4 +471,7 @@ bool vnc_display_reload_certs(const char *id,  Error **errp);
- /* input.c */
- int index_from_key(const char *key, size_t key_length);
- 
-+/* udmabuf.c */
-+int udmabuf_fd(void);
-+
- #endif
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 5ae0ad60a6..6e75179404 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -18,12 +18,15 @@
- #include <gdk/gdkwayland.h>
- #endif
- 
-+#include "ui/console.h"
- #include "ui/kbd-state.h"
- #if defined(CONFIG_OPENGL)
- #include "ui/egl-helpers.h"
- #include "ui/egl-context.h"
- #endif
- 
-+#define MAX_VCS 10
-+
- typedef struct GtkDisplayState GtkDisplayState;
- 
- typedef struct VirtualGfxConsole {
-@@ -83,6 +86,60 @@ typedef struct VirtualConsole {
-     };
- } VirtualConsole;
- 
-+struct GtkDisplayState {
-+    GtkWidget *window;
-+
-+    GtkWidget *menu_bar;
-+
-+    GtkAccelGroup *accel_group;
-+
-+    GtkWidget *machine_menu_item;
-+    GtkWidget *machine_menu;
-+    GtkWidget *pause_item;
-+    GtkWidget *reset_item;
-+    GtkWidget *powerdown_item;
-+    GtkWidget *quit_item;
-+
-+    GtkWidget *view_menu_item;
-+    GtkWidget *view_menu;
-+    GtkWidget *full_screen_item;
-+    GtkWidget *copy_item;
-+    GtkWidget *zoom_in_item;
-+    GtkWidget *zoom_out_item;
-+    GtkWidget *zoom_fixed_item;
-+    GtkWidget *zoom_fit_item;
-+    GtkWidget *grab_item;
-+    GtkWidget *grab_on_hover_item;
-+
-+    int nb_vcs;
-+    VirtualConsole vc[MAX_VCS];
-+
-+    GtkWidget *show_tabs_item;
-+    GtkWidget *untabify_item;
-+    GtkWidget *show_menubar_item;
-+
-+    GtkWidget *vbox;
-+    GtkWidget *notebook;
-+    int button_mask;
-+    gboolean last_set;
-+    int last_x;
-+    int last_y;
-+    int grab_x_root;
-+    int grab_y_root;
-+    VirtualConsole *kbd_owner;
-+    VirtualConsole *ptr_owner;
-+
-+    gboolean full_screen;
-+
-+    GdkCursor *null_cursor;
-+    Notifier mouse_mode_notifier;
-+    gboolean free_scale;
-+
-+    bool external_pause_update;
-+
-+    DisplayOptions *opts;
-+};
-+
- extern bool gtk_use_gl_area;
- 
- /* ui/gtk.c */
-diff --git a/include/ui/qemu-pixman.h b/include/ui/qemu-pixman.h
-index 87737a6f16..806ddcd7cd 100644
---- a/include/ui/qemu-pixman.h
-+++ b/include/ui/qemu-pixman.h
-@@ -62,6 +62,7 @@ typedef struct PixelFormat {
- PixelFormat qemu_pixelformat_from_pixman(pixman_format_code_t format);
- pixman_format_code_t qemu_default_pixman_format(int bpp, bool native_endian);
- pixman_format_code_t qemu_drm_format_to_pixman(uint32_t drm_format);
-+uint32_t qemu_pixman_to_drm_format(pixman_format_code_t pixman);
- int qemu_pixman_get_type(int rshift, int gshift, int bshift);
- pixman_format_code_t qemu_pixman_get_format(PixelFormat *pf);
- bool qemu_pixman_check_format(DisplayChangeListener *dcl,
-diff --git a/meson.build b/meson.build
-index c6f4b0cf5e..396b2bf9b6 100644
---- a/meson.build
-+++ b/meson.build
-@@ -1883,7 +1883,7 @@ util_ss.add_all(trace_ss)
- util_ss = util_ss.apply(config_all, strict: false)
- libqemuutil = static_library('qemuutil',
-                              sources: util_ss.sources() + stub_ss.sources() + genh,
--                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc])
-+                             dependencies: [util_ss.dependencies(), m, glib, socket, malloc, pixman])
- qemuutil = declare_dependency(link_with: libqemuutil,
-                               sources: genh + version_res)
- 
-diff --git a/scripts/update-linux-headers.sh b/scripts/update-linux-headers.sh
-index 1050e36169..fea4d6eb65 100755
---- a/scripts/update-linux-headers.sh
-+++ b/scripts/update-linux-headers.sh
-@@ -34,6 +34,7 @@ cp_portable() {
-     if
-         grep '#include' "$f" | grep -v -e 'linux/virtio' \
-                                      -e 'linux/types' \
-+                                     -e 'linux/ioctl' \
-                                      -e 'stdint' \
-                                      -e 'linux/if_ether' \
-                                      -e 'input-event-codes' \
-@@ -66,6 +67,7 @@ cp_portable() {
-         -e 's/__BITS_PER_LONG/HOST_LONG_BITS/' \
-         -e '/\"drm.h\"/d' \
-         -e '/sys\/ioctl.h/d' \
-+        -e '/linux\/ioctl.h/d' \
-         -e 's/SW_MAX/SW_MAX_/' \
-         -e 's/atomic_t/int/' \
-         -e 's/__kernel_long_t/long/' \
-@@ -190,6 +192,7 @@ for i in "$tmpdir"/include/linux/*virtio*.h \
-          "$tmpdir/include/linux/fuse.h" \
-          "$tmpdir/include/linux/input.h" \
-          "$tmpdir/include/linux/input-event-codes.h" \
-+         "$tmpdir/include/linux/udmabuf.h" \
-          "$tmpdir/include/linux/pci_regs.h" \
-          "$tmpdir/include/linux/ethtool.h" \
-          "$tmpdir/include/linux/const.h" \
-diff --git a/stubs/meson.build b/stubs/meson.build
-index be6f6d609e..9f64f49101 100644
---- a/stubs/meson.build
-+++ b/stubs/meson.build
-@@ -51,6 +51,7 @@ endif
- if have_system
-   stub_ss.add(files('semihost.c'))
-   stub_ss.add(files('xen-hw-stub.c'))
-+  stub_ss.add(files('virtio-gpu-udmabuf.c'))
- else
-   stub_ss.add(files('qdev.c'))
- endif
-diff --git a/stubs/virtio-gpu-udmabuf.c b/stubs/virtio-gpu-udmabuf.c
-new file mode 100644
-index 0000000000..81f661441a
---- /dev/null
-+++ b/stubs/virtio-gpu-udmabuf.c
-@@ -0,0 +1,27 @@
-+#include "qemu/osdep.h"
-+#include "hw/virtio/virtio-gpu.h"
-+
-+bool virtio_gpu_have_udmabuf(void)
-+{
-+    /* nothing (stub) */
-+    return false;
-+}
-+
-+void virtio_gpu_init_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    /* nothing (stub) */
-+}
-+
-+void virtio_gpu_fini_udmabuf(struct virtio_gpu_simple_resource *res)
-+{
-+    /* nothing (stub) */
-+}
-+
-+int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-+                             uint32_t scanout_id,
-+                             struct virtio_gpu_simple_resource *res,
-+                             struct virtio_gpu_framebuffer *fb)
-+{
-+    /* nothing (stub) */
-+    return 0;
-+}
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 77353a620d..3deefc6d95 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -60,7 +60,6 @@
- #include "chardev/char.h"
- #include "qom/object.h"
- 
--#define MAX_VCS 10
- #define VC_WINDOW_X_MIN  320
- #define VC_WINDOW_Y_MIN  240
- #define VC_TERM_X_MIN     80
-@@ -119,60 +118,6 @@
- static const guint16 *keycode_map;
- static size_t keycode_maplen;
- 
--struct GtkDisplayState {
--    GtkWidget *window;
--
--    GtkWidget *menu_bar;
--
--    GtkAccelGroup *accel_group;
--
--    GtkWidget *machine_menu_item;
--    GtkWidget *machine_menu;
--    GtkWidget *pause_item;
--    GtkWidget *reset_item;
--    GtkWidget *powerdown_item;
--    GtkWidget *quit_item;
--
--    GtkWidget *view_menu_item;
--    GtkWidget *view_menu;
--    GtkWidget *full_screen_item;
--    GtkWidget *copy_item;
--    GtkWidget *zoom_in_item;
--    GtkWidget *zoom_out_item;
--    GtkWidget *zoom_fixed_item;
--    GtkWidget *zoom_fit_item;
--    GtkWidget *grab_item;
--    GtkWidget *grab_on_hover_item;
--
--    int nb_vcs;
--    VirtualConsole vc[MAX_VCS];
--
--    GtkWidget *show_tabs_item;
--    GtkWidget *untabify_item;
--    GtkWidget *show_menubar_item;
--
--    GtkWidget *vbox;
--    GtkWidget *notebook;
--    int button_mask;
--    gboolean last_set;
--    int last_x;
--    int last_y;
--    int grab_x_root;
--    int grab_y_root;
--    VirtualConsole *kbd_owner;
--    VirtualConsole *ptr_owner;
--
--    gboolean full_screen;
--
--    GdkCursor *null_cursor;
--    Notifier mouse_mode_notifier;
--    gboolean free_scale;
--
--    bool external_pause_update;
--
--    DisplayOptions *opts;
--};
--
- struct VCChardev {
-     Chardev parent;
-     VirtualConsole *console;
-diff --git a/ui/meson.build b/ui/meson.build
-index e8d3ff41b9..7a709ff548 100644
---- a/ui/meson.build
-+++ b/ui/meson.build
-@@ -11,6 +11,7 @@ softmmu_ss.add(files(
-   'kbd-state.c',
-   'keymaps.c',
-   'qemu-pixman.c',
-+  'udmabuf.c',
- ))
- softmmu_ss.add([spice_headers, files('spice-module.c')])
- 
-diff --git a/ui/qemu-pixman.c b/ui/qemu-pixman.c
-index 85f2945e88..3ab7e2e958 100644
---- a/ui/qemu-pixman.c
-+++ b/ui/qemu-pixman.c
-@@ -89,21 +89,34 @@ pixman_format_code_t qemu_default_pixman_format(int bpp, bool native_endian)
- }
- 
- /* Note: drm is little endian, pixman is native endian */
-+static const struct {
-+    uint32_t drm_format;
-+    pixman_format_code_t pixman_format;
-+} drm_format_pixman_map[] = {
-+    { DRM_FORMAT_RGB888,   PIXMAN_LE_r8g8b8   },
-+    { DRM_FORMAT_ARGB8888, PIXMAN_LE_a8r8g8b8 },
-+    { DRM_FORMAT_XRGB8888, PIXMAN_LE_x8r8g8b8 }
-+};
-+
- pixman_format_code_t qemu_drm_format_to_pixman(uint32_t drm_format)
- {
--    static const struct {
--        uint32_t drm_format;
--        pixman_format_code_t pixman;
--    } map[] = {
--        { DRM_FORMAT_RGB888,   PIXMAN_LE_r8g8b8   },
--        { DRM_FORMAT_ARGB8888, PIXMAN_LE_a8r8g8b8 },
--        { DRM_FORMAT_XRGB8888, PIXMAN_LE_x8r8g8b8 }
--    };
-     int i;
- 
--    for (i = 0; i < ARRAY_SIZE(map); i++) {
--        if (drm_format == map[i].drm_format) {
--            return map[i].pixman;
-+    for (i = 0; i < ARRAY_SIZE(drm_format_pixman_map); i++) {
-+        if (drm_format == drm_format_pixman_map[i].drm_format) {
-+            return drm_format_pixman_map[i].pixman_format;
-+        }
-+    }
-+    return 0;
-+}
-+
-+uint32_t qemu_pixman_to_drm_format(pixman_format_code_t pixman_format)
-+{
-+    int i;
-+
-+    for (i = 0; i < ARRAY_SIZE(drm_format_pixman_map); i++) {
-+        if (pixman_format == drm_format_pixman_map[i].pixman_format) {
-+            return drm_format_pixman_map[i].drm_format;
-         }
-     }
-     return 0;
-diff --git a/ui/udmabuf.c b/ui/udmabuf.c
-new file mode 100644
-index 0000000000..23abe1e7eb
---- /dev/null
-+++ b/ui/udmabuf.c
-@@ -0,0 +1,40 @@
-+/*
-+ * udmabuf helper functions.
-+ *
-+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
-+ * See the COPYING file in the top-level directory.
-+ */
-+#include "qemu/osdep.h"
-+#include "qapi/error.h"
-+#include "ui/console.h"
-+
-+#ifdef CONFIG_LINUX
-+
-+#include <fcntl.h>
-+#include <sys/ioctl.h>
-+
-+int udmabuf_fd(void)
-+{
-+    static bool first = true;
-+    static int udmabuf;
-+
-+    if (!first) {
-+        return udmabuf;
-+    }
-+    first = false;
-+
-+    udmabuf = open("/dev/udmabuf", O_RDWR);
-+    if (udmabuf < 0) {
-+        warn_report("open /dev/udmabuf: %s", strerror(errno));
-+    }
-+    return udmabuf;
-+}
-+
-+#else
-+
-+int udmabuf_fd(void)
-+{
-+    return -1;
-+}
-+
-+#endif
-diff --git a/util/module.c b/util/module.c
-index 7661d0f623..eee8ff2de1 100644
---- a/util/module.c
-+++ b/util/module.c
-@@ -182,6 +182,10 @@ static const struct {
-     { "ui-spice-app",   "ui-spice-core" },
-     { "ui-spice-app",   "chardev-spice" },
- 
-+    { "hw-display-virtio-gpu-gl", "hw-display-virtio-gpu" },
-+    { "hw-display-virtio-gpu-pci-gl", "hw-display-virtio-gpu-pci" },
-+    { "hw-display-virtio-vga-gl", "hw-display-virtio-vga" },
-+
- #ifdef CONFIG_OPENGL
-     { "ui-egl-headless", "ui-opengl"    },
-     { "ui-gtk",          "ui-opengl"    },
-@@ -301,13 +305,16 @@ static struct {
-     { "qxl-vga",               "hw-", "display-qxl"           },
-     { "qxl",                   "hw-", "display-qxl"           },
-     { "virtio-gpu-device",     "hw-", "display-virtio-gpu"    },
-+    { "virtio-gpu-gl-device",  "hw-", "display-virtio-gpu-gl" },
-     { "vhost-user-gpu",        "hw-", "display-virtio-gpu"    },
-     { "virtio-gpu-pci-base",   "hw-", "display-virtio-gpu-pci" },
-     { "virtio-gpu-pci",        "hw-", "display-virtio-gpu-pci" },
-+    { "virtio-gpu-gl-pci",     "hw-", "display-virtio-gpu-pci-gl" },
-     { "vhost-user-gpu-pci",    "hw-", "display-virtio-gpu-pci" },
-     { "virtio-gpu-ccw",        "hw-", "s390x-virtio-gpu-ccw"   },
-     { "virtio-vga-base",       "hw-", "display-virtio-vga"    },
-     { "virtio-vga",            "hw-", "display-virtio-vga"    },
-+    { "virtio-vga-gl",         "hw-", "display-virtio-vga-gl" },
-     { "vhost-user-vga",        "hw-", "display-virtio-vga"    },
-     { "chardev-braille",       "chardev-", "baum"             },
-     { "chardev-spicevmc",      "chardev-", "spice"            },
--- 
-2.17.1
-
diff --git a/host/qemu/0006-ui-gtk-Create-a-common-release_dmabuf-helper.patch b/host/qemu/0006-ui-gtk-Create-a-common-release_dmabuf-helper.patch
deleted file mode 100644
index da72a19..0000000
--- a/host/qemu/0006-ui-gtk-Create-a-common-release_dmabuf-helper.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Date: Tue, 11 May 2021 00:51:12 -0700
-Subject: [PATCH] ui/gtk: Create a common release_dmabuf helper
-
-Since the texture release mechanism is same for both gtk-egl
-and gtk-glarea, move the helper from gtk-egl to common gtk
-code so that it can be shared by both gtk backends.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Reviewed-by: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
----
- include/ui/gtk.h |  2 --
- ui/gtk-egl.c     |  8 --------
- ui/gtk.c         | 11 ++++++++++-
- 3 files changed, 10 insertions(+), 11 deletions(-)
-
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 6e75179404..75b56d92e5 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -171,8 +171,6 @@ void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
-                           uint32_t hot_x, uint32_t hot_y);
- void gd_egl_cursor_position(DisplayChangeListener *dcl,
-                             uint32_t pos_x, uint32_t pos_y);
--void gd_egl_release_dmabuf(DisplayChangeListener *dcl,
--                           QemuDmaBuf *dmabuf);
- void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-                           uint32_t x, uint32_t y, uint32_t w, uint32_t h);
- void gtk_egl_init(DisplayGLMode mode);
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 2a2e6d3a17..b671181272 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -249,14 +249,6 @@ void gd_egl_cursor_position(DisplayChangeListener *dcl,
-     vc->gfx.cursor_y = pos_y * vc->gfx.scale_y;
- }
- 
--void gd_egl_release_dmabuf(DisplayChangeListener *dcl,
--                           QemuDmaBuf *dmabuf)
--{
--#ifdef CONFIG_GBM
--    egl_dmabuf_release_texture(dmabuf);
--#endif
--}
--
- void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-                           uint32_t x, uint32_t y, uint32_t w, uint32_t h)
- {
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 3deefc6d95..1bf6c128dc 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -575,6 +575,14 @@ static bool gd_has_dmabuf(DisplayChangeListener *dcl)
-     return vc->gfx.has_dmabuf;
- }
- 
-+static void gd_gl_release_dmabuf(DisplayChangeListener *dcl,
-+                                 QemuDmaBuf *dmabuf)
-+{
-+#ifdef CONFIG_GBM
-+    egl_dmabuf_release_texture(dmabuf);
-+#endif
-+}
-+
- /** DisplayState Callbacks (opengl version) **/
- 
- static const DisplayChangeListenerOps dcl_gl_area_ops = {
-@@ -593,6 +601,7 @@ static const DisplayChangeListenerOps dcl_gl_area_ops = {
-     .dpy_gl_scanout_disable  = gd_gl_area_scanout_disable,
-     .dpy_gl_update           = gd_gl_area_scanout_flush,
-     .dpy_gl_scanout_dmabuf   = gd_gl_area_scanout_dmabuf,
-+    .dpy_gl_release_dmabuf   = gd_gl_release_dmabuf,
-     .dpy_has_dmabuf          = gd_has_dmabuf,
- };
- 
-@@ -615,8 +624,8 @@ static const DisplayChangeListenerOps dcl_egl_ops = {
-     .dpy_gl_scanout_dmabuf   = gd_egl_scanout_dmabuf,
-     .dpy_gl_cursor_dmabuf    = gd_egl_cursor_dmabuf,
-     .dpy_gl_cursor_position  = gd_egl_cursor_position,
--    .dpy_gl_release_dmabuf   = gd_egl_release_dmabuf,
-     .dpy_gl_update           = gd_egl_scanout_flush,
-+    .dpy_gl_release_dmabuf   = gd_gl_release_dmabuf,
-     .dpy_has_dmabuf          = gd_has_dmabuf,
- };
- 
--- 
-2.17.1
-
diff --git a/host/qemu/0007-ui-egl-Add-egl-helpers-to-help-with-synchronization.patch b/host/qemu/0007-ui-egl-Add-egl-helpers-to-help-with-synchronization.patch
deleted file mode 100644
index 52b9c49..0000000
--- a/host/qemu/0007-ui-egl-Add-egl-helpers-to-help-with-synchronization.patch
+++ /dev/null
@@ -1,82 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Date: Tue, 11 May 2021 00:32:26 -0700
-Subject: [PATCH] ui/egl: Add egl helpers to help with synchronization
-
-These egl helpers would be used for creating and waiting on
-a sync object.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
----
- include/ui/console.h     |  2 ++
- include/ui/egl-helpers.h |  2 ++
- ui/egl-helpers.c         | 26 ++++++++++++++++++++++++++
- 3 files changed, 30 insertions(+)
-
-diff --git a/include/ui/console.h b/include/ui/console.h
-index b30b63976a..49978fdae3 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -168,6 +168,8 @@ typedef struct QemuDmaBuf {
-     uint64_t  modifier;
-     uint32_t  texture;
-     bool      y0_top;
-+    void      *sync;
-+    int       fence_fd;
- } QemuDmaBuf;
- 
- typedef struct DisplayState DisplayState;
-diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
-index f1bf8f97fc..2c3ba92b53 100644
---- a/include/ui/egl-helpers.h
-+++ b/include/ui/egl-helpers.h
-@@ -45,6 +45,8 @@ int egl_get_fd_for_texture(uint32_t tex_id, EGLint *stride, EGLint *fourcc,
- 
- void egl_dmabuf_import_texture(QemuDmaBuf *dmabuf);
- void egl_dmabuf_release_texture(QemuDmaBuf *dmabuf);
-+void egl_dmabuf_create_sync(QemuDmaBuf *dmabuf);
-+void egl_dmabuf_create_fence(QemuDmaBuf *dmabuf);
- 
- #endif
- 
-diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
-index 6d0cb2b5cb..6fa3f2ec45 100644
---- a/ui/egl-helpers.c
-+++ b/ui/egl-helpers.c
-@@ -76,6 +76,32 @@ void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
-                               GL_TEXTURE_2D, fb->texture, 0);
- }
- 
-+void egl_dmabuf_create_sync(QemuDmaBuf *dmabuf)
-+{
-+    EGLSyncKHR sync;
-+
-+    if (epoxy_has_egl_extension(qemu_egl_display,
-+                                "EGL_KHR_fence_sync") &&
-+        epoxy_has_egl_extension(qemu_egl_display,
-+                                "EGL_ANDROID_native_fence_sync")) {
-+        sync = eglCreateSyncKHR(qemu_egl_display,
-+				EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
-+        if (sync != EGL_NO_SYNC_KHR) {
-+            dmabuf->sync = sync;
-+        }
-+    }
-+}
-+
-+void egl_dmabuf_create_fence(QemuDmaBuf *dmabuf)
-+{
-+    if (dmabuf->sync) {
-+        dmabuf->fence_fd = eglDupNativeFenceFDANDROID(qemu_egl_display,
-+                                                      dmabuf->sync);
-+        eglDestroySyncKHR(qemu_egl_display, dmabuf->sync);
-+        dmabuf->sync = NULL;
-+    }
-+}
-+
- void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
- {
-     GLuint texture;
--- 
-2.17.1
-
diff --git a/host/qemu/0008-ui-Create-sync-objects-and-fences-only-for-blobs.patch b/host/qemu/0008-ui-Create-sync-objects-and-fences-only-for-blobs.patch
deleted file mode 100644
index 93df1ef..0000000
--- a/host/qemu/0008-ui-Create-sync-objects-and-fences-only-for-blobs.patch
+++ /dev/null
@@ -1,230 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Date: Mon, 7 Jun 2021 14:45:55 -0700
-Subject: [PATCH] ui: Create sync objects and fences only for blobs
-
-Create sync objects and fences only for dmabufs that are blobs. Once a
-fence is created (after glFlush) and is signalled,
-graphic_hw_gl_flushed() will be called and virtio-gpu cmd processing
-will be resumed.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
----
- hw/display/virtio-gpu-udmabuf.c |  1 +
- include/ui/console.h            |  1 +
- include/ui/egl-helpers.h        |  1 +
- include/ui/gtk.h                |  1 +
- ui/gtk-egl.c                    | 20 ++++++++++++++++++++
- ui/gtk-gl-area.c                | 20 ++++++++++++++++++++
- ui/gtk.c                        | 13 +++++++++++++
- 7 files changed, 57 insertions(+)
-
-diff --git a/hw/display/virtio-gpu-udmabuf.c b/hw/display/virtio-gpu-udmabuf.c
-index 3c01a415e7..632ba06cbc 100644
---- a/hw/display/virtio-gpu-udmabuf.c
-+++ b/hw/display/virtio-gpu-udmabuf.c
-@@ -185,6 +185,7 @@ static VGPUDMABuf
-     dmabuf->buf.stride = fb->stride;
-     dmabuf->buf.fourcc = qemu_pixman_to_drm_format(fb->format);
-     dmabuf->buf.fd = res->dmabuf_fd;
-+    dmabuf->buf.blob = true;
- 
-     dmabuf->scanout_id = scanout_id;
-     QTAILQ_INSERT_HEAD(&g->dmabuf.bufs, dmabuf, next);
-diff --git a/include/ui/console.h b/include/ui/console.h
-index 49978fdae3..570d827644 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -170,6 +170,7 @@ typedef struct QemuDmaBuf {
-     bool      y0_top;
-     void      *sync;
-     int       fence_fd;
-+    bool      blob;
- } QemuDmaBuf;
- 
- typedef struct DisplayState DisplayState;
-diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
-index 2c3ba92b53..2fb6e0dd6b 100644
---- a/include/ui/egl-helpers.h
-+++ b/include/ui/egl-helpers.h
-@@ -19,6 +19,7 @@ typedef struct egl_fb {
-     GLuint texture;
-     GLuint framebuffer;
-     bool delete_texture;
-+    QemuDmaBuf *dmabuf;
- } egl_fb;
- 
- void egl_fb_destroy(egl_fb *fb);
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 75b56d92e5..83ea872d1d 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -145,6 +145,7 @@ extern bool gtk_use_gl_area;
- /* ui/gtk.c */
- void gd_update_windowsize(VirtualConsole *vc);
- int gd_monitor_update_interval(GtkWidget *widget);
-+void gd_hw_gl_flushed(void *vc);
- 
- /* ui/gtk-egl.c */
- void gd_egl_init(VirtualConsole *vc);
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index b671181272..f530bcd940 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -12,6 +12,7 @@
-  */
- 
- #include "qemu/osdep.h"
-+#include "qemu/main-loop.h"
- 
- #include "trace.h"
- 
-@@ -63,6 +64,7 @@ void gd_egl_draw(VirtualConsole *vc)
- {
-     GdkWindow *window;
-     int ww, wh;
-+    QemuDmaBuf *dmabuf = vc->gfx.guest_fb.dmabuf;
- 
-     if (!vc->gfx.gls) {
-         return;
-@@ -94,6 +96,14 @@ void gd_egl_draw(VirtualConsole *vc)
-     }
- 
-     glFlush();
-+    if (dmabuf) {
-+        egl_dmabuf_create_fence(dmabuf);
-+        if (dmabuf->fence_fd > 0) {
-+            qemu_set_fd_handler(dmabuf->fence_fd, gd_hw_gl_flushed, NULL, vc);
-+            return;
-+        }
-+        graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+    }
-     graphic_hw_gl_flushed(vc->gfx.dcl.con);
- }
- 
-@@ -209,6 +219,8 @@ void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                            QemuDmaBuf *dmabuf)
- {
- #ifdef CONFIG_GBM
-+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-+
-     egl_dmabuf_import_texture(dmabuf);
-     if (!dmabuf->texture) {
-         return;
-@@ -217,6 +229,10 @@ void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-     gd_egl_scanout_texture(dcl, dmabuf->texture,
-                            false, dmabuf->width, dmabuf->height,
-                            0, 0, dmabuf->width, dmabuf->height);
-+
-+    if (dmabuf->blob) {
-+        vc->gfx.guest_fb.dmabuf = dmabuf;
-+    }
- #endif
- }
- 
-@@ -281,6 +297,10 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-         egl_fb_blit(&vc->gfx.win_fb, &vc->gfx.guest_fb, !vc->gfx.y0_top);
-     }
- 
-+    if (vc->gfx.guest_fb.dmabuf) {
-+        egl_dmabuf_create_sync(vc->gfx.guest_fb.dmabuf);
-+    }
-+
-     eglSwapBuffers(qemu_egl_display, vc->gfx.esurface);
- }
- 
-diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
-index dd5783fec7..091194789e 100644
---- a/ui/gtk-gl-area.c
-+++ b/ui/gtk-gl-area.c
-@@ -8,6 +8,7 @@
-  */
- 
- #include "qemu/osdep.h"
-+#include "qemu/main-loop.h"
- 
- #include "trace.h"
- 
-@@ -38,6 +39,7 @@ static void gtk_gl_area_set_scanout_mode(VirtualConsole *vc, bool scanout)
- void gd_gl_area_draw(VirtualConsole *vc)
- {
-     int ww, wh, y1, y2;
-+    QemuDmaBuf *dmabuf = vc->gfx.guest_fb.dmabuf;
- 
-     if (!vc->gfx.gls) {
-         return;
-@@ -71,7 +73,18 @@ void gd_gl_area_draw(VirtualConsole *vc)
-         surface_gl_render_texture(vc->gfx.gls, vc->gfx.ds);
-     }
- 
-+    if (dmabuf) {
-+        egl_dmabuf_create_sync(dmabuf);
-+    }
-     glFlush();
-+    if (dmabuf) {
-+        egl_dmabuf_create_fence(dmabuf);
-+        if (dmabuf->fence_fd > 0) {
-+            qemu_set_fd_handler(dmabuf->fence_fd, gd_hw_gl_flushed, NULL, vc);
-+            return;
-+        }
-+        graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+    }
-     graphic_hw_gl_flushed(vc->gfx.dcl.con);
- }
- 
-@@ -213,6 +226,9 @@ void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
- {
-     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
- 
-+    if (vc->gfx.guest_fb.dmabuf) {
-+        graphic_hw_gl_block(vc->gfx.dcl.con, true);
-+    }
-     gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
- }
- 
-@@ -231,6 +247,10 @@ void gd_gl_area_scanout_dmabuf(DisplayChangeListener *dcl,
-     gd_gl_area_scanout_texture(dcl, dmabuf->texture,
-                                false, dmabuf->width, dmabuf->height,
-                                0, 0, dmabuf->width, dmabuf->height);
-+
-+    if (dmabuf->blob) {
-+        vc->gfx.guest_fb.dmabuf = dmabuf;
-+    }
- #endif
- }
- 
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 1bf6c128dc..6279fad0ce 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -36,6 +36,7 @@
- #include "qapi/qapi-commands-machine.h"
- #include "qapi/qapi-commands-misc.h"
- #include "qemu/cutils.h"
-+#include "qemu/main-loop.h"
- 
- #include "ui/console.h"
- #include "ui/gtk.h"
-@@ -583,6 +584,18 @@ static void gd_gl_release_dmabuf(DisplayChangeListener *dcl,
- #endif
- }
- 
-+void gd_hw_gl_flushed(void *vcon)
-+{
-+    VirtualConsole *vc = vcon;
-+    QemuDmaBuf *dmabuf = vc->gfx.guest_fb.dmabuf;
-+
-+    graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+    graphic_hw_gl_flushed(vc->gfx.dcl.con);
-+    qemu_set_fd_handler(dmabuf->fence_fd, NULL, NULL, NULL);
-+    close(dmabuf->fence_fd);
-+    dmabuf->fence_fd = -1;
-+}
-+
- /** DisplayState Callbacks (opengl version) **/
- 
- static const DisplayChangeListenerOps dcl_gl_area_ops = {
--- 
-2.17.1
-
diff --git a/host/qemu/0009-ui-gtk-egl-Wait-for-the-draw-signal-for-dmabuf-blobs.patch b/host/qemu/0009-ui-gtk-egl-Wait-for-the-draw-signal-for-dmabuf-blobs.patch
deleted file mode 100644
index 09fed4f..0000000
--- a/host/qemu/0009-ui-gtk-egl-Wait-for-the-draw-signal-for-dmabuf-blobs.patch
+++ /dev/null
@@ -1,71 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Date: Tue, 11 May 2021 00:45:34 -0700
-Subject: [PATCH] ui/gtk-egl: Wait for the draw signal for dmabuf blobs
-
-Instead of immediately drawing and submitting, queue and wait
-for the draw signal if the dmabuf submitted is a blob.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
----
- include/ui/gtk.h |  2 ++
- ui/gtk-egl.c     | 15 +++++++++++++++
- ui/gtk.c         |  2 +-
- 3 files changed, 18 insertions(+), 1 deletion(-)
-
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 83ea872d1d..074ad4466f 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -172,6 +172,8 @@ void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
-                           uint32_t hot_x, uint32_t hot_y);
- void gd_egl_cursor_position(DisplayChangeListener *dcl,
-                             uint32_t pos_x, uint32_t pos_y);
-+void gd_egl_flush(DisplayChangeListener *dcl,
-+                  uint32_t x, uint32_t y, uint32_t w, uint32_t h);
- void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-                           uint32_t x, uint32_t y, uint32_t w, uint32_t h);
- void gtk_egl_init(DisplayGLMode mode);
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index f530bcd940..3c7eb244b4 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -304,6 +304,21 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-     eglSwapBuffers(qemu_egl_display, vc->gfx.esurface);
- }
- 
-+void gd_egl_flush(DisplayChangeListener *dcl,
-+                  uint32_t x, uint32_t y, uint32_t w, uint32_t h)
-+{
-+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-+    GtkWidget *area = vc->gfx.drawing_area;
-+
-+    if (vc->gfx.guest_fb.dmabuf) {
-+        graphic_hw_gl_block(vc->gfx.dcl.con, true);
-+        gtk_widget_queue_draw_area(area, x, y, w, h);
-+        return;
-+    }
-+
-+    gd_egl_scanout_flush(&vc->gfx.dcl, x, y, w, h);
-+}
-+
- void gtk_egl_init(DisplayGLMode mode)
- {
-     GdkDisplay *gdk_display = gdk_display_get_default();
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 6279fad0ce..cf4882b25a 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -637,7 +637,7 @@ static const DisplayChangeListenerOps dcl_egl_ops = {
-     .dpy_gl_scanout_dmabuf   = gd_egl_scanout_dmabuf,
-     .dpy_gl_cursor_dmabuf    = gd_egl_cursor_dmabuf,
-     .dpy_gl_cursor_position  = gd_egl_cursor_position,
--    .dpy_gl_update           = gd_egl_scanout_flush,
-+    .dpy_gl_update           = gd_egl_flush,
-     .dpy_gl_release_dmabuf   = gd_gl_release_dmabuf,
-     .dpy_has_dmabuf          = gd_has_dmabuf,
- };
--- 
-2.17.1
-
diff --git a/host/qemu/0010-virtio-gpu-Add-gl_flushed-callback.patch b/host/qemu/0010-virtio-gpu-Add-gl_flushed-callback.patch
deleted file mode 100644
index 98842cc..0000000
--- a/host/qemu/0010-virtio-gpu-Add-gl_flushed-callback.patch
+++ /dev/null
@@ -1,79 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Date: Mon, 10 May 2021 16:41:59 -0700
-Subject: [PATCH] virtio-gpu: Add gl_flushed callback
-
-Adding this callback provides a way to resume the processing of
-cmds in fenceq and cmdq that were not processed because the UI
-was waiting on a fence and blocked cmd processing.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>
----
- hw/display/virtio-gpu.c | 32 ++++++++++++++++++++++++++++++--
- 1 file changed, 30 insertions(+), 2 deletions(-)
-
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index e183f4ecda..3fcd44ac5e 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -991,8 +991,10 @@ void virtio_gpu_simple_process_cmd(VirtIOGPU *g,
-         break;
-     }
-     if (!cmd->finished) {
--        virtio_gpu_ctrl_response_nodata(g, cmd, cmd->error ? cmd->error :
--                                        VIRTIO_GPU_RESP_OK_NODATA);
-+        if (!g->parent_obj.renderer_blocked) {
-+            virtio_gpu_ctrl_response_nodata(g, cmd, cmd->error ? cmd->error :
-+                                            VIRTIO_GPU_RESP_OK_NODATA);
-+        }
-     }
- }
- 
-@@ -1048,6 +1050,30 @@ void virtio_gpu_process_cmdq(VirtIOGPU *g)
-     g->processing_cmdq = false;
- }
- 
-+static void virtio_gpu_process_fenceq(VirtIOGPU *g)
-+{
-+    struct virtio_gpu_ctrl_command *cmd, *tmp;
-+
-+    QTAILQ_FOREACH_SAFE(cmd, &g->fenceq, next, tmp) {
-+        trace_virtio_gpu_fence_resp(cmd->cmd_hdr.fence_id);
-+        virtio_gpu_ctrl_response_nodata(g, cmd, VIRTIO_GPU_RESP_OK_NODATA);
-+        QTAILQ_REMOVE(&g->fenceq, cmd, next);
-+        g_free(cmd);
-+        g->inflight--;
-+        if (virtio_gpu_stats_enabled(g->parent_obj.conf)) {
-+            fprintf(stderr, "inflight: %3d (-)\r", g->inflight);
-+        }
-+    }
-+}
-+
-+static void virtio_gpu_handle_gl_flushed(VirtIOGPUBase *b)
-+{
-+    VirtIOGPU *g = container_of(b, VirtIOGPU, parent_obj);
-+
-+    virtio_gpu_process_fenceq(g);
-+    virtio_gpu_process_cmdq(g);
-+}
-+
- static void virtio_gpu_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
- {
-     VirtIOGPU *g = VIRTIO_GPU(vdev);
-@@ -1406,10 +1432,12 @@ static void virtio_gpu_class_init(ObjectClass *klass, void *data)
-     DeviceClass *dc = DEVICE_CLASS(klass);
-     VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
-     VirtIOGPUClass *vgc = VIRTIO_GPU_CLASS(klass);
-+    VirtIOGPUBaseClass *vgbc = &vgc->parent;
- 
-     vgc->handle_ctrl = virtio_gpu_handle_ctrl;
-     vgc->process_cmd = virtio_gpu_simple_process_cmd;
-     vgc->update_cursor_data = virtio_gpu_update_cursor_data;
-+    vgbc->gl_flushed = virtio_gpu_handle_gl_flushed;
- 
-     vdc->realize = virtio_gpu_device_realize;
-     vdc->reset = virtio_gpu_reset;
--- 
-2.17.1
-
diff --git a/host/qemu/0011-ui-gtk-skip-any-extra-draw-of-same-guest-scanout-blo.patch b/host/qemu/0011-ui-gtk-skip-any-extra-draw-of-same-guest-scanout-blo.patch
deleted file mode 100644
index b5da8a4..0000000
--- a/host/qemu/0011-ui-gtk-skip-any-extra-draw-of-same-guest-scanout-blo.patch
+++ /dev/null
@@ -1,135 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Fri, 25 Jun 2021 09:57:31 -0700
-Subject: [PATCH] ui/gtk: skip any extra draw of same guest scanout blob res
-
-Any extra gd_egl_draw of same blob resource representing guest
-scanout before the previous drawing is not finished can break
-synchronous draw sequence so it needs to be skipped or blocked.
-
-v2: mutex to protect critical section where draw_submitted flag is
-    checked and modified.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- hw/display/virtio-gpu-udmabuf.c |  3 +++
- include/ui/console.h            |  3 +++
- ui/gtk-egl.c                    | 15 +++++++++++++++
- ui/gtk-gl-area.c                |  9 +++++++++
- 4 files changed, 30 insertions(+)
-
-diff --git a/hw/display/virtio-gpu-udmabuf.c b/hw/display/virtio-gpu-udmabuf.c
-index 632ba06cbc..29793f5317 100644
---- a/hw/display/virtio-gpu-udmabuf.c
-+++ b/hw/display/virtio-gpu-udmabuf.c
-@@ -186,6 +186,9 @@ static VGPUDMABuf
-     dmabuf->buf.fourcc = qemu_pixman_to_drm_format(fb->format);
-     dmabuf->buf.fd = res->dmabuf_fd;
-     dmabuf->buf.blob = true;
-+    dmabuf->buf.draw_submitted = false;
-+
-+    qemu_mutex_init(&dmabuf->buf.mutex);
- 
-     dmabuf->scanout_id = scanout_id;
-     QTAILQ_INSERT_HEAD(&g->dmabuf.bufs, dmabuf, next);
-diff --git a/include/ui/console.h b/include/ui/console.h
-index 570d827644..f7cf3f1acd 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -5,6 +5,7 @@
- #include "qom/object.h"
- #include "qemu/notify.h"
- #include "qemu/error-report.h"
-+#include "qemu/lockable.h"
- #include "qapi/qapi-types-ui.h"
- 
- #ifdef CONFIG_OPENGL
-@@ -171,6 +172,8 @@ typedef struct QemuDmaBuf {
-     void      *sync;
-     int       fence_fd;
-     bool      blob;
-+    bool      draw_submitted;
-+    QemuMutex mutex;
- } QemuDmaBuf;
- 
- typedef struct DisplayState DisplayState;
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 3c7eb244b4..207b28fbe1 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -74,6 +74,15 @@ void gd_egl_draw(VirtualConsole *vc)
-     ww = gdk_window_get_width(window);
-     wh = gdk_window_get_height(window);
- 
-+    if (dmabuf) {
-+       qemu_mutex_lock(&dmabuf->mutex);
-+       if (!dmabuf->draw_submitted) {
-+           qemu_mutex_unlock(&dmabuf->mutex);
-+           return;
-+       } else {
-+          dmabuf->draw_submitted = false;
-+       }
-+    }
-     if (vc->gfx.scanout_mode) {
-         gd_egl_scanout_flush(&vc->gfx.dcl, 0, 0, vc->gfx.w, vc->gfx.h);
- 
-@@ -81,6 +90,9 @@ void gd_egl_draw(VirtualConsole *vc)
-         vc->gfx.scale_y = (double)wh / vc->gfx.h;
-     } else {
-         if (!vc->gfx.ds) {
-+            if (dmabuf) {
-+                qemu_mutex_unlock(&dmabuf->mutex);
-+            }
-             return;
-         }
-         eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
-@@ -100,9 +112,11 @@ void gd_egl_draw(VirtualConsole *vc)
-         egl_dmabuf_create_fence(dmabuf);
-         if (dmabuf->fence_fd > 0) {
-             qemu_set_fd_handler(dmabuf->fence_fd, gd_hw_gl_flushed, NULL, vc);
-+	    qemu_mutex_unlock(&dmabuf->mutex);
-             return;
-         }
-         graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+	qemu_mutex_unlock(&dmabuf->mutex);
-     }
-     graphic_hw_gl_flushed(vc->gfx.dcl.con);
- }
-@@ -312,6 +326,7 @@ void gd_egl_flush(DisplayChangeListener *dcl,
- 
-     if (vc->gfx.guest_fb.dmabuf) {
-         graphic_hw_gl_block(vc->gfx.dcl.con, true);
-+        vc->gfx.guest_fb.dmabuf->draw_submitted = true;
-         gtk_widget_queue_draw_area(area, x, y, w, h);
-         return;
-     }
-diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
-index 091194789e..4ea64736c5 100644
---- a/ui/gtk-gl-area.c
-+++ b/ui/gtk-gl-area.c
-@@ -54,6 +54,14 @@ void gd_gl_area_draw(VirtualConsole *vc)
-             return;
-         }
- 
-+        if (dmabuf) {
-+            if (!dmabuf->draw_submitted) {
-+                return;
-+            } else {
-+                dmabuf->draw_submitted = false;
-+            }
-+        }
-+
-         glBindFramebuffer(GL_READ_FRAMEBUFFER, vc->gfx.guest_fb.framebuffer);
-         /* GtkGLArea sets GL_DRAW_FRAMEBUFFER for us */
- 
-@@ -228,6 +236,7 @@ void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
- 
-     if (vc->gfx.guest_fb.dmabuf) {
-         graphic_hw_gl_block(vc->gfx.dcl.con, true);
-+        vc->gfx.guest_fb.dmabuf->draw_submitted = true;
-     }
-     gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
- }
--- 
-2.17.1
-
diff --git a/host/qemu/0012-ui-gtk-egl-un-tab-and-re-tab-should-destory-egl-surf.patch b/host/qemu/0012-ui-gtk-egl-un-tab-and-re-tab-should-destory-egl-surf.patch
deleted file mode 100644
index ceb3e29..0000000
--- a/host/qemu/0012-ui-gtk-egl-un-tab-and-re-tab-should-destory-egl-surf.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Tue, 29 Jun 2021 11:00:07 -0700
-Subject: [PATCH] ui/gtk-egl: un-tab and re-tab should destory egl surface
-
-An old esurface should be destroyed and set to be NULL while doing
-un-tab and re-tab so that a new esurface can be created for the
-window widget that esurface will be bound to.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk.c | 18 ++++++++++++++++++
- 1 file changed, 18 insertions(+)
-
-diff --git a/ui/gtk.c b/ui/gtk.c
-index cf4882b25a..54cc9bf185 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -1254,6 +1254,14 @@ static gboolean gd_tab_window_close(GtkWidget *widget, GdkEvent *event,
-                                     vc->tab_item, vc->label);
-     gtk_widget_destroy(vc->window);
-     vc->window = NULL;
-+    if (vc->gfx.esurface) {
-+        eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
-+        vc->gfx.esurface = NULL;
-+    }
-+    if (vc->gfx.ectx) {
-+        eglDestroyContext(qemu_egl_display, vc->gfx.ectx);
-+        vc->gfx.ectx = NULL;
-+    }
-     return TRUE;
- }
- 
-@@ -1283,6 +1291,16 @@ static void gd_menu_untabify(GtkMenuItem *item, void *opaque)
-     if (!vc->window) {
-         gtk_widget_set_sensitive(vc->menu_item, false);
-         vc->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-+        if (vc->gfx.esurface) {
-+            eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
-+            vc->gfx.esurface = NULL;
-+        }
-+
-+        if (vc->gfx.esurface) {
-+            eglDestroyContext(qemu_egl_display, vc->gfx.ectx);
-+            vc->gfx.ectx = NULL;
-+        }
-+
-         gd_widget_reparent(s->notebook, vc->window, vc->tab_item);
- 
-         g_signal_connect(vc->window, "delete-event",
--- 
-2.17.1
-
diff --git a/host/qemu/0013-ui-gtk-egl-make-sure-the-right-context-is-the-curren.patch b/host/qemu/0013-ui-gtk-egl-make-sure-the-right-context-is-the-curren.patch
deleted file mode 100644
index df917bc..0000000
--- a/host/qemu/0013-ui-gtk-egl-make-sure-the-right-context-is-the-curren.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Tue, 29 Jun 2021 11:17:19 -0700
-Subject: [PATCH] ui/gtk-egl: make sure the right context is the current
-
-Making the vc->gfx.ectx current before handling texture
-associated with it
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk-egl.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 207b28fbe1..572c135663 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -150,6 +150,7 @@ void gd_egl_refresh(DisplayChangeListener *dcl)
-         }
-         vc->gfx.gls = qemu_gl_init_shader();
-         if (vc->gfx.ds) {
-+            surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-             surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
-         }
-     }
-@@ -177,6 +178,9 @@ void gd_egl_switch(DisplayChangeListener *dcl,
-         resized = false;
-     }
- 
-+    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
-+                   vc->gfx.esurface, vc->gfx.ectx);
-+
-     surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-     vc->gfx.ds = surface;
-     if (vc->gfx.gls) {
-@@ -235,6 +239,9 @@ void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
- #ifdef CONFIG_GBM
-     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
- 
-+    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
-+                   vc->gfx.esurface, vc->gfx.ectx);
-+
-     egl_dmabuf_import_texture(dmabuf);
-     if (!dmabuf->texture) {
-         return;
--- 
-2.17.1
-
diff --git a/host/qemu/0014-ui-gtk-gd_draw_event-returns-FALSE-when-no-cairo-sur.patch b/host/qemu/0014-ui-gtk-gd_draw_event-returns-FALSE-when-no-cairo-sur.patch
deleted file mode 100644
index 39fb8fe..0000000
--- a/host/qemu/0014-ui-gtk-gd_draw_event-returns-FALSE-when-no-cairo-sur.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Fri, 2 Jul 2021 17:08:58 -0700
-Subject: [PATCH] ui/gtk: gd_draw_event returns FALSE when no cairo surface is
- bound
-
-gd_draw_event shouldn't try to repaint if surface does not exist
-for the VC.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk.c | 3 +++
- 1 file changed, 3 insertions(+)
-
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 54cc9bf185..8bcf965440 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -778,6 +778,9 @@ static gboolean gd_draw_event(GtkWidget *widget, cairo_t *cr, void *opaque)
-     if (!vc->gfx.ds) {
-         return FALSE;
-     }
-+    if (!vc->gfx.surface) {
-+        return FALSE;
-+    }
- 
-     vc->gfx.dcl.update_interval =
-         gd_monitor_update_interval(vc->window ? vc->window : s->window);
--- 
-2.17.1
-
diff --git a/host/qemu/0015-ui-gtk-egl-guest-fb-texture-needs-to-be-regenerated-.patch b/host/qemu/0015-ui-gtk-egl-guest-fb-texture-needs-to-be-regenerated-.patch
deleted file mode 100644
index e001d3e..0000000
--- a/host/qemu/0015-ui-gtk-egl-guest-fb-texture-needs-to-be-regenerated-.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Tue, 6 Jul 2021 21:51:47 -0700
-Subject: [PATCH] ui/gtk-egl: guest fb texture needs to be regenerated when
- reinitializing egl
-
-If guest fb is backed by dmabuf (blob-resource), the texture bound to the
-old context needs to be recreated in case the egl is re-initialized (e.g.
-new window for vc is created in case of detaching/reattaching of the tab)
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk-egl.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 572c135663..d96804ff7f 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -153,6 +153,10 @@ void gd_egl_refresh(DisplayChangeListener *dcl)
-             surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-             surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
-         }
-+        if (vc->gfx.guest_fb.dmabuf) {
-+            vc->gfx.guest_fb.dmabuf->texture = 0;
-+            gd_egl_scanout_dmabuf(dcl, vc->gfx.guest_fb.dmabuf);
-+        }
-     }
- 
-     graphic_hw_update(dcl->con);
--- 
-2.17.1
-
diff --git a/host/qemu/0016-edid-Added-support-for-4k-60-Hz-monitor.patch b/host/qemu/0016-edid-Added-support-for-4k-60-Hz-monitor.patch
deleted file mode 100644
index fd72517..0000000
--- a/host/qemu/0016-edid-Added-support-for-4k-60-Hz-monitor.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Satyeshwar Singh <satyeshwar.singh@intel.com>
-Date: Fri, 9 Jul 2021 14:03:17 -0700
-Subject: [PATCH] edid: Added support for 4k@60 Hz monitor
-
-Previously, the large modes (>1080p) that were generated by Qemu in its EDID
-were all 50 Hz. If we provide them to a Guest OS and the user selects
-one of these modes, then the OS by default only gets 50 FPS. This is
-especially true for Windows OS. With this patch, we are now exposing a
-3840x2160@60 Hz which will allow the guest OS to get 60 FPS.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Signed-off-by: Satyeshwar Singh <satyeshwar.singh@intel.com>
----
- hw/display/edid-generate.c | 3 +++
- 1 file changed, 3 insertions(+)
-
-diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
-index a1bea9a3aa..6bc2daba62 100644
---- a/hw/display/edid-generate.c
-+++ b/hw/display/edid-generate.c
-@@ -24,6 +24,9 @@ static const struct edid_mode {
-     { .xres = 2048,   .yres = 1152 },
-     { .xres = 1920,   .yres = 1080,   .dta =  31 },
- 
-+    /* dea/dta extension timings (all @ 60 Hz) */
-+    { .xres = 3840,   .yres = 2160,   .dta =  97 },
-+
-     /* additional standard timings 3 (all @ 60Hz) */
-     { .xres = 1920,   .yres = 1200,   .xtra3 = 10,   .bit = 0 },
-     { .xres = 1600,   .yres = 1200,   .xtra3 =  9,   .bit = 2 },
--- 
-2.17.1
-
diff --git a/host/qemu/0017-virtio-gpu-splitting-one-extended-mode-guest-fb-into.patch b/host/qemu/0017-virtio-gpu-splitting-one-extended-mode-guest-fb-into.patch
deleted file mode 100644
index 5112265..0000000
--- a/host/qemu/0017-virtio-gpu-splitting-one-extended-mode-guest-fb-into.patch
+++ /dev/null
@@ -1,160 +0,0 @@
-From 3e3f585946ffe07afc248d17cd54109376cf2579 Mon Sep 17 00:00:00 2001
-From: Xiao HaowenX <haowenx.xiao@intel.com>
-Date: Mon, 28 Feb 2022 09:33:06 +0800
-Subject: [PATCH]  virtio-gpu: splitting one extended mode guest fb into 
- n-scanouts
-
-When guest is running Linux/X11 with extended multiple displays mode enabled,
-the guest shares one scanout resource each time containing whole surface
-rather than sharing individual display output separately. This extended frame
-is properly splited and rendered on the corresponding scanout surfaces but
-not in case of blob-resource (zero copy).
-
-This code change lets the qemu split this one large surface data into multiple
-in case of blob-resource as well so that each sub frame then can be blitted
-properly to each scanout. (rebased)
-
-v2: put virtio_gpu_rect's width and height to dmabuf's scanout_width
- and scanout_height
----
- hw/display/virtio-gpu-udmabuf.c | 19 +++++++++++--------
- hw/display/virtio-gpu.c         |  4 ++--
- include/hw/virtio/virtio-gpu.h  |  5 +++--
- include/ui/console.h            |  4 ++++
- stubs/virtio-gpu-udmabuf.c      |  3 ++-
- 5 files changed, 22 insertions(+), 13 deletions(-)
-
-diff --git a/hw/display/virtio-gpu-udmabuf.c b/hw/display/virtio-gpu-udmabuf.c
-index 29793f531..b11ac5bc6 100644
---- a/hw/display/virtio-gpu-udmabuf.c
-+++ b/hw/display/virtio-gpu-udmabuf.c
-@@ -171,7 +171,8 @@ static VGPUDMABuf
- *virtio_gpu_create_dmabuf(VirtIOGPU *g,
-                           uint32_t scanout_id,
-                           struct virtio_gpu_simple_resource *res,
--                          struct virtio_gpu_framebuffer *fb)
-+                          struct virtio_gpu_framebuffer *fb,
-+                          struct virtio_gpu_rect *r)
- {
-     VGPUDMABuf *dmabuf;
- 
-@@ -183,6 +184,10 @@ static VGPUDMABuf
-     dmabuf->buf.width = fb->width;
-     dmabuf->buf.height = fb->height;
-     dmabuf->buf.stride = fb->stride;
-+    dmabuf->buf.x = r->x;
-+    dmabuf->buf.y = r->y;
-+    dmabuf->buf.scanout_width = r->width;
-+    dmabuf->buf.scanout_height = r->height;
-     dmabuf->buf.fourcc = qemu_pixman_to_drm_format(fb->format);
-     dmabuf->buf.fd = res->dmabuf_fd;
-     dmabuf->buf.blob = true;
-@@ -199,24 +204,22 @@ static VGPUDMABuf
- int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-                              uint32_t scanout_id,
-                              struct virtio_gpu_simple_resource *res,
--                             struct virtio_gpu_framebuffer *fb)
-+                             struct virtio_gpu_framebuffer *fb,
-+                             struct virtio_gpu_rect *r)
- {
-     struct virtio_gpu_scanout *scanout = &g->parent_obj.scanout[scanout_id];
-     VGPUDMABuf *new_primary, *old_primary = NULL;
- 
--    new_primary = virtio_gpu_create_dmabuf(g, scanout_id, res, fb);
-+    new_primary = virtio_gpu_create_dmabuf(g, scanout_id, res, fb, r);
-     if (!new_primary) {
-         return -EINVAL;
-     }
- 
-     if (g->dmabuf.primary) {
--        old_primary = g->dmabuf.primary;
-+        old_primary = g->dmabuf.primary[scanout_id];
-     }
- 
--    g->dmabuf.primary = new_primary;
--    qemu_console_resize(scanout->con,
--                        new_primary->buf.width,
--                        new_primary->buf.height);
-+    g->dmabuf.primary[scanout_id] = new_primary;
-     dpy_gl_scanout_dmabuf(scanout->con, &new_primary->buf);
- 
-     if (old_primary) {
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index 3fcd44ac5..cc8f98cfa 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -523,9 +523,9 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
-                 console_has_gl(scanout->con)) {
-                 dpy_gl_update(scanout->con, 0, 0, scanout->width,
-                               scanout->height);
--                return;
-             }
-         }
-+        return;
-     }
- 
-     if (!res->blob &&
-@@ -633,7 +633,7 @@ static void virtio_gpu_do_set_scanout(VirtIOGPU *g,
- 
-     if (res->blob) {
-         if (console_has_gl(scanout->con)) {
--            if (!virtio_gpu_update_dmabuf(g, scanout_id, res, fb)) {
-+            if (!virtio_gpu_update_dmabuf(g, scanout_id, res, fb, r)) {
-                 virtio_gpu_update_scanout(g, scanout_id, res, r);
-                 return;
-             }
-diff --git a/include/hw/virtio/virtio-gpu.h b/include/hw/virtio/virtio-gpu.h
-index bcf54d970..6372f4bbb 100644
---- a/include/hw/virtio/virtio-gpu.h
-+++ b/include/hw/virtio/virtio-gpu.h
-@@ -187,7 +187,7 @@ struct VirtIOGPU {
- 
-     struct {
-         QTAILQ_HEAD(, VGPUDMABuf) bufs;
--        VGPUDMABuf *primary;
-+        VGPUDMABuf *primary[VIRTIO_GPU_MAX_SCANOUTS];
-     } dmabuf;
- };
- 
-@@ -273,7 +273,8 @@ void virtio_gpu_fini_udmabuf(struct virtio_gpu_simple_resource *res);
- int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-                              uint32_t scanout_id,
-                              struct virtio_gpu_simple_resource *res,
--                             struct virtio_gpu_framebuffer *fb);
-+                             struct virtio_gpu_framebuffer *fb,
-+                             struct virtio_gpu_rect *r);
- 
- /* virtio-gpu-3d.c */
- void virtio_gpu_virgl_process_cmd(VirtIOGPU *g,
-diff --git a/include/ui/console.h b/include/ui/console.h
-index f7cf3f1ac..396795887 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -168,6 +168,10 @@ typedef struct QemuDmaBuf {
-     uint32_t  fourcc;
-     uint64_t  modifier;
-     uint32_t  texture;
-+    uint32_t  x;
-+    uint32_t  y;
-+    uint32_t  scanout_width;
-+    uint32_t  scanout_height;
-     bool      y0_top;
-     void      *sync;
-     int       fence_fd;
-diff --git a/stubs/virtio-gpu-udmabuf.c b/stubs/virtio-gpu-udmabuf.c
-index 81f661441..f692e1351 100644
---- a/stubs/virtio-gpu-udmabuf.c
-+++ b/stubs/virtio-gpu-udmabuf.c
-@@ -20,7 +20,8 @@ void virtio_gpu_fini_udmabuf(struct virtio_gpu_simple_resource *res)
- int virtio_gpu_update_dmabuf(VirtIOGPU *g,
-                              uint32_t scanout_id,
-                              struct virtio_gpu_simple_resource *res,
--                             struct virtio_gpu_framebuffer *fb)
-+                             struct virtio_gpu_framebuffer *fb,
-+                             struct virtio_gpu_rect *r)
- {
-     /* nothing (stub) */
-     return 0;
--- 
-2.34.1
-
diff --git a/host/qemu/0018-ui-gtk-egl-blitting-partial-guest-fb-to-the-proper-s.patch b/host/qemu/0018-ui-gtk-egl-blitting-partial-guest-fb-to-the-proper-s.patch
deleted file mode 100644
index 4040508..0000000
--- a/host/qemu/0018-ui-gtk-egl-blitting-partial-guest-fb-to-the-proper-s.patch
+++ /dev/null
@@ -1,63 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Sun, 4 Jul 2021 21:58:59 -0700
-Subject: [PATCH] ui/gtk-egl: blitting partial guest fb to the proper scanout
- surface
-
-eb_fb_blit needs more parameters that describe x and y offsets and width
-and height of the actual scanout to specify the size and cordination of
-partial image to blit in the guest fb in case the guest fb contains multiple
-display outputs. (rebased)
-
-v2: make egl_fb include dmabuf info so that egl_fb_blit can use the embedded
-    parameters instead of introducing additional arguments to the function
-    (Vivek Kasireddy)
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/egl-helpers.c | 25 +++++++++++++++++++++----
- 1 file changed, 21 insertions(+), 4 deletions(-)
-
-diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
-index 6fa3f2ec45..42f0b45d4c 100644
---- a/ui/egl-helpers.c
-+++ b/ui/egl-helpers.c
-@@ -116,14 +116,31 @@ void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
- 
- void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip)
- {
--    GLuint y1, y2;
-+    GLuint x1 = 0;
-+    GLuint y1 = 0;
-+    GLuint x2, y2;
-+    GLuint w = src->width;
-+    GLuint h = src->height;
- 
-     glBindFramebuffer(GL_READ_FRAMEBUFFER, src->framebuffer);
-     glBindFramebuffer(GL_DRAW_FRAMEBUFFER, dst->framebuffer);
-     glViewport(0, 0, dst->width, dst->height);
--    y1 = flip ? src->height : 0;
--    y2 = flip ? 0 : src->height;
--    glBlitFramebuffer(0, y1, src->width, y2,
-+
-+    if (src->dmabuf) {
-+        x1 = src->dmabuf->x;
-+        y1 = src->dmabuf->y;
-+        w = src->dmabuf->scanout_width;
-+        h = src->dmabuf->scanout_height;
-+    }
-+
-+    w = (x1 + w) > src->width ? src->width - x1 : w;
-+    h = (y1 + h) > src->height ? src->height - y1 : h;
-+
-+    y2 = flip ? y1 : h + y1;
-+    y1 = flip ? h + y1 : y1;
-+    x2 = x1 + w;
-+
-+    glBlitFramebuffer(x1, y1, x2, y2,
-                       0, 0, dst->width, dst->height,
-                       GL_COLOR_BUFFER_BIT, GL_LINEAR);
- }
--- 
-2.17.1
-
diff --git a/host/qemu/0019-ui-Add-in-clipboard-infra.patch b/host/qemu/0019-ui-Add-in-clipboard-infra.patch
deleted file mode 100644
index f4746fb..0000000
--- a/host/qemu/0019-ui-Add-in-clipboard-infra.patch
+++ /dev/null
@@ -1,634 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Gerd Hoffmann <kraxel@redhat.com>
-Date: Wed, 19 May 2021 07:39:33 +0200
-Subject: [PATCH] ui: Add in clipboard infra
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Mazlan, Hazwan Arif <hazwan.arif.mazlan@intel.com>
-
-ui: add clipboard infrastructure
-
-Add some infrastructure to manage the clipboard in qemu.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Reviewed-by: Marc-Andr√© Lureau <marcandre.lureau@redhat.com>
-Message-id: 20210519053940.1888907-1-kraxel@redhat.com
-Message-Id: <20210519053940.1888907-3-kraxel@redhat.com>
-
-ui/cocoa: Add clipboard support
-
-Signed-off-by: Akihiko Odaki <akihiko.odaki@gmail.com>
-Message-Id: <20210616141954.54291-1-akihiko.odaki@gmail.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-
-ui/gtk: add clipboard support
-
-This patch adds clipboard support to the qemu gtk ui.
-
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
-Reviewed-by: Marc-Andr√© Lureau <marcandre.lureau@redhat.com>
-Message-id: 20210519053940.1888907-1-kraxel@redhat.com
-Message-Id: <20210519053940.1888907-10-kraxel@redhat.com>
----
- include/ui/clipboard.h |  62 +++++++++++++
- include/ui/gtk.h       |  10 +++
- ui/clipboard.c         |  92 ++++++++++++++++++++
- ui/cocoa.m             | 109 +++++++++++++++++++++++
- ui/gtk-clipboard.c     | 192 +++++++++++++++++++++++++++++++++++++++++
- ui/gtk.c               |   1 +
- ui/meson.build         |   3 +-
- 7 files changed, 468 insertions(+), 1 deletion(-)
- create mode 100644 include/ui/clipboard.h
- create mode 100644 ui/clipboard.c
- create mode 100644 ui/gtk-clipboard.c
-
-diff --git a/include/ui/clipboard.h b/include/ui/clipboard.h
-new file mode 100644
-index 0000000000..a1aacb1f7d
---- /dev/null
-+++ b/include/ui/clipboard.h
-@@ -0,0 +1,62 @@
-+#ifndef QEMU_CLIPBOARD_H
-+#define QEMU_CLIPBOARD_H
-+
-+#include "qemu/notify.h"
-+
-+typedef enum QemuClipboardType QemuClipboardType;
-+typedef enum QemuClipboardSelection QemuClipboardSelection;
-+typedef struct QemuClipboardPeer QemuClipboardPeer;
-+typedef struct QemuClipboardInfo QemuClipboardInfo;
-+
-+enum QemuClipboardType {
-+    QEMU_CLIPBOARD_TYPE_TEXT,  /* text/plain; charset=utf-8 */
-+    QEMU_CLIPBOARD_TYPE__COUNT,
-+};
-+
-+/* same as VD_AGENT_CLIPBOARD_SELECTION_* */
-+enum QemuClipboardSelection {
-+    QEMU_CLIPBOARD_SELECTION_CLIPBOARD,
-+    QEMU_CLIPBOARD_SELECTION_PRIMARY,
-+    QEMU_CLIPBOARD_SELECTION_SECONDARY,
-+    QEMU_CLIPBOARD_SELECTION__COUNT,
-+};
-+
-+struct QemuClipboardPeer {
-+    const char *name;
-+    Notifier update;
-+    void (*request)(QemuClipboardInfo *info,
-+                    QemuClipboardType type);
-+};
-+
-+struct QemuClipboardInfo {
-+    uint32_t refcount;
-+    QemuClipboardPeer *owner;
-+    QemuClipboardSelection selection;
-+    struct {
-+        bool available;
-+        bool requested;
-+        size_t size;
-+        void *data;
-+    } types[QEMU_CLIPBOARD_TYPE__COUNT];
-+};
-+
-+void qemu_clipboard_peer_register(QemuClipboardPeer *peer);
-+void qemu_clipboard_peer_unregister(QemuClipboardPeer *peer);
-+
-+QemuClipboardInfo *qemu_clipboard_info_new(QemuClipboardPeer *owner,
-+                                           QemuClipboardSelection selection);
-+QemuClipboardInfo *qemu_clipboard_info_ref(QemuClipboardInfo *info);
-+void qemu_clipboard_info_unref(QemuClipboardInfo *info);
-+
-+void qemu_clipboard_update(QemuClipboardInfo *info);
-+void qemu_clipboard_request(QemuClipboardInfo *info,
-+                            QemuClipboardType type);
-+
-+void qemu_clipboard_set_data(QemuClipboardPeer *peer,
-+                             QemuClipboardInfo *info,
-+                             QemuClipboardType type,
-+                             uint32_t size,
-+                             const void *data,
-+                             bool update);
-+
-+#endif /* QEMU_CLIPBOARD_H */
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 074ad4466f..a25f5bfecc 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -18,6 +18,7 @@
- #include <gdk/gdkwayland.h>
- #endif
- 
-+#include "ui/clipboard.h"
- #include "ui/console.h"
- #include "ui/kbd-state.h"
- #if defined(CONFIG_OPENGL)
-@@ -137,6 +138,12 @@ struct GtkDisplayState {
- 
-     bool external_pause_update;
- 
-+    QemuClipboardPeer cbpeer;
-+    QemuClipboardInfo *cbinfo[QEMU_CLIPBOARD_SELECTION__COUNT];
-+    uint32_t cbpending[QEMU_CLIPBOARD_SELECTION__COUNT];
-+    GtkClipboard *gtkcb[QEMU_CLIPBOARD_SELECTION__COUNT];
-+    bool cbowner[QEMU_CLIPBOARD_SELECTION__COUNT];
-+
-     DisplayOptions *opts;
- };
- 
-@@ -208,4 +215,7 @@ void gtk_gl_area_init(void);
- int gd_gl_area_make_current(DisplayChangeListener *dcl,
-                             QEMUGLContext ctx);
- 
-+/* gtk-clipboard.c */
-+void gd_clipboard_init(GtkDisplayState *gd);
-+
- #endif /* UI_GTK_H */
-diff --git a/ui/clipboard.c b/ui/clipboard.c
-new file mode 100644
-index 0000000000..3525b30178
---- /dev/null
-+++ b/ui/clipboard.c
-@@ -0,0 +1,92 @@
-+#include "qemu/osdep.h"
-+#include "ui/clipboard.h"
-+
-+static NotifierList clipboard_notifiers =
-+    NOTIFIER_LIST_INITIALIZER(clipboard_notifiers);
-+
-+void qemu_clipboard_peer_register(QemuClipboardPeer *peer)
-+{
-+    notifier_list_add(&clipboard_notifiers, &peer->update);
-+}
-+
-+void qemu_clipboard_peer_unregister(QemuClipboardPeer *peer)
-+{
-+    notifier_remove(&peer->update);
-+}
-+
-+void qemu_clipboard_update(QemuClipboardInfo *info)
-+{
-+    notifier_list_notify(&clipboard_notifiers, info);
-+}
-+
-+QemuClipboardInfo *qemu_clipboard_info_new(QemuClipboardPeer *owner,
-+                                           QemuClipboardSelection selection)
-+{
-+    QemuClipboardInfo *info = g_new0(QemuClipboardInfo, 1);
-+
-+    info->owner = owner;
-+    info->selection = selection;
-+    info->refcount = 1;
-+
-+    return info;
-+}
-+
-+QemuClipboardInfo *qemu_clipboard_info_ref(QemuClipboardInfo *info)
-+{
-+    info->refcount++;
-+    return info;
-+}
-+
-+void qemu_clipboard_info_unref(QemuClipboardInfo *info)
-+{
-+    uint32_t type;
-+
-+    if (!info) {
-+        return;
-+    }
-+
-+    info->refcount--;
-+    if (info->refcount > 0) {
-+        return;
-+    }
-+
-+    for (type = 0; type < QEMU_CLIPBOARD_TYPE__COUNT; type++) {
-+        g_free(info->types[type].data);
-+    }
-+    g_free(info);
-+}
-+
-+void qemu_clipboard_request(QemuClipboardInfo *info,
-+                            QemuClipboardType type)
-+{
-+    if (info->types[type].data ||
-+        info->types[type].requested ||
-+        !info->types[type].available ||
-+        !info->owner)
-+        return;
-+
-+    info->types[type].requested = true;
-+    info->owner->request(info, type);
-+}
-+
-+void qemu_clipboard_set_data(QemuClipboardPeer *peer,
-+                             QemuClipboardInfo *info,
-+                             QemuClipboardType type,
-+                             uint32_t size,
-+                             const void *data,
-+                             bool update)
-+{
-+    if (!info ||
-+        info->owner != peer) {
-+        return;
-+    }
-+
-+    g_free(info->types[type].data);
-+    info->types[type].data = g_memdup(data, size);
-+    info->types[type].size = size;
-+    info->types[type].available = true;
-+
-+    if (update) {
-+        qemu_clipboard_update(info);
-+    }
-+}
-diff --git a/ui/cocoa.m b/ui/cocoa.m
-index 37e1fb52eb..bd549e3276 100644
---- a/ui/cocoa.m
-+++ b/ui/cocoa.m
-@@ -28,6 +28,7 @@
- #include <crt_externs.h>
- 
- #include "qemu-common.h"
-+#include "ui/clipboard.h"
- #include "ui/console.h"
- #include "ui/input.h"
- #include "ui/kbd-state.h"
-@@ -105,6 +106,10 @@ static QemuSemaphore display_init_sem;
- static QemuSemaphore app_started_sem;
- static bool allow_events;
- 
-+static NSInteger cbchangecount = -1;
-+static QemuClipboardInfo *cbinfo;
-+static QemuEvent cbevent;
-+
- // Utility functions to run specified code block with iothread lock held
- typedef void (^CodeBlock)(void);
- typedef bool (^BoolCodeBlock)(void);
-@@ -1711,6 +1716,93 @@ static void addRemovableDevicesMenuItems(void)
-     qapi_free_BlockInfoList(pointerToFree);
- }
- 
-+@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
-+@end
-+
-+@implementation QemuCocoaPasteboardTypeOwner
-+
-+- (void)pasteboard:(NSPasteboard *)sender provideDataForType:(NSPasteboardType)type
-+{
-+    if (type != NSPasteboardTypeString) {
-+        return;
-+    }
-+
-+    with_iothread_lock(^{
-+        QemuClipboardInfo *info = qemu_clipboard_info_ref(cbinfo);
-+        qemu_event_reset(&cbevent);
-+        qemu_clipboard_request(info, QEMU_CLIPBOARD_TYPE_TEXT);
-+
-+        while (info == cbinfo &&
-+               info->types[QEMU_CLIPBOARD_TYPE_TEXT].available &&
-+               info->types[QEMU_CLIPBOARD_TYPE_TEXT].data == NULL) {
-+            qemu_mutex_unlock_iothread();
-+            qemu_event_wait(&cbevent);
-+            qemu_mutex_lock_iothread();
-+        }
-+
-+        if (info == cbinfo) {
-+            NSData *data = [[NSData alloc] initWithBytes:info->types[QEMU_CLIPBOARD_TYPE_TEXT].data
-+                                           length:info->types[QEMU_CLIPBOARD_TYPE_TEXT].size];
-+            [sender setData:data forType:NSPasteboardTypeString];
-+            [data release];
-+        }
-+
-+        qemu_clipboard_info_unref(info);
-+    });
-+}
-+
-+@end
-+
-+static QemuCocoaPasteboardTypeOwner *cbowner;
-+
-+static void cocoa_clipboard_notify(Notifier *notifier, void *data);
-+static void cocoa_clipboard_request(QemuClipboardInfo *info,
-+                                    QemuClipboardType type);
-+
-+static QemuClipboardPeer cbpeer = {
-+    .name = "cocoa",
-+    .update = { .notify = cocoa_clipboard_notify },
-+    .request = cocoa_clipboard_request
-+};
-+
-+static void cocoa_clipboard_notify(Notifier *notifier, void *data)
-+{
-+    QemuClipboardInfo *info = data;
-+
-+    if (info->owner == &cbpeer || info->selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
-+        return;
-+    }
-+
-+    if (info != cbinfo) {
-+        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-+        qemu_clipboard_info_unref(cbinfo);
-+        cbinfo = qemu_clipboard_info_ref(info);
-+        cbchangecount = [[NSPasteboard generalPasteboard] declareTypes:@[NSPasteboardTypeString] owner:cbowner];
-+        [pool release];
-+    }
-+
-+    qemu_event_set(&cbevent);
-+}
-+
-+static void cocoa_clipboard_request(QemuClipboardInfo *info,
-+                                    QemuClipboardType type)
-+{
-+    NSData *text;
-+
-+    switch (type) {
-+    case QEMU_CLIPBOARD_TYPE_TEXT:
-+        text = [[NSPasteboard generalPasteboard] dataForType:NSPasteboardTypeString];
-+        if (text) {
-+            qemu_clipboard_set_data(&cbpeer, info, type,
-+                                    [text length], [text bytes], true);
-+            [text release];
-+        }
-+        break;
-+    default:
-+        break;
-+    }
-+}
-+
- /*
-  * The startup process for the OSX/Cocoa UI is complicated, because
-  * OSX insists that the UI runs on the initial main thread, and so we
-@@ -1745,6 +1837,7 @@ static void *call_qemu_main(void *opaque)
-     COCOA_DEBUG("Second thread: calling qemu_main()\n");
-     status = qemu_main(gArgc, gArgv, *_NSGetEnviron());
-     COCOA_DEBUG("Second thread: qemu_main() returned, exiting\n");
-+    [cbowner release];
-     exit(status);
- }
- 
-@@ -1865,6 +1958,18 @@ static void cocoa_refresh(DisplayChangeListener *dcl)
-             [cocoaView setAbsoluteEnabled:YES];
-         });
-     }
-+
-+    if (cbchangecount != [[NSPasteboard generalPasteboard] changeCount]) {
-+        qemu_clipboard_info_unref(cbinfo);
-+        cbinfo = qemu_clipboard_info_new(&cbpeer, QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
-+        if ([[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]]) {
-+            cbinfo->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
-+        }
-+        qemu_clipboard_update(cbinfo);
-+        cbchangecount = [[NSPasteboard generalPasteboard] changeCount];
-+        qemu_event_set(&cbevent);
-+    }
-+
-     [pool release];
- }
- 
-@@ -1890,6 +1995,10 @@ static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
- 
-     // register vga output callbacks
-     register_displaychangelistener(&dcl);
-+
-+    qemu_event_init(&cbevent, false);
-+    cbowner = [[QemuCocoaPasteboardTypeOwner alloc] init];
-+    qemu_clipboard_peer_register(&cbpeer);
- }
- 
- static QemuDisplay qemu_display_cocoa = {
-diff --git a/ui/gtk-clipboard.c b/ui/gtk-clipboard.c
-new file mode 100644
-index 0000000000..bff28d2030
---- /dev/null
-+++ b/ui/gtk-clipboard.c
-@@ -0,0 +1,192 @@
-+/*
-+ * GTK UI -- clipboard support
-+ *
-+ * Copyright (C) 2021 Gerd Hoffmann <kraxel@redhat.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
-+ *
-+ */
-+
-+#include "qemu/osdep.h"
-+#include "qemu-common.h"
-+#include "qemu/main-loop.h"
-+
-+#include "ui/gtk.h"
-+
-+static QemuClipboardSelection gd_find_selection(GtkDisplayState *gd,
-+                                                GtkClipboard *clipboard)
-+{
-+    QemuClipboardSelection s;
-+
-+    for (s = 0; s < QEMU_CLIPBOARD_SELECTION__COUNT; s++) {
-+        if (gd->gtkcb[s] == clipboard) {
-+            return s;
-+        }
-+    }
-+    return QEMU_CLIPBOARD_SELECTION_CLIPBOARD;
-+}
-+
-+static void gd_clipboard_get_data(GtkClipboard     *clipboard,
-+                                  GtkSelectionData *selection_data,
-+                                  guint             selection_info,
-+                                  gpointer          data)
-+{
-+    GtkDisplayState *gd = data;
-+    QemuClipboardSelection s = gd_find_selection(gd, clipboard);
-+    QemuClipboardType type = QEMU_CLIPBOARD_TYPE_TEXT;
-+    QemuClipboardInfo *info = qemu_clipboard_info_ref(gd->cbinfo[s]);
-+
-+    qemu_clipboard_request(info, type);
-+    while (info == gd->cbinfo[s] &&
-+           info->types[type].available &&
-+           info->types[type].data == NULL) {
-+        main_loop_wait(false);
-+    }
-+
-+    if (info == gd->cbinfo[s] && gd->cbowner[s]) {
-+        gtk_selection_data_set_text(selection_data,
-+                                    info->types[type].data,
-+                                    info->types[type].size);
-+    } else {
-+        /* clipboard owner changed while waiting for the data */
-+    }
-+
-+    qemu_clipboard_info_unref(info);
-+}
-+
-+static void gd_clipboard_clear(GtkClipboard *clipboard,
-+                               gpointer data)
-+{
-+    GtkDisplayState *gd = data;
-+    QemuClipboardSelection s = gd_find_selection(gd, clipboard);
-+
-+    gd->cbowner[s] = false;
-+}
-+
-+static void gd_clipboard_notify(Notifier *notifier, void *data)
-+{
-+    GtkDisplayState *gd = container_of(notifier, GtkDisplayState, cbpeer.update);
-+    QemuClipboardInfo *info = data;
-+    QemuClipboardSelection s = info->selection;
-+    bool self_update = info->owner == &gd->cbpeer;
-+
-+    if (info != gd->cbinfo[s]) {
-+        qemu_clipboard_info_unref(gd->cbinfo[s]);
-+        gd->cbinfo[s] = qemu_clipboard_info_ref(info);
-+        gd->cbpending[s] = 0;
-+        if (!self_update) {
-+            GtkTargetList *list;
-+            GtkTargetEntry *targets;
-+            gint n_targets;
-+
-+            list = gtk_target_list_new(NULL, 0);
-+            if (info->types[QEMU_CLIPBOARD_TYPE_TEXT].available) {
-+                gtk_target_list_add_text_targets(list, 0);
-+            }
-+            targets = gtk_target_table_new_from_list(list, &n_targets);
-+
-+            gtk_clipboard_clear(gd->gtkcb[s]);
-+            gd->cbowner[s] = true;
-+            gtk_clipboard_set_with_data(gd->gtkcb[s],
-+                                        targets, n_targets,
-+                                        gd_clipboard_get_data,
-+                                        gd_clipboard_clear,
-+                                        gd);
-+
-+            gtk_target_table_free(targets, n_targets);
-+            gtk_target_list_unref(list);
-+        }
-+        return;
-+    }
-+
-+    if (self_update) {
-+        return;
-+    }
-+
-+    /*
-+     * Clipboard got updated, with data probably.  No action here, we
-+     * are waiting for updates in gd_clipboard_get_data().
-+     */
-+}
-+
-+static void gd_clipboard_request(QemuClipboardInfo *info,
-+                                 QemuClipboardType type)
-+{
-+    GtkDisplayState *gd = container_of(info->owner, GtkDisplayState, cbpeer);
-+    char *text;
-+
-+    switch (type) {
-+    case QEMU_CLIPBOARD_TYPE_TEXT:
-+        text = gtk_clipboard_wait_for_text(gd->gtkcb[info->selection]);
-+        if (text) {
-+            qemu_clipboard_set_data(&gd->cbpeer, info, type,
-+                                    strlen(text), text, true);
-+            g_free(text);
-+        }
-+        break;
-+    default:
-+        break;
-+    }
-+}
-+
-+static void gd_owner_change(GtkClipboard *clipboard,
-+                            GdkEvent *event,
-+                            gpointer data)
-+{
-+    GtkDisplayState *gd = data;
-+    QemuClipboardSelection s = gd_find_selection(gd, clipboard);
-+    QemuClipboardInfo *info;
-+
-+    if (gd->cbowner[s]) {
-+        /* ignore notifications about our own grabs */
-+        return;
-+    }
-+
-+
-+    switch (event->owner_change.reason) {
-+    case GDK_SETTING_ACTION_NEW:
-+        info = qemu_clipboard_info_new(&gd->cbpeer, s);
-+        if (gtk_clipboard_wait_is_text_available(clipboard)) {
-+            info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
-+        }
-+
-+        qemu_clipboard_update(info);
-+        qemu_clipboard_info_unref(info);
-+        break;
-+    default:
-+        break;
-+    }
-+}
-+
-+void gd_clipboard_init(GtkDisplayState *gd)
-+{
-+    gd->cbpeer.name = "gtk";
-+    gd->cbpeer.update.notify = gd_clipboard_notify;
-+    gd->cbpeer.request = gd_clipboard_request;
-+    qemu_clipboard_peer_register(&gd->cbpeer);
-+
-+    gd->gtkcb[QEMU_CLIPBOARD_SELECTION_CLIPBOARD] =
-+        gtk_clipboard_get(gdk_atom_intern("CLIPBOARD", FALSE));
-+    gd->gtkcb[QEMU_CLIPBOARD_SELECTION_PRIMARY] =
-+        gtk_clipboard_get(gdk_atom_intern("PRIMARY", FALSE));
-+    gd->gtkcb[QEMU_CLIPBOARD_SELECTION_SECONDARY] =
-+        gtk_clipboard_get(gdk_atom_intern("SECONDARY", FALSE));
-+
-+    g_signal_connect(gd->gtkcb[QEMU_CLIPBOARD_SELECTION_CLIPBOARD],
-+                     "owner-change", G_CALLBACK(gd_owner_change), gd);
-+    g_signal_connect(gd->gtkcb[QEMU_CLIPBOARD_SELECTION_PRIMARY],
-+                     "owner-change", G_CALLBACK(gd_owner_change), gd);
-+    g_signal_connect(gd->gtkcb[QEMU_CLIPBOARD_SELECTION_SECONDARY],
-+                     "owner-change", G_CALLBACK(gd_owner_change), gd);
-+}
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 8bcf965440..bb3861c135 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -2342,6 +2342,7 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     }
- 
- 
-+    gd_clipboard_init(s);
- }
- 
- static void early_gtk_display_init(DisplayOptions *opts)
-diff --git a/ui/meson.build b/ui/meson.build
-index 7a709ff548..e72e1c39ed 100644
---- a/ui/meson.build
-+++ b/ui/meson.build
-@@ -2,6 +2,7 @@ softmmu_ss.add(pixman)
- specific_ss.add(when: ['CONFIG_SOFTMMU'], if_true: pixman)   # for the include path
- 
- softmmu_ss.add(files(
-+  'clipboard.c',
-   'console.c',
-   'cursor.c',
-   'input-keymap.c',
-@@ -63,7 +64,7 @@ if gtk.found()
-   softmmu_ss.add(when: 'CONFIG_WIN32', if_true: files('win32-kbd-hook.c'))
- 
-   gtk_ss = ss.source_set()
--  gtk_ss.add(gtk, vte, pixman, files('gtk.c'))
-+  gtk_ss.add(gtk, vte, pixman, files('gtk.c', 'gtk-clipboard.c'))
-   gtk_ss.add(when: x11, if_true: files('x_keymap.c'))
-   gtk_ss.add(when: [opengl, 'CONFIG_OPENGL'], if_true: files('gtk-gl-area.c'))
-   gtk_ss.add(when: [x11, opengl, 'CONFIG_OPENGL'], if_true: files('gtk-egl.c'))
--- 
-2.17.1
-
diff --git a/host/qemu/0020-ui-gtk-detach_all-option-for-making-all-VCs-detached.patch b/host/qemu/0020-ui-gtk-detach_all-option-for-making-all-VCs-detached.patch
deleted file mode 100644
index 6312c95..0000000
--- a/host/qemu/0020-ui-gtk-detach_all-option-for-making-all-VCs-detached.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Sat, 17 Jul 2021 14:42:11 -0700
-Subject: [PATCH] ui/gtk: detach_all option for making all VCs detached upon
- starting
-
-With "detach-all=on" for display, all VCs are detached from the beginning.
-This is useful when there are multiple displays assigned to a guest OS.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
-Signed-off-by: Khairul Anuar Romli <khairul.anuar.romli@intel.com>
----
- qapi/ui.json | 4 +++-
- ui/gtk.c     | 7 +++++++
- 2 files changed, 10 insertions(+), 1 deletion(-)
-
-diff --git a/qapi/ui.json b/qapi/ui.json
-index 398d1774ac..64c08c97f1 100644
---- a/qapi/ui.json
-+++ b/qapi/ui.json
-@@ -1144,6 +1144,7 @@
- # @show-cursor:   Force showing the mouse cursor (default: off).
- #                 (since: 5.0)
- # @gl:            Enable OpenGL support (default: off).
-+# @detach-all:    Detatch all VirtualConsoles from beginning (default: off).
- #
- # Since: 2.12
- #
-@@ -1153,7 +1154,8 @@
-                 '*full-screen'   : 'bool',
-                 '*window-close'  : 'bool',
-                 '*show-cursor'   : 'bool',
--                '*gl'            : 'DisplayGLMode' },
-+                '*gl'            : 'DisplayGLMode',
-+                '*detach-all'    : 'bool' },
-   'discriminator' : 'type',
-   'data'    : { 'gtk'            : 'DisplayGTK',
-                 'curses'         : 'DisplayCurses',
-diff --git a/ui/gtk.c b/ui/gtk.c
-index bb3861c135..460fae438b 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -2234,6 +2234,7 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     char *dir;
-     int monitor_n;
-     bool monitor_status = false;
-+    int i;
- 
-     if (!gtkinit) {
-         fprintf(stderr, "gtk initialization failed\n");
-@@ -2343,6 +2344,12 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
- 
- 
-     gd_clipboard_init(s);
-+
-+    if (opts->detach_all) {
-+        for (i = 0; i < s->nb_vcs - 1; i++) {
-+            gtk_menu_item_activate(GTK_MENU_ITEM(s->untabify_item));
-+        }
-+    }
- }
- 
- static void early_gtk_display_init(DisplayOptions *opts)
--- 
-2.17.1
-
diff --git a/host/qemu/0021-ui-gtk-specify-detached-window-s-size-and-location.patch b/host/qemu/0021-ui-gtk-specify-detached-window-s-size-and-location.patch
deleted file mode 100644
index b36cb32..0000000
--- a/host/qemu/0021-ui-gtk-specify-detached-window-s-size-and-location.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Mon, 19 Jul 2021 14:05:53 -0700
-Subject: [PATCH] ui/gtk: specify detached window's size and location
-
-Specify location and size of detached window based on top level window's
-location and size info when detachment happens. (rebased)
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk.c | 14 ++++++++++++++
- 1 file changed, 14 insertions(+)
-
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 460fae438b..b343e0ffd2 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -1285,6 +1285,8 @@ static void gd_menu_untabify(GtkMenuItem *item, void *opaque)
- {
-     GtkDisplayState *s = opaque;
-     VirtualConsole *vc = gd_vc_find_current(s);
-+    gint x, y, w, h;
-+    int i;
- 
-     if (vc->type == GD_VC_GFX &&
-         qemu_console_is_graphic(vc->gfx.dcl.con)) {
-@@ -1305,6 +1307,18 @@ static void gd_menu_untabify(GtkMenuItem *item, void *opaque)
-         }
- 
-         gd_widget_reparent(s->notebook, vc->window, vc->tab_item);
-+        gtk_window_get_position(GTK_WINDOW(s->window), &x, &y);
-+        gtk_window_get_size(GTK_WINDOW(s->window), &w, &h);
-+
-+        for (i = 0; i < s->nb_vcs; i++) {
-+            if (vc == &s->vc[i]) {
-+                break;
-+            }
-+        }
-+
-+        gtk_window_move(GTK_WINDOW(vc->window),
-+                        x + w * (i % (s->nb_vcs/2) + 1), y + h * (i / (s->nb_vcs/2)));
-+        gtk_window_resize(GTK_WINDOW(vc->window), w, h);
- 
-         g_signal_connect(vc->window, "delete-event",
-                          G_CALLBACK(gd_tab_window_close), vc);
--- 
-2.17.1
-
diff --git a/host/qemu/0022-ui-gtk-adds-status-bar-for-expressing-ups-and-fps.patch b/host/qemu/0022-ui-gtk-adds-status-bar-for-expressing-ups-and-fps.patch
deleted file mode 100644
index 317e5f2..0000000
--- a/host/qemu/0022-ui-gtk-adds-status-bar-for-expressing-ups-and-fps.patch
+++ /dev/null
@@ -1,200 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: "Mazlan, Hazwan Arif" <hazwan.arif.mazlan@intel.com>
-Date: Thu, 19 Aug 2021 22:10:47 +0800
-Subject: [PATCH] ui/gtk: adds status bar for expressing ups and fps
-
-With a display option, "show-fps=on", qemu adds a status bar and print
-following performance numbers on the bar,
-
-ups = update per seconds - the rate the guest scanout is updated.
-fps = frame per seconds - the frame rate of VC's GL drawing area
-
-One function, gd_gl_count_frame is added to count # frames
-and calculate ups and fps every 100 frames or guest scanout updates.
-(rebased)
-
-Signed-off-by: Kim, Dongwon <dongwon.kim@intel.com>
----
- include/ui/console.h |  4 ++++
- include/ui/gtk.h     |  2 ++
- qapi/ui.json         |  6 ++++--
- ui/console.c         |  6 ++++++
- ui/gtk.c             | 51 ++++++++++++++++++++++++++++++++++++++++++++
- 5 files changed, 67 insertions(+), 2 deletions(-)
-
-diff --git a/include/ui/console.h b/include/ui/console.h
-index 396795887e..27054af6b4 100644
---- a/include/ui/console.h
-+++ b/include/ui/console.h
-@@ -254,6 +254,8 @@ typedef struct DisplayChangeListenerOps {
-     void (*dpy_gl_update)(DisplayChangeListener *dcl,
-                           uint32_t x, uint32_t y, uint32_t w, uint32_t h);
- 
-+    /* optional */
-+    void (*dpy_gl_count_frame)(DisplayChangeListener *dcl, bool ups);
- } DisplayChangeListenerOps;
- 
- struct DisplayChangeListener {
-@@ -325,6 +327,8 @@ void dpy_gl_release_dmabuf(QemuConsole *con,
- void dpy_gl_update(QemuConsole *con,
-                    uint32_t x, uint32_t y, uint32_t w, uint32_t h);
- 
-+void dpy_gl_count_frame(QemuConsole *con, bool ups);
-+
- QEMUGLContext dpy_gl_ctx_create(QemuConsole *con,
-                                 QEMUGLParams *params);
- void dpy_gl_ctx_destroy(QemuConsole *con, QEMUGLContext ctx);
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index a25f5bfecc..86344ee42d 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -118,6 +118,7 @@ struct GtkDisplayState {
-     GtkWidget *show_tabs_item;
-     GtkWidget *untabify_item;
-     GtkWidget *show_menubar_item;
-+    GtkWidget *status_bar;
- 
-     GtkWidget *vbox;
-     GtkWidget *notebook;
-@@ -153,6 +154,7 @@ extern bool gtk_use_gl_area;
- void gd_update_windowsize(VirtualConsole *vc);
- int gd_monitor_update_interval(GtkWidget *widget);
- void gd_hw_gl_flushed(void *vc);
-+void gd_gl_count_frame(DisplayChangeListener *dcl, bool ups);
- 
- /* ui/gtk-egl.c */
- void gd_egl_init(VirtualConsole *vc);
-diff --git a/qapi/ui.json b/qapi/ui.json
-index 64c08c97f1..45c3f2475b 100644
---- a/qapi/ui.json
-+++ b/qapi/ui.json
-@@ -1145,7 +1145,8 @@
- #                 (since: 5.0)
- # @gl:            Enable OpenGL support (default: off).
- # @detach-all:    Detatch all VirtualConsoles from beginning (default: off).
--#
-+# @show-fps:      Enable showing Guest Scanout's update rate (UPS) and
-+#                 Surface render swap rate (FPS) on a status bar (default: off).
- # Since: 2.12
- #
- ##
-@@ -1155,7 +1156,8 @@
-                 '*window-close'  : 'bool',
-                 '*show-cursor'   : 'bool',
-                 '*gl'            : 'DisplayGLMode',
--                '*detach-all'    : 'bool' },
-+                '*detach-all'    : 'bool',
-+                '*show-fps'      : 'bool' },
-   'discriminator' : 'type',
-   'data'    : { 'gtk'            : 'DisplayGTK',
-                 'curses'         : 'DisplayCurses',
-diff --git a/ui/console.c b/ui/console.c
-index 2de5f4105b..31efdb0512 100644
---- a/ui/console.c
-+++ b/ui/console.c
-@@ -1924,6 +1924,12 @@ void dpy_gl_update(QemuConsole *con,
-     con->gl->ops->dpy_gl_update(con->gl, x, y, w, h);
- }
- 
-+void dpy_gl_count_frame(QemuConsole *con, bool ups)
-+{
-+    assert(con->gl);
-+    con->gl->ops->dpy_gl_count_frame(con->gl, ups);
-+}
-+
- /***********************************************************/
- /* register display */
- 
-diff --git a/ui/gtk.c b/ui/gtk.c
-index b343e0ffd2..d445178700 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -550,6 +550,47 @@ static void gd_switch(DisplayChangeListener *dcl,
-     }
- }
- 
-+void gd_gl_count_frame(DisplayChangeListener *dcl, bool ups)
-+{
-+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-+    gchar ups_fps_str[100];
-+    static guint prev, curr;
-+    static guint ups_cnt, fps_cnt, status_bar_id;
-+    struct timeval tv;
-+
-+    if (!vc->s->opts->show_fps) {
-+        return;
-+    }
-+
-+    if (prev == 0) {
-+        gettimeofday(&tv, NULL);
-+        prev = tv.tv_sec * 1000000 + tv.tv_usec;
-+    }
-+
-+    if (ups) {
-+        ups_cnt++;
-+    } else {
-+        fps_cnt++;
-+    }
-+
-+    /* update rate is calculated for every 200 frames */
-+    if (ups_cnt == 200 || fps_cnt == 200) {
-+        gettimeofday(&tv, NULL);
-+        curr = tv.tv_sec * 1000000 + tv.tv_usec;
-+        prev = curr - prev;
-+        sprintf(ups_fps_str, "UPS : %0.2f u/s  FPS : %0.2f f/s",
-+                ups_cnt * 1000000/(gfloat)prev, fps_cnt * 1000000/(gfloat)prev);
-+
-+        status_bar_id = gtk_statusbar_get_context_id(GTK_STATUSBAR(vc->s->status_bar),
-+                                                     "ups_fps_info");
-+        gtk_statusbar_pop(GTK_STATUSBAR(vc->s->status_bar), status_bar_id);
-+        gtk_statusbar_push(GTK_STATUSBAR(vc->s->status_bar), status_bar_id, ups_fps_str);
-+        prev = curr;
-+        fps_cnt = 0;
-+        ups_cnt = 0;
-+     }
-+}
-+
- static const DisplayChangeListenerOps dcl_ops = {
-     .dpy_name             = "gtk",
-     .dpy_gfx_update       = gd_update,
-@@ -558,6 +599,7 @@ static const DisplayChangeListenerOps dcl_ops = {
-     .dpy_refresh          = gd_refresh,
-     .dpy_mouse_set        = gd_mouse_set,
-     .dpy_cursor_define    = gd_cursor_define,
-+    .dpy_gl_count_frame   = gd_gl_count_frame,
- };
- 
- 
-@@ -640,6 +682,7 @@ static const DisplayChangeListenerOps dcl_egl_ops = {
-     .dpy_gl_update           = gd_egl_flush,
-     .dpy_gl_release_dmabuf   = gd_gl_release_dmabuf,
-     .dpy_has_dmabuf          = gd_has_dmabuf,
-+    .dpy_gl_count_frame      = gd_gl_count_frame,
- };
- 
- #endif
-@@ -2268,6 +2311,10 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     s->notebook = gtk_notebook_new();
-     s->menu_bar = gtk_menu_bar_new();
- 
-+     if (opts->show_fps) {
-+        s->status_bar = gtk_statusbar_new();
-+    }
-+
-     s->free_scale = FALSE;
- 
-     /* Mostly LC_MESSAGES only. See early_gtk_display_init() for details. For
-@@ -2308,6 +2355,10 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     gtk_box_pack_start(GTK_BOX(s->vbox), s->menu_bar, FALSE, TRUE, 0);
-     gtk_box_pack_start(GTK_BOX(s->vbox), s->notebook, TRUE, TRUE, 0);
- 
-+    if (opts->show_fps) {
-+        gtk_box_pack_start(GTK_BOX(s->vbox), s->status_bar, FALSE, TRUE, 0);
-+    }
-+
-     gtk_container_add(GTK_CONTAINER(s->window), s->vbox);
- 
-     gtk_widget_show_all(s->window);
--- 
-2.17.1
-
diff --git a/host/qemu/0023-ui-gtk-calling-gd_gl_frame_counter-at-every-draw-swa.patch b/host/qemu/0023-ui-gtk-calling-gd_gl_frame_counter-at-every-draw-swa.patch
deleted file mode 100644
index 50a5514..0000000
--- a/host/qemu/0023-ui-gtk-calling-gd_gl_frame_counter-at-every-draw-swa.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: "Mazlan, Hazwan Arif" <hazwan.arif.mazlan@intel.com>
-Date: Thu, 19 Aug 2021 23:20:12 +0800
-Subject: [PATCH] ui/gtk: calling gd_gl_frame_counter at every draw/swap
-
-For FPS calculation, gd_gl_frame_counter is called at every
-draw(gtk-gl-area) or swap(gtk-egl) activity.
-
-Signed-off-by: Dongwon, Kim <dongwon.kim@intel.com>
----
- ui/gtk-egl.c     | 2 ++
- ui/gtk-gl-area.c | 1 +
- 2 files changed, 3 insertions(+)
-
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index d96804ff7f..94e8649747 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -103,6 +103,7 @@ void gd_egl_draw(VirtualConsole *vc)
- 
-         eglSwapBuffers(qemu_egl_display, vc->gfx.esurface);
- 
-+        gd_gl_count_frame(&vc->gfx.dcl, false);
-         vc->gfx.scale_x = (double)ww / surface_width(vc->gfx.ds);
-         vc->gfx.scale_y = (double)wh / surface_height(vc->gfx.ds);
-     }
-@@ -327,6 +328,7 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-     }
- 
-     eglSwapBuffers(qemu_egl_display, vc->gfx.esurface);
-+    gd_gl_count_frame(&vc->gfx.dcl, false);
- }
- 
- void gd_egl_flush(DisplayChangeListener *dcl,
-diff --git a/ui/gtk-gl-area.c b/ui/gtk-gl-area.c
-index 4ea64736c5..f68e9d6b7a 100644
---- a/ui/gtk-gl-area.c
-+++ b/ui/gtk-gl-area.c
-@@ -85,6 +85,7 @@ void gd_gl_area_draw(VirtualConsole *vc)
-         egl_dmabuf_create_sync(dmabuf);
-     }
-     glFlush();
-+    gd_gl_count_frame(&vc->gfx.dcl, false);
-     if (dmabuf) {
-         egl_dmabuf_create_fence(dmabuf);
-         if (dmabuf->fence_fd > 0) {
--- 
-2.17.1
-
diff --git a/host/qemu/0024-virtio-gpu-call-dpy_gl_frame_counter-at-every-guest-.patch b/host/qemu/0024-virtio-gpu-call-dpy_gl_frame_counter-at-every-guest-.patch
deleted file mode 100644
index e2ff696..0000000
--- a/host/qemu/0024-virtio-gpu-call-dpy_gl_frame_counter-at-every-guest-.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: "Mazlan, Hazwan Arif" <hazwan.arif.mazlan@intel.com>
-Date: Thu, 19 Aug 2021 23:24:53 +0800
-Subject: [PATCH] virtio-gpu: call dpy_gl_frame_counter at every guest scanout
- flush
-
-dpy_gl_frame_counter needs to be called for guest scanout frame count
-to calculate and display the performance figure - ups, the guest FB
-update per seconds.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- hw/display/virtio-gpu.c | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index 3c5d9e9258..dcae5cbaa7 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -525,6 +525,7 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
-                               scanout->height);
-             }
-         }
-+        dpy_gl_count_frame(scanout->con, true);
-         return;
-     }
- 
-@@ -570,6 +571,7 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,
-         pixman_region_fini(&region);
-         pixman_region_fini(&finalregion);
-     }
-+    dpy_gl_count_frame(scanout->con, true);
-     pixman_region_fini(&flush_region);
- }
- 
--- 
-2.17.1
-
diff --git a/host/qemu/0025-hw-display-virtio-gpu-Fix-memory-leak-CID-1453811.patch b/host/qemu/0025-hw-display-virtio-gpu-Fix-memory-leak-CID-1453811.patch
deleted file mode 100644
index 11d9e4b..0000000
--- a/host/qemu/0025-hw-display-virtio-gpu-Fix-memory-leak-CID-1453811.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Philippe=2C=20Mathieu-Daud=C3=A9?= <philmd@redhat.com>
-Date: Mon, 31 May 2021 12:19:28 +0200
-Subject: [PATCH] hw/display/virtio-gpu: Fix memory leak (CID 1453811)
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-To avoid leaking memory on the error path, reorder the
-code as:
-- check the parameters first
-- check resource already existing
-- finally allocate memory
-
-Reported-by: Coverity (CID 1453811: RESOURCE_LEAK)
-Fixes: e0933d91b1c ("virtio-gpu: Add virtio_gpu_resource_create_blob")
-Signed-off-by: Philippe Mathieu-Daud√© <philmd@redhat.com>
-Message-Id: <20210531101928.1662732-1-philmd@redhat.com>
-Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
----
- hw/display/virtio-gpu.c | 26 ++++++++++----------------
- 1 file changed, 10 insertions(+), 16 deletions(-)
-
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index dcae5cbaa7..eac488612b 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -340,37 +340,31 @@ static void virtio_gpu_resource_create_blob(VirtIOGPU *g,
-         return;
-     }
- 
--    res = virtio_gpu_find_resource(g, cblob.resource_id);
--    if (res) {
--        qemu_log_mask(LOG_GUEST_ERROR, "%s: resource already exists %d\n",
--                      __func__, cblob.resource_id);
--        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
--        return;
--    }
--
--    res = g_new0(struct virtio_gpu_simple_resource, 1);
--    res->resource_id = cblob.resource_id;
--    res->blob_size = cblob.size;
--
-     if (cblob.blob_mem != VIRTIO_GPU_BLOB_MEM_GUEST &&
-         cblob.blob_flags != VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE) {
-         qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid memory type\n",
-                       __func__);
-         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
--        g_free(res);
-         return;
-     }
- 
--    if (res->iov) {
--        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+    if (virtio_gpu_find_resource(g, cblob.resource_id)) {
-+        qemu_log_mask(LOG_GUEST_ERROR, "%s: resource already exists %d\n",
-+                      __func__, cblob.resource_id);
-+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-         return;
-     }
- 
-+    res = g_new0(struct virtio_gpu_simple_resource, 1);
-+    res->resource_id = cblob.resource_id;
-+    res->blob_size = cblob.size;
-+
-     ret = virtio_gpu_create_mapping_iov(g, cblob.nr_entries, sizeof(cblob),
-                                         cmd, &res->addrs, &res->iov,
-                                         &res->iov_cnt);
--    if (ret != 0) {
-+    if (ret != 0 || res->iov) {
-         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-+        g_free(res);
-         return;
-     }
- 
--- 
-2.17.1
-
diff --git a/host/qemu/0026-virtio-gpu-no-point-of-checking-res-iov.patch b/host/qemu/0026-virtio-gpu-no-point-of-checking-res-iov.patch
deleted file mode 100644
index 88c4261..0000000
--- a/host/qemu/0026-virtio-gpu-no-point-of-checking-res-iov.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Mon, 30 Aug 2021 10:37:28 -0700
-Subject: [PATCH] virtio-gpu: no point of checking res->iov
-
-The code should check the opposite condition of res->iov because it will be null
-if virtio_gpu_create_mapping_iov fails and actually this checking is not even
-required because checking on ret covers all failing cases.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- hw/display/virtio-gpu.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c
-index eac488612b..cb5375368a 100644
---- a/hw/display/virtio-gpu.c
-+++ b/hw/display/virtio-gpu.c
-@@ -362,7 +362,7 @@ static void virtio_gpu_resource_create_blob(VirtIOGPU *g,
-     ret = virtio_gpu_create_mapping_iov(g, cblob.nr_entries, sizeof(cblob),
-                                         cmd, &res->addrs, &res->iov,
-                                         &res->iov_cnt);
--    if (ret != 0 || res->iov) {
-+    if (ret != 0) {
-         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
-         g_free(res);
-         return;
--- 
-2.17.1
-
diff --git a/host/qemu/0027-ui-gtk-egl-dmabuf-scanout-only-when-scanout_mode-is-.patch b/host/qemu/0027-ui-gtk-egl-dmabuf-scanout-only-when-scanout_mode-is-.patch
deleted file mode 100644
index f1bb823..0000000
--- a/host/qemu/0027-ui-gtk-egl-dmabuf-scanout-only-when-scanout_mode-is-.patch
+++ /dev/null
@@ -1,88 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Fri, 27 Aug 2021 13:06:52 -0700
-Subject: [PATCH] ui/gtk-egl: dmabuf scanout only when scanout_mode is on in
- gd_egl_draw
-
-dmabuf buf related code path (checkes on flag and mutex protection) only
-if scanout_mode is set as it's not relevant to the normal draw path.
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk-egl.c | 44 ++++++++++++++++++++------------------------
- 1 file changed, 20 insertions(+), 24 deletions(-)
-
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 94e8649747..298b7c8f4e 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -74,25 +74,31 @@ void gd_egl_draw(VirtualConsole *vc)
-     ww = gdk_window_get_width(window);
-     wh = gdk_window_get_height(window);
- 
--    if (dmabuf) {
--       qemu_mutex_lock(&dmabuf->mutex);
--       if (!dmabuf->draw_submitted) {
--           qemu_mutex_unlock(&dmabuf->mutex);
--           return;
--       } else {
--          dmabuf->draw_submitted = false;
--       }
--    }
-     if (vc->gfx.scanout_mode) {
-+        if (dmabuf) {
-+            if (!dmabuf->draw_submitted) {
-+                return;
-+            } else {
-+                dmabuf->draw_submitted = false;
-+            }
-+        }
-         gd_egl_scanout_flush(&vc->gfx.dcl, 0, 0, vc->gfx.w, vc->gfx.h);
- 
-         vc->gfx.scale_x = (double)ww / vc->gfx.w;
-         vc->gfx.scale_y = (double)wh / vc->gfx.h;
-+
-+        glFlush();
-+        if (dmabuf) {
-+            egl_dmabuf_create_fence(dmabuf);
-+            if (dmabuf->fence_fd > 0) {
-+                qemu_set_fd_handler(dmabuf->fence_fd, gd_hw_gl_flushed, NULL, vc);
-+                return;
-+            }
-+            graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+        }
-+        graphic_hw_gl_flushed(vc->gfx.dcl.con);
-     } else {
-         if (!vc->gfx.ds) {
--            if (dmabuf) {
--                qemu_mutex_unlock(&dmabuf->mutex);
--            }
-             return;
-         }
-         eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
-@@ -106,20 +112,10 @@ void gd_egl_draw(VirtualConsole *vc)
-         gd_gl_count_frame(&vc->gfx.dcl, false);
-         vc->gfx.scale_x = (double)ww / surface_width(vc->gfx.ds);
-         vc->gfx.scale_y = (double)wh / surface_height(vc->gfx.ds);
--    }
- 
--    glFlush();
--    if (dmabuf) {
--        egl_dmabuf_create_fence(dmabuf);
--        if (dmabuf->fence_fd > 0) {
--            qemu_set_fd_handler(dmabuf->fence_fd, gd_hw_gl_flushed, NULL, vc);
--	    qemu_mutex_unlock(&dmabuf->mutex);
--            return;
--        }
--        graphic_hw_gl_block(vc->gfx.dcl.con, false);
--	qemu_mutex_unlock(&dmabuf->mutex);
-+        glFlush();
-+        graphic_hw_gl_flushed(vc->gfx.dcl.con);
-     }
--    graphic_hw_gl_flushed(vc->gfx.dcl.con);
- }
- 
- void gd_egl_update(DisplayChangeListener *dcl,
--- 
-2.17.1
-
diff --git a/host/qemu/0028-ui-gtk-graphic_hw_gl_flushed-after-closing-dmabuf-fe.patch b/host/qemu/0028-ui-gtk-graphic_hw_gl_flushed-after-closing-dmabuf-fe.patch
deleted file mode 100644
index 1742994..0000000
--- a/host/qemu/0028-ui-gtk-graphic_hw_gl_flushed-after-closing-dmabuf-fe.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Sun, 21 Nov 2021 09:25:40 -0800
-Subject: [PATCH] ui/gtk: graphic_hw_gl_flushed after closing dmabuf->fence_fd
-
-The dmabuf often becomes invalid right after unblocking pipeline
-and graphic_hw_gl_flushed in case a new scanout blob is submitted
-because the dmabuf associated with the current guest scanout is
-freed after swapping.
-
-So both graphic_hw_gl_block and graphic_hw_gl_flushed should be
-executed after closing fence_fd for the current dmabuf.
-
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- ui/gtk.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/ui/gtk.c b/ui/gtk.c
-index d445178700..e8ea685936 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -631,11 +631,11 @@ void gd_hw_gl_flushed(void *vcon)
-     VirtualConsole *vc = vcon;
-     QemuDmaBuf *dmabuf = vc->gfx.guest_fb.dmabuf;
- 
--    graphic_hw_gl_block(vc->gfx.dcl.con, false);
--    graphic_hw_gl_flushed(vc->gfx.dcl.con);
-     qemu_set_fd_handler(dmabuf->fence_fd, NULL, NULL, NULL);
-     close(dmabuf->fence_fd);
-     dmabuf->fence_fd = -1;
-+    graphic_hw_gl_block(vc->gfx.dcl.con, false);
-+    graphic_hw_gl_flushed(vc->gfx.dcl.con);
- }
- 
- /** DisplayState Callbacks (opengl version) **/
--- 
-2.17.1
-
diff --git a/host/qemu/0029-ui-gtk-revert-full-screen-on.-optional-param.patch b/host/qemu/0029-ui-gtk-revert-full-screen-on.-optional-param.patch
deleted file mode 100644
index 8d1ffca..0000000
--- a/host/qemu/0029-ui-gtk-revert-full-screen-on.-optional-param.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Tue, 23 Nov 2021 18:25:01 -0800
-Subject: [PATCH] ui/gtk: revert full-screen-on... optional param
-
-not needed as it will be replaced with "monitor"
-
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- qapi/ui.json    |  7 +------
- qemu-options.hx |  2 +-
- ui/gtk.c        | 31 -------------------------------
- 3 files changed, 2 insertions(+), 38 deletions(-)
-
-diff --git a/qapi/ui.json b/qapi/ui.json
-index 45c3f2475b..7aec34a18e 100644
---- a/qapi/ui.json
-+++ b/qapi/ui.json
-@@ -1035,17 +1035,12 @@
- #               assuming the guest will resize the display to match
- #               the window size then.  Otherwise it defaults to "off".
- #               Since 3.1
--# @full-screen-on-monitor: Monitor number to display QEMU in full screen.
--#                          Monitor number started from index 1. If total number
--#                          of monitors is 3, possible values for this option are
--#                          1, 2 or 3.
- # Since: 2.12
- #
- ##
- { 'struct'  : 'DisplayGTK',
-   'data'    : { '*grab-on-hover' : 'bool',
--                '*zoom-to-fit'   : 'bool',
--		'*full-screen-on-monitor' : 'int' } }
-+                '*zoom-to-fit'   : 'bool' } }
- ##
- # @DisplayEGLHeadless:
- #
-diff --git a/qemu-options.hx b/qemu-options.hx
-index d0bb48c728..4a2a109d9d 100644
---- a/qemu-options.hx
-+++ b/qemu-options.hx
-@@ -1775,7 +1775,7 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
-     "            [,window_close=on|off][,gl=on|core|es|off]\n"
- #endif
- #if defined(CONFIG_GTK)
--    "-display gtk[,grab-on-hover=on|off][,gl=on|off][,full-screen-on-monitor=<value>]\n"
-+    "-display gtk[,grab-on-hover=on|off][,gl=on|off]\n"
- #endif
- #if defined(CONFIG_VNC)
-     "-display vnc=<display>[,<optargs>]\n"
-diff --git a/ui/gtk.c b/ui/gtk.c
-index e8ea685936..1e648dbaf7 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -2289,8 +2289,6 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     GdkDisplay *window_display;
-     GtkIconTheme *theme;
-     char *dir;
--    int monitor_n;
--    bool monitor_status = false;
-     int i;
- 
-     if (!gtkinit) {
-@@ -2379,35 +2377,6 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-         gtk_menu_item_activate(GTK_MENU_ITEM(s->grab_on_hover_item));
-     }
- 
--     if (opts->u.gtk.has_full_screen_on_monitor) {
--        monitor_n = gdk_display_get_n_monitors(window_display);
--
--        if (opts->u.gtk.full_screen_on_monitor <= monitor_n &&
--            opts->u.gtk.full_screen_on_monitor > 0) {
--            gtk_window_fullscreen_on_monitor(GTK_WINDOW(s->window),
--                gdk_display_get_default_screen(window_display),
--                opts->u.gtk.full_screen_on_monitor - 1);
--
--            if (gdk_display_get_monitor(window_display,
--                                        opts->u.gtk.full_screen_on_monitor
--                                        - 1) != NULL) {
--                monitor_status = true;
--            }
--        }
--        if (monitor_status == false) {
--            /*
--             * Calling GDK API to read the number of monitors again in case
--             * monitor added or removed since last read.
--             */
--            monitor_n = gdk_display_get_n_monitors(window_display);
--            warn_report("Failed to enable full screen on monitor %" PRId64 ". "
--                        "Current total number of monitors is %d, "
--                        "please verify full-screen-on-monitor option value.",
--                        opts->u.gtk.full_screen_on_monitor, monitor_n);
--        }
--    }
--
--
-     gd_clipboard_init(s);
- 
-     if (opts->detach_all) {
--- 
-2.17.1
-
diff --git a/host/qemu/0030-ui-gtk-new-param-monitor-to-specify-target-monitor-f.patch b/host/qemu/0030-ui-gtk-new-param-monitor-to-specify-target-monitor-f.patch
deleted file mode 100644
index 2535715..0000000
--- a/host/qemu/0030-ui-gtk-new-param-monitor-to-specify-target-monitor-f.patch
+++ /dev/null
@@ -1,98 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Dongwon Kim <dongwon.kim@intel.com>
-Date: Tue, 23 Nov 2021 18:30:42 -0800
-Subject: [PATCH] ui/gtk: new param monitor to specify target monitor for
- launching QEMU
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-(currently upstreaming wip)
-
-Introducing a new integer parameter to specify the monitor where the
-Qemu window is placed upon launching.
-
-Monitor can be any number between 0 and (total number of monitors - 1).
-
-It can be used together with full-screen=on, which will make the QEMU
-window full-screened on the targeted monitor.
-
-v2: fixed typos and updated commit subject and msg
-    (Philippe Mathieu-Daud√©)
-
-    changed param name to monitor, removed unnecessary condition check
-    on the parameter
-    (Paolo Bonzini)
-
-Cc: Philippe Mathieu-Daud√© <philmd@redhat.com>
-Cc: Paolo Bonzini <pbonzini@redhat.com>
-Cc: Gerd Hoffmann <kraxel@redhat.com>
-Cc: Vivek Kasireddy <vivek.kasireddy@intel.com>
-Cc: sweeaun <swee.aun.khor@intel.com>
-Cc: Khairul Anuar Romli <khairul.anuar.romli@intel.com>
-Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
----
- qapi/ui.json    | 7 ++++++-
- qemu-options.hx | 2 +-
- ui/gtk.c        | 9 ++++++++-
- 3 files changed, 15 insertions(+), 3 deletions(-)
-
-diff --git a/qapi/ui.json b/qapi/ui.json
-index 7aec34a18e..09bf92b844 100644
---- a/qapi/ui.json
-+++ b/qapi/ui.json
-@@ -1035,12 +1035,17 @@
- #               assuming the guest will resize the display to match
- #               the window size then.  Otherwise it defaults to "off".
- #               Since 3.1
-+# @monitor:     Indicate monitor where QEMU window is lauched. monitor
-+#               could be any number from 0 to (total num of monitors - 1).
-+#               since 7.0
- # Since: 2.12
- #
- ##
- { 'struct'  : 'DisplayGTK',
-   'data'    : { '*grab-on-hover' : 'bool',
--                '*zoom-to-fit'   : 'bool' } }
-+                '*zoom-to-fit'   : 'bool',
-+                '*monitor'       : 'uint32' } }
-+
- ##
- # @DisplayEGLHeadless:
- #
-diff --git a/qemu-options.hx b/qemu-options.hx
-index 4a2a109d9d..49ad4fd4bd 100644
---- a/qemu-options.hx
-+++ b/qemu-options.hx
-@@ -1775,7 +1775,7 @@ DEF("display", HAS_ARG, QEMU_OPTION_display,
-     "            [,window_close=on|off][,gl=on|core|es|off]\n"
- #endif
- #if defined(CONFIG_GTK)
--    "-display gtk[,grab-on-hover=on|off][,gl=on|off]\n"
-+    "-display gtk[,grab-on-hover=on|off][,gl=on|off][,monitor=<value>]\n"
- #endif
- #if defined(CONFIG_VNC)
-     "-display vnc=<display>[,<optargs>]\n"
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 1e648dbaf7..6ab7c2ed77 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -2367,7 +2367,14 @@ static void gtk_display_init(DisplayState *ds, DisplayOptions *opts)
-     gtk_widget_set_sensitive(s->copy_item,
-                              vc && vc->type == GD_VC_VTE);
- #endif
--
-+    if (opts->u.gtk.has_monitor &&
-+        opts->u.gtk.monitor < gdk_display_get_n_monitors(window_display)) {
-+        GdkRectangle mon_dest;
-+        gdk_monitor_get_geometry(
-+            gdk_display_get_monitor(window_display, opts->u.gtk.monitor),
-+            &mon_dest);
-+        gtk_window_move(GTK_WINDOW(s->window), mon_dest.x, mon_dest.y);
-+    }
-     if (opts->has_full_screen &&
-         opts->full_screen) {
-         gtk_menu_item_activate(GTK_MENU_ITEM(s->full_screen_item));
--- 
-2.17.1
-
diff --git a/host/qemu/0032-Adapt-APP-landscape-or-portrait-mode-display-dynamic.patch b/host/qemu/0032-Adapt-APP-landscape-or-portrait-mode-display-dynamic.patch
deleted file mode 100644
index f13fd98..0000000
--- a/host/qemu/0032-Adapt-APP-landscape-or-portrait-mode-display-dynamic.patch
+++ /dev/null
@@ -1,236 +0,0 @@
-From a78e248316e91cb2827878f2173caedd1076373e Mon Sep 17 00:00:00 2001
-From: renchenglei <chenglei.ren@intel.com>
-Date: Tue, 19 Apr 2022 17:49:22 +0800
-Subject: [PATCH] Adapt APP landscape or portrait mode display dynamically
-
-Add one gtk button to set window to landscape/portrait
-mode.
-
-Tracked-On: OAM-101263
-Signed-off-by: Chenglei Ren <chenglei.ren@intel.com>
----
- include/ui/gtk.h                 |  1 +
- include/ui/shader.h              |  1 +
- ui/egl-helpers.c                 |  4 ++++
- ui/gtk-egl.c                     |  2 ++
- ui/gtk.c                         | 28 ++++++++++++++++++++++++++--
- ui/shader.c                      | 19 ++++++++++++++++++-
- ui/shader/texture-blit-flip.vert |  6 ++++++
- ui/shader/texture-blit.vert      |  6 ++++++
- 8 files changed, 64 insertions(+), 3 deletions(-)
-
-diff --git a/include/ui/gtk.h b/include/ui/gtk.h
-index 86344ee42d22..e363a8aa865e 100644
---- a/include/ui/gtk.h
-+++ b/include/ui/gtk.h
-@@ -111,6 +111,7 @@ struct GtkDisplayState {
-     GtkWidget *zoom_fit_item;
-     GtkWidget *grab_item;
-     GtkWidget *grab_on_hover_item;
-+    GtkWidget *window_rotation;
- 
-     int nb_vcs;
-     VirtualConsole vc[MAX_VCS];
-diff --git a/include/ui/shader.h b/include/ui/shader.h
-index 4c5acb2ce8b2..84b7ead88615 100644
---- a/include/ui/shader.h
-+++ b/include/ui/shader.h
-@@ -6,6 +6,7 @@
- typedef struct QemuGLShader QemuGLShader;
- 
- void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip);
-+void qemu_gl_load_rotation(QemuGLShader *gls, bool flip, int rotation);
- 
- QemuGLShader *qemu_gl_init_shader(void);
- void qemu_gl_fini_shader(QemuGLShader *gls);
-diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
-index e7d84febc578..3a1c6765bd1f 100644
---- a/ui/egl-helpers.c
-+++ b/ui/egl-helpers.c
-@@ -155,10 +155,14 @@ void egl_fb_read(DisplaySurface *dst, egl_fb *src)
- 
- void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip)
- {
-+    int rotation = 0;
-     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
-     glViewport(0, 0, dst->width, dst->height);
-     glEnable(GL_TEXTURE_2D);
-     glBindTexture(GL_TEXTURE_2D, src->texture);
-+    if (dst->width < dst->height)
-+        rotation = 3;
-+    qemu_gl_load_rotation(gls, flip, rotation);
-     qemu_gl_run_texture_blit(gls, flip);
- }
- 
-diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
-index 298b7c8f4ef8..ca0bcf8818f4 100644
---- a/ui/gtk-egl.c
-+++ b/ui/gtk-egl.c
-@@ -317,6 +317,8 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
-                           vc->gfx.scale_x, vc->gfx.scale_y);
-     } else {
-         egl_fb_blit(&vc->gfx.win_fb, &vc->gfx.guest_fb, !vc->gfx.y0_top);
-+        egl_texture_blit(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.guest_fb,
-+                         vc->gfx.y0_top);
-     }
- 
-     if (vc->gfx.guest_fb.dmabuf) {
-diff --git a/ui/gtk.c b/ui/gtk.c
-index 6ab7c2ed77e3..0a52b601b36e 100644
---- a/ui/gtk.c
-+++ b/ui/gtk.c
-@@ -116,6 +116,8 @@
- 
- #define HOTKEY_MODIFIERS        (GDK_CONTROL_MASK | GDK_MOD1_MASK)
- 
-+static bool rotation = false;
-+
- static const guint16 *keycode_map;
- static size_t keycode_maplen;
- 
-@@ -274,8 +276,14 @@ static void gd_update_geometry_hints(VirtualConsole *vc)
-             geo.min_height = surface_height(vc->gfx.ds) * VC_SCALE_MIN;
-             mask |= GDK_HINT_MIN_SIZE;
-         } else {
--            geo.min_width  = surface_width(vc->gfx.ds) * vc->gfx.scale_x;
--            geo.min_height = surface_height(vc->gfx.ds) * vc->gfx.scale_y;
-+            if (rotation) {
-+                geo.min_height  = surface_width(vc->gfx.ds) * vc->gfx.scale_x;
-+                geo.min_width = surface_height(vc->gfx.ds) * vc->gfx.scale_y;
-+                rotation = false;
-+            } else {
-+                geo.min_width  = surface_width(vc->gfx.ds) * vc->gfx.scale_x;
-+                geo.min_height = surface_height(vc->gfx.ds) * vc->gfx.scale_y;
-+            }
-             mask |= GDK_HINT_MIN_SIZE;
-         }
-         geo_widget = vc->gfx.drawing_area;
-@@ -1436,6 +1444,17 @@ static void gd_menu_full_screen(GtkMenuItem *item, void *opaque)
-     gd_update_cursor(vc);
- }
- 
-+static void gd_menu_window_rotation(GtkMenuItem *item, void *opaque)
-+{
-+    GtkDisplayState *s = opaque;
-+    VirtualConsole *vc = gd_vc_find_current(s);
-+
-+    s->free_scale = FALSE;
-+    rotation = true;
-+    gd_update_windowsize(vc);
-+    gd_update_full_redraw(vc);
-+}
-+
- static void gd_accel_full_screen(void *opaque)
- {
-     GtkDisplayState *s = opaque;
-@@ -2012,6 +2031,8 @@ static void gd_connect_signals(GtkDisplayState *s)
-                      G_CALLBACK(gd_menu_grab_input), s);
-     g_signal_connect(s->notebook, "switch-page",
-                      G_CALLBACK(gd_change_page), s);
-+    g_signal_connect(s->window_rotation, "activate",
-+                     G_CALLBACK(gd_menu_window_rotation), s);
- }
- 
- static GtkWidget *gd_create_menu_machine(GtkDisplayState *s)
-@@ -2162,6 +2183,9 @@ static GtkWidget *gd_create_menu_view(GtkDisplayState *s)
-     gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), s->copy_item);
- #endif
- 
-+    s->window_rotation = gtk_check_menu_item_new_with_mnemonic(_("_Rotation"));
-+    gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), s->window_rotation);
-+
-     gtk_accel_group_connect(s->accel_group, GDK_KEY_f, HOTKEY_MODIFIERS, 0,
-             g_cclosure_new_swap(G_CALLBACK(gd_accel_full_screen), s, NULL));
-     gtk_accel_label_set_accel(
-diff --git a/ui/shader.c b/ui/shader.c
-index e8b8d321b7c7..d2de7cd07ef7 100644
---- a/ui/shader.c
-+++ b/ui/shader.c
-@@ -31,6 +31,8 @@
- #include "ui/shader/texture-blit-flip-vert.h"
- #include "ui/shader/texture-blit-frag.h"
- 
-+#include <math.h>
-+
- struct QemuGLShader {
-     GLint texture_blit_prog;
-     GLint texture_blit_flip_prog;
-@@ -47,7 +49,8 @@ static GLuint qemu_gl_init_texture_blit(GLint texture_blit_prog)
-         -1,  1,
-         1,   1,
-     };
--    GLint l_position;
-+    static float rotation = 0.0;
-+    GLint l_position, l_rotation;
-     GLuint vao, buffer;
- 
-     glGenVertexArrays(1, &vao);
-@@ -63,6 +66,9 @@ static GLuint qemu_gl_init_texture_blit(GLint texture_blit_prog)
-     glVertexAttribPointer(l_position, 2, GL_FLOAT, GL_FALSE, 0, 0);
-     glEnableVertexAttribArray(l_position);
- 
-+    l_rotation = glGetUniformLocation(texture_blit_prog, "in_rotation");
-+    glUniform1f(l_rotation, M_PI / 2.0 * rotation);
-+
-     glBindBuffer(GL_ARRAY_BUFFER, 0);
-     glBindVertexArray(0);
- 
-@@ -78,6 +84,17 @@ void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip)
-     glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
- }
- 
-+void qemu_gl_load_rotation(QemuGLShader *gls, bool flip, int rotation)
-+{
-+   GLint l_rotation;
-+   glUseProgram(flip
-+                 ? gls->texture_blit_flip_prog
-+                 : gls->texture_blit_prog);
-+   l_rotation = glGetUniformLocation((flip ? gls->texture_blit_flip_prog: gls->texture_blit_prog),
-+                                     "in_rotation");
-+   glUniform1f(l_rotation, M_PI / 2.0 * rotation);
-+}
-+
- /* ---------------------------------------------------------------------- */
- 
- static GLuint qemu_gl_create_compile_shader(GLenum type, const GLchar *src)
-diff --git a/ui/shader/texture-blit-flip.vert b/ui/shader/texture-blit-flip.vert
-index ba081fa5a6c3..6071804f7f61 100644
---- a/ui/shader/texture-blit-flip.vert
-+++ b/ui/shader/texture-blit-flip.vert
-@@ -3,8 +3,14 @@
- 
- in vec2  in_position;
- out vec2 ex_tex_coord;
-+uniform float in_rotation;
- 
- void main(void) {
-     gl_Position = vec4(in_position, 0.0, 1.0);
-+    mat4 rotationMatrix = mat4(cos(in_rotation), sin(in_rotation), 0.0, 0.0,
-+                               -sin(in_rotation), cos(in_rotation), 0.0, 0.0,
-+                               0.0, 0.0, 1.0, 0.0,
-+                               0.0, 0.0, 0.0, 1.0);
-+    gl_Position = rotationMatrix * gl_Position;
-     ex_tex_coord = vec2(1.0 + in_position.x, 1.0 + in_position.y) * 0.5;
- }
-diff --git a/ui/shader/texture-blit.vert b/ui/shader/texture-blit.vert
-index 6fe2744d6849..26fca7902457 100644
---- a/ui/shader/texture-blit.vert
-+++ b/ui/shader/texture-blit.vert
-@@ -3,8 +3,14 @@
- 
- in vec2  in_position;
- out vec2 ex_tex_coord;
-+uniform float in_rotation;
- 
- void main(void) {
-     gl_Position = vec4(in_position, 0.0, 1.0);
-+    mat4 rotationMatrix = mat4(cos(in_rotation), sin(in_rotation), 0.0, 0.0,
-+                               -sin(in_rotation), cos(in_rotation), 0.0, 0.0,
-+                               0.0, 0.0, 1.0, 0.0,
-+                               0.0, 0.0, 0.0, 1.0);
-+    gl_Position = rotationMatrix * gl_Position;
-     ex_tex_coord = vec2(1.0 + in_position.x, 1.0 - in_position.y) * 0.5;
- }
--- 
-2.17.1
-
-- 
2.36.1

